<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>object</title>
        </head><body>
        <h1>object</h1>
        <!-- Generated by Ddoc from src\object_.d -->
Forms the symbols available to all D programs. Includes Object, which is
 the root of the class <u>object</u> hierarchy.  This module is implicitly
 imported.
<br><br>
<b>License:</b><br>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.
<br><br>
<b>Authors:</b><br>
Walter Bright, Sean Kelly<br><br>

<dl><dt><big>class <u>Object</u>;
</big></dt>
<dd>All D class objects inherit from <u>Object</u>.<br><br>

<dl><dt><big>string <u>toString</u>();
</big></dt>
<dd>Convert Object to a human readable string.<br><br>

</dd>
<dt><big>hash_t <u>toHash</u>();
</big></dt>
<dd>Compute hash function for Object.<br><br>

</dd>
<dt><big>int <u>opCmp</u>(Object <i>o</i>);
</big></dt>
<dd>Compare with another Object obj.
<br><br>
<b>Returns:</b><br>
<table> <tr><td>this &lt; obj</td> <td>&lt; 0</td></tr>
  <tr><td>this == obj</td> <td>0</td></tr>
  <tr><td>this &gt; obj</td> <td>&gt; 0</td></tr>
  </table><br><br>

</dd>
<dt><big>equals_t <u>opEquals</u>(Object <i>o</i>);
</big></dt>
<dd>Returns !=0 if this object does have the same contents as obj.<br><br>

</dd>
<dt><big>static Object <u>factory</u>(string <i>classname</i>);
</big></dt>
<dd>Create instance of class specified by <i>classname</i>.
 The class must either have no constructors or have
 a default constructor.
<br><br>
<b>Returns:</b><br>
<b>null</b> if failed<br><br>

</dd>
</dl>
</dd>
<dt><big>bool <u>opEquals</u>(Object <i>lhs</i>, Object <i>rhs</i>);
</big></dt>
<dd>Returns <b>true</b> if <i>lhs</i> and <i>rhs</i> are equal.<br><br>

</dd>
<dt><big>struct <u>Interface</u>;
</big></dt>
<dd>Information about an interface.
 When an object is accessed via an interface, an <u>Interface</u>* appears as the
 first entry in its vtbl.<br><br>

<dl><dt><big>TypeInfo_Class <u>classinfo</u>;
</big></dt>
<dd>.<u>classinfo</u> for this interface (not for containing class)<br><br>

</dd>
<dt><big>ptrdiff_t <u>offset</u>;
</big></dt>
<dd><u>offset</u> to Interface 'this' from Object 'this'<br><br>

</dd>
</dl>
</dd>
<dt><big>alias <u>Classinfo</u>;
</big></dt>
<dd>Runtime type information about a class. Can be retrieved for any class type
 or instance by using the .classinfo property.
 A pointer to this appears as the first entry in the class's vtbl[].<br><br>

</dd>
<dt><big>struct <u>OffsetTypeInfo</u>;
</big></dt>
<dd>Array of pairs giving the offset and type information for each
 member in an aggregate.<br><br>

<dl><dt><big>size_t <u>offset</u>;
</big></dt>
<dd>Offset of member from start of object<br><br>

</dd>
<dt><big>TypeInfo <u>ti</u>;
</big></dt>
<dd>TypeInfo for this member<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>TypeInfo</u>;
</big></dt>
<dd>Runtime type information about a type.
 Can be retrieved for any type using a
 <a href="../expression.html#typeidexpression">TypeidExpression</a>.<br><br>

<dl><dt><big>hash_t <u>getHash</u>(in void* <i>p</i>);
</big></dt>
<dd>Returns a hash of the instance of a type.<br><br>

</dd>
<dt><big>equals_t <u>equals</u>(in void* <i>p1</i>, in void* <i>p2</i>);
</big></dt>
<dd>Compares two instances for equality.<br><br>

</dd>
<dt><big>int <u>compare</u>(in void* <i>p1</i>, in void* <i>p2</i>);
</big></dt>
<dd>Compares two instances for &lt;, ==, or &gt;.<br><br>

</dd>
<dt><big>size_t <u>tsize</u>();
</big></dt>
<dd>Returns size of the type.<br><br>

</dd>
<dt><big>void <u>swap</u>(void* <i>p1</i>, void* <i>p2</i>);
</big></dt>
<dd>Swaps two instances of the type.<br><br>

</dd>
<dt><big>TypeInfo <u>next</u>();
</big></dt>
<dd>Get TypeInfo for '<u>next</u>' type, as defined by what kind of type this is,
 <b>null</b> if none.<br><br>

</dd>
<dt><big>void[] <u>init</u>();
</big></dt>
<dd>Return default initializer.  If the type should be initialized to all zeros,
 an array with a <b>null</b> ptr and a length equal to the type size will be returned.<br><br>

</dd>
<dt><big>uint <u>flags</u>();
</big></dt>
<dd>Get <u>flags</u> for type: 1 means GC should scan for pointers<br><br>

</dd>
<dt><big>OffsetTypeInfo[] <u>offTi</u>();
</big></dt>
<dd>Get type information on the contents of the type; <b>null</b> if not available<br><br>

</dd>
<dt><big>void <u>destroy</u>(void* <i>p</i>);
</big></dt>
<dd>Run the destructor on the object and all its sub-objects<br><br>

</dd>
<dt><big>void <u>postblit</u>(void* <i>p</i>);
</big></dt>
<dd>Run the <u>postblit</u> on the object and all its sub-objects<br><br>

</dd>
<dt><big>size_t <u>talign</u>();
</big></dt>
<dd>Return alignment of type<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>TypeInfo_Class</u>: object.TypeInfo;
</big></dt>
<dd>Runtime type information about a class.
 Can be retrieved from an object instance by using the
 <a href="../property.html#classinfo">.classinfo</a> property.<br><br>

<dl><dt><big>byte[] <u>init</u>;
</big></dt>
<dd>class static initializer
 (<u>init</u>.length gives size in bytes of class)<br><br>

</dd>
<dt><big>string <u>name</u>;
</big></dt>
<dd>class <u>name</u><br><br>

</dd>
<dt><big>void*[] <u>vtbl</u>;
</big></dt>
<dd>virtual function pointer table<br><br>

</dd>
<dt><big>Interface[] <u>interfaces</u>;
</big></dt>
<dd><u>interfaces</u> this class implements<br><br>

</dd>
<dt><big>TypeInfo_Class <u>base</u>;
</big></dt>
<dd><u>base</u> class<br><br>

</dd>
<dt><big>static TypeInfo_Class <u>find</u>(in char[] <i>classname</i>);
</big></dt>
<dd>Search all modules for TypeInfo_Class corresponding to <i>classname</i>.
<br><br>
<b>Returns:</b><br>
<b>null</b> if not found<br><br>

</dd>
<dt><big>Object <u>create</u>();
</big></dt>
<dd>Create instance of Object represented by 'this'.<br><br>

</dd>
<dt><big>const(MemberInfo[]) <u>getMembers</u>(in char[] <i>name</i>);
</big></dt>
<dd>Search for all members with the <i>name</i> '<i>name</i>'.
 If <i>name</i>[] is <b>null</b>, return all members.<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>Throwable</u>;
</big></dt>
<dd><br><br>
</dd>
<dt><big>void <u>rt_setTraceHandler</u>(TraceHandler <i>h</i>);
</big></dt>
<dd>Overrides the default trace hander with a user-supplied version.
<br><br>
<b>Params:</b><br>
<table><tr><td>TraceHandler <i>h</i></td>
<td>The new trace handler.  Set to <b>null</b> to use the default handler.</td></tr>
</table><br>

</dd>
<dt><big>TraceHandler <u>rt_getTraceHandler</u>();
</big></dt>
<dd>Return the current trace handler<br><br>

</dd>
<dt><big>Throwable.TraceInfo <u>_d_traceContext</u>(void* <i>ptr</i> = null);
</big></dt>
<dd>This function will be called when an exception is constructed.  The
 user-supplied trace handler will be called if one has been supplied,
 otherwise no trace will be generated.
<br><br>
<b>Params:</b><br>
<table><tr><td>void* <i>ptr</i></td>
<td>A pointer to the location from which to generate the trace, or <b>null</b>
        if the trace should be generated from within the trace handler
        itself.</td></tr>
</table><br>
<b>Returns:</b><br>
An object describing the current calling context or <b>null</b> if no handler is
  supplied.<br><br>

</dd>
<dt><big>void <u>_moduleCtor</u>();
</big></dt>
<dd>Initialize the modules.<br><br>

</dd>
<dt><big>void <u>_checkModCtors</u>();
</big></dt>
<dd>Check for cycles on module constructors, and establish an order for module
 constructors.<br><br>

</dd>
<dt><big>void <u>_moduleTlsCtor</u>();
</big></dt>
<dd>Run static constructors for thread local global data.<br><br>

</dd>
<dt><big>void <u>_moduleDtor</u>();
</big></dt>
<dd>Destruct the modules.<br><br>

</dd>
<dt><big>alias <u>IMonitor</u>;
</big></dt>
<dd><br><br>
</dd>
<dt><big>size_t <u>capacity</u>(T)(T[] <i>arr</i>);
</big></dt>
<dd>(Property) Get the current <u>capacity</u> of an array.  The <u>capacity</u> is the number
 of elements that the array can grow to before the array must be
 extended/reallocated.<br><br>

</dd>
<dt><big>size_t <u>reserve</u>(T)(ref T[] <i>arr</i>, size_t <i>newcapacity</i>);
</big></dt>
<dd>Try to <u>reserve</u> capacity for an array.  The capacity is the number of
 elements that the array can grow to before the array must be
 extended/reallocated.
<br><br>
The return value is the new capacity of the array (which may be larger than
 the requested capacity).<br><br>

</dd>
<dt><big>void <u>assumeSafeAppend</u>(T)(T[] <i>arr</i>);
</big></dt>
<dd>Assume that it is safe to append to this array.  Appends made to this array
 after calling this function may append in place, even if the array was a
 slice of a larger array to begin with.
<br><br>
Use this only when you are sure no elements are in use beyond the array in
 the memory block.  If there are, those elements could be overwritten by
 appending to this array.
<br><br>

 Calling this function, and then using references to data located after the
 given array results in undefined behavior.<br><br>

</dd>
<dt><big>bool <u>_ArrayEq</u>(T1, T2)(T1[] <i>a1</i>, T2[] <i>a2</i>);
</big></dt>
<dd>Helper function used to see if two containers of different
 types have the same contents in the same sequence.<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>. Copyright Digital Mars 2000 - 2011.
</small>
        </body></html>
