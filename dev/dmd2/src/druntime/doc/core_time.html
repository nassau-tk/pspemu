<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>core.time</title>
        </head><body>
        <h1>core.time</h1>
        <!-- Generated by Ddoc from src\core\time.d -->
Module containing core <u>time</u> functionality, such as Duration (which
    represents a duration of <u>time</u>).
<br><br>
Various functions take a string (or strings) to represent a unit of <u>time</u>
    (e.g. ). The valid strings to use
    with such functions are "years", "months", "weeks", "days", "hours",
    "minutes", "seconds", "msecs" (milliseconds), "usecs" (microseconds),
    "hnsecs" (hecto-nanoseconds - i.e. 100 ns) or some subset thereof. There
    are a few functions that also allow "nsecs", but very little actually
    has precision greater than hnsecs.

<br><br>
<b>License:</b><br>
.
<br><br>
<b>Authors:</b><br>
Jonathan M Davis and Kato Shoichi
<br><br>
<b>Source:</b><br>
<br><br>

<dl><dt><big>struct <u>Duration</u>;
</big></dt>
<dd>Represents a duration of time of weeks or less (kept internally as hnsecs).
    (e.g. 22 days or 700 seconds).
<br><br>
It is used when representing a duration of time - such as how long to
    sleep with Thread.sleep().
<br><br>

    In std.datetime, it is also used as the result of various arithmetic
    operations on time points.
<br><br>

    Use the  function to create Durations.
<br><br>

    You cannot create a duration of months or years because the variable number
    of days in a month or a year makes it so that you cannot convert between
    months or years and smaller units without a specific date. Any type or
    function which handles months or years has other functions for handling those
    rather than using durations. For instance,  has
     and  for adding years and months, rather than
    creating a duration of years or months and adding that to a
    . If you're dealing with weeks or smaller, however,
    durations are what you use.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>assert</font>(dur!<font color=red>"days"</font>(12) == <u>Duration</u>(10_368_000_000_000L));
<font color=blue>assert</font>(dur!<font color=red>"hnsecs"</font>(27) == <u>Duration</u>(27));
<font color=blue>assert</font>(std.datetime.Date(2010, 9, 7) + dur!<font color=red>"days"</font>(5) == std.datetime.Date(2010, 9, 12));
</pre>
<br><br>

<dl><dt><big>const pure nothrow int <u>opCmp</u>(in Duration <i>rhs</i>);
</big></dt>
<dd>Compares this Duration with the given Duration.
<br><br>
<b>Returns:</b><br>
<table>           <tr><td>this &lt; <i>rhs</i></td> <td>&lt; 0</td></tr>
            <tr><td>this == <i>rhs</i></td> <td>0</td></tr>
            <tr><td>this &gt; <i>rhs</i></td> <td>&gt; 0</td></tr>
            </table><br><br>

</dd>
<dt><big>const pure nothrow Duration <u>opBinary</u>(string op, D)(in D <i>rhs</i>);
</big></dt>
<dd>Adds or subtracts two Durations.
<br><br>
The legal types of arithmetic for Duration using this operator are
<br><br>

        <table>       <tr><td>Duration</td> <td>+</td> <td>Duration</td> <td>--&gt;</td> <td>Duration</td></tr>
        <tr><td>Duration</td> <td>-</td> <td>Duration</td> <td>--&gt;</td> <td>Duration</td></tr>
        <tr><td>Duration</td> <td>+</td> <td>TickDuration</td> <td>--&gt;</td> <td>Duration</td></tr>
        <tr><td>Duration</td> <td>-</td> <td>TickDuration</td> <td>--&gt;</td> <td>Duration</td></tr>
        </table>

<br><br>
<b>Params:</b><br>
<table><tr><td>duration</td>
<td>The duration to add to or subtract from this duration.</td></tr>
</table><br>
<b>Note:</b><br>
TUnqual is just a local copy of std.traits' Unqual, since core does
            not have access to std.traits, and naming it Unqual as well would
            result in a name clash, so it's TUnqual.<br><br>

</dd>
<dt><big>pure nothrow Duration <u>opOpAssign</u>(string op, D)(in D <i>rhs</i>);
</big></dt>
<dd>Adds or subtracts two Durations as well as assigning the result
        to this Duration.
<br><br>
The legal types of arithmetic for Duration using this operator are
<br><br>

        <table>       <tr><td>Duration</td> <td>+</td> <td>Duration</td> <td>--&gt;</td> <td>Duration</td></tr>
        <tr><td>Duration</td> <td>-</td> <td>Duration</td> <td>--&gt;</td> <td>Duration</td></tr>
        <tr><td>Duration</td> <td>+</td> <td>TickDuration</td> <td>--&gt;</td> <td>Duration</td></tr>
        <tr><td>Duration</td> <td>-</td> <td>TickDuration</td> <td>--&gt;</td> <td>Duration</td></tr>
        </table>

<br><br>
<b>Params:</b><br>
<table><tr><td>rhs</td>
<td>The duration to add to or subtract from this DateTime.</td></tr>
</table><br>
<b>Note:</b><br>
TUnqual is just a local copy of std.traits' Unqual, since core does
            not have access to std.traits, and naming it Unqual as well would
            result in a name clash, so it's TUnqual.<br><br>

</dd>
<dt><big>const pure nothrow Duration <u>opBinary</u>(string op)(long <i>value</i>);
</big></dt>
<dd>The legal types of arithmetic for Duration using this operator overload are
<br><br>
<table>       <tr><td>Duration</td> <td>*</td> <td>long</td> <td>--&gt;</td> <td>Duration</td></tr>
        </table>

<br><br>
<b>Params:</b><br>
<table><tr><td>value</td>
<td>The value to multiply this duration by.</td></tr>
</table><br>

</dd>
<dt><big>pure nothrow Duration <u>opOpAssign</u>(string op)(long <i>value</i>);
</big></dt>
<dd>The legal types of arithmetic for Duration using this operator overload are
<br><br>
<table>       <tr><td>Duration</td> <td>*</td> <td>long</td> <td>--&gt;</td> <td>Duration</td></tr>
        </table>

<br><br>
<b>Params:</b><br>
<table><tr><td>value</td>
<td>The value to multiply this duration by.</td></tr>
</table><br>

</dd>
<dt><big>const pure Duration <u>opBinary</u>(string op)(long <i>value</i>);
</big></dt>
<dd>The legal types of arithmetic for Duration using this operator overload are
<br><br>
<table>       <tr><td>Duration</td> <td>/</td> <td>long</td> <td>--&gt;</td> <td>Duration</td></tr>
        </table>

<br><br>
<b>Params:</b><br>
<table><tr><td>value</td>
<td>The value to divide from this duration.</td></tr>
</table><br>
<b>Throws:</b><br>
TimeException if an attempt to divide by 0 is made.<br><br>

</dd>
<dt><big>pure Duration <u>opOpAssign</u>(string op)(long <i>value</i>);
</big></dt>
<dd>The legal types of arithmetic for Duration using this operator overload are
<br><br>
<table>       <tr><td>Duration</td> <td>/</td> <td>long</td> <td>--&gt;</td> <td>Duration</td></tr>
        </table>

<br><br>
<b>Params:</b><br>
<table><tr><td>value</td>
<td>The value to divide from this duration.</td></tr>
</table><br>
<b>Throws:</b><br>
TimeException if an attempt to divide by 0 is made.<br><br>

</dd>
<dt><big>const pure nothrow Duration <u>opBinaryRight</u>(string op)(long <i>value</i>);
</big></dt>
<dd>Multiplies an integral value and a Duration.
<br><br>
The legal types of arithmetic for Duration using this operator overload are
<br><br>

        <table>       <tr><td>long</td> <td>*</td> <td>Duration</td> <td>--&gt;</td> <td>Duration</td></tr>
        </table>

<br><br>
<b>Params:</b><br>
<table><tr><td>value</td>
<td>The number of units to multiply this duration by.</td></tr>
</table><br>

</dd>
<dt><big>const pure nothrow Duration <u>opUnary</u>(string op)();
</big></dt>
<dd>Returns the negation of this Duration.<br><br>

</dd>
<dt><big>const pure nothrow long <u>get</u>(string units)();
</big></dt>
<dd>Returns the number of the given units in the duration
        (minus the larger units).
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>assert</font>(dur!<font color=red>"weeks"</font>(12).<u>get</u>!<font color=red>"weeks"</font>() == 12);
<font color=blue>assert</font>(dur!<font color=red>"weeks"</font>(12).<u>get</u>!<font color=red>"days"</font>() == 0);

<font color=blue>assert</font>(dur!<font color=red>"days"</font>(13).<u>get</u>!<font color=red>"weeks"</font>() == 1);
<font color=blue>assert</font>(dur!<font color=red>"days"</font>(13).<u>get</u>!<font color=red>"days"</font>() == 6);

<font color=blue>assert</font>(dur!<font color=red>"hours"</font>(49).<u>get</u>!<font color=red>"days"</font>() == 2);
<font color=blue>assert</font>(dur!<font color=red>"hours"</font>(49).<u>get</u>!<font color=red>"hours"</font>() == 1);
</pre>
<br><br>

</dd>
<dt><big>alias <u>weeks</u>;
</big></dt>
<dd>Returns the number of <u>weeks</u> in the duration.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>assert</font>(dur!<font color=red>"weeks"</font>(12).<u>weeks</u> == 12);
<font color=blue>assert</font>(dur!<font color=red>"days"</font>(13).<u>weeks</u> == 1);
</pre>
<br><br>

</dd>
<dt><big>alias <u>days</u>;
</big></dt>
<dd>Returns the number of <u>days</u> in the duration (minus the larger units).
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>assert</font>(dur!<font color=red>"weeks"</font>(12).<u>days</u> == 0);
<font color=blue>assert</font>(dur!<font color=red>"days"</font>(13).<u>days</u> == 6);
<font color=blue>assert</font>(dur!<font color=red>"hours"</font>(49).<u>days</u> == 2);
</pre>
<br><br>

</dd>
<dt><big>alias <u>hours</u>;
</big></dt>
<dd>Returns the number of <u>hours</u> in the duration (minus the larger units).
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>assert</font>(dur!<font color=red>"days"</font>(8).<u>hours</u> == 0);
<font color=blue>assert</font>(dur!<font color=red>"hours"</font>(49).<u>hours</u> == 1);
<font color=blue>assert</font>(dur!<font color=red>"minutes"</font>(121).<u>hours</u> == 2);
</pre>
<br><br>

</dd>
<dt><big>alias <u>minutes</u>;
</big></dt>
<dd>Returns the number of <u>minutes</u> in the duration (minus the larger units).
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>assert</font>(dur!<font color=red>"hours"</font>(47).<u>minutes</u> == 0);
<font color=blue>assert</font>(dur!<font color=red>"minutes"</font>(127).<u>minutes</u> == 7);
<font color=blue>assert</font>(dur!<font color=red>"seconds"</font>(121).<u>minutes</u> == 2);
</pre>
<br><br>

</dd>
<dt><big>alias <u>seconds</u>;
</big></dt>
<dd>Returns the number of <u>seconds</u> in the duration (minus the larger units).
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>assert</font>(dur!<font color=red>"minutes"</font>(47).<u>seconds</u> == 0);
<font color=blue>assert</font>(dur!<font color=red>"seconds"</font>(127).<u>seconds</u> == 7);
<font color=blue>assert</font>(dur!<font color=red>"msecs"</font>(1217).<u>seconds</u> == 1);
</pre>
<br><br>

</dd>
<dt><big>const pure nothrow @property FracSec <u>fracSec</u>();
</big></dt>
<dd>Returns the fractional seconds passed the second.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>assert</font>(dur!<font color=red>"msecs"</font>(1000).<u>fracSec</u> == FracSec.from!<font color=red>"msecs"</font>(0));
<font color=blue>assert</font>(dur!<font color=red>"msecs"</font>(1217).<u>fracSec</u> == FracSec.from!<font color=red>"msecs"</font>(217));
<font color=blue>assert</font>(dur!<font color=red>"usecs"</font>(43).<u>fracSec</u> == FracSec.from!<font color=red>"usecs"</font>(43));
<font color=blue>assert</font>(dur!<font color=red>"hnsecs"</font>(50_007).<u>fracSec</u> == FracSec.from!<font color=red>"hnsecs"</font>(50_007));
<font color=blue>assert</font>(dur!<font color=red>"nsecs"</font>(62_127).<u>fracSec</u> == FracSec.from!<font color=red>"nsecs"</font>(62_100));
</pre>
<br><br>

</dd>
<dt><big>const pure nothrow long <u>total</u>(string units)();
</big></dt>
<dd>Returns the <u>total</u> number of the given units in the duration.
        So, unlike , it does not strip out the larger
        units.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>assert</font>(dur!<font color=red>"weeks"</font>(12).<u>total</u>!<font color=red>"weeks"</font>() == 12);
<font color=blue>assert</font>(dur!<font color=red>"weeks"</font>(12).<u>total</u>!<font color=red>"days"</font>() == 84);

<font color=blue>assert</font>(dur!<font color=red>"days"</font>(13).<u>total</u>!<font color=red>"weeks"</font>() == 1);
<font color=blue>assert</font>(dur!<font color=red>"days"</font>(13).<u>total</u>!<font color=red>"days"</font>() == 13);

<font color=blue>assert</font>(dur!<font color=red>"hours"</font>(49).<u>total</u>!<font color=red>"days"</font>() == 2);
<font color=blue>assert</font>(dur!<font color=red>"hours"</font>(49).<u>total</u>!<font color=red>"hours"</font>() == 49);

<font color=blue>assert</font>(dur!<font color=red>"nsecs"</font>(2007).<u>total</u>!<font color=red>"hnsecs"</font>() == 20);
<font color=blue>assert</font>(dur!<font color=red>"nsecs"</font>(2007).<u>total</u>!<font color=red>"nsecs"</font>() == 2000);
</pre>
<br><br>

</dd>
<dt><big>const pure nothrow string <u>toString</u>();
</big></dt>
<dd>Converts this duration to a string.<br><br>

</dd>
</dl>
</dd>
<dt><big>pure nothrow Duration <u>dur</u>(string units)(long <i>length</i>);
</big></dt>
<dd>This allows you to construct a Duration from the given time units
    with the given length.
<br><br>
The possible values for units are "weeks", "days", "hours", "minutes",
    "seconds", "msecs" (milliseconds), "usecs", (microseconds),
    "hnsecs" (hecto-nanoseconds, i.e. 100 ns), and "nsecs".

<br><br>
<b>Params:</b><br>
<table><tr><td>units</td>
<td>The time units of the duration (e.g. "days").</td></tr>
<tr><td>length</td>
<td>The number of units in the duration.</td></tr>
</table><br>

</dd>
<dt><big>struct <u>TickDuration</u>;
</big></dt>
<dd>Duration in system clock ticks.
<br><br>
This type maintains the most high precision ticks of system clock in each
   environment.<br><br>

<dl><dt><big>static immutable long <u>ticksPerSec</u>;
</big></dt>
<dd>The number of ticks that the system clock has in one second.
<br><br>
Confirm that it is not 0, to examine whether you can use TickDuration.<br><br>

</dd>
<dt><big>static immutable TickDuration <u>appOrigin</u>;
</big></dt>
<dd>TickDuration when application begins.<br><br>

</dd>
<dt><big>long <u>length</u>;
</big></dt>
<dd>The number of ticks.
<br><br>
You can convert this <u>length</u> into number of seconds by dividing it
       by ticksPerSec.<br><br>

</dd>
<dt><big>const pure nothrow T <u>to</u>(string units, T)();
</big></dt>
<dd>Converts TickDuration <u>to</u> the given units as an integral value.
<br><br>
<b>Params:</b><br>
<table><tr><td>units</td>
<td>The units <u>to</u> convert <u>to</u>. "seconds" and smaller only.</td></tr>
<tr><td>T</td>
<td>The integral type <u>to</u> convert <u>to</u>.</td></tr>
</table><br>

</dd>
<dt><big>const pure nothrow T <u>to</u>(string units, T)();
</big></dt>
<dd>Converts TickDuration <u>to</u> the given units as a floating point value.
<br><br>
<b>Params:</b><br>
<table><tr><td>units</td>
<td>The units <u>to</u> convert <u>to</u>. "seconds" and smaller only.</td></tr>
<tr><td>T</td>
<td>The floating point type <u>to</u> convert <u>to</u>.</td></tr>
</table><br>

</dd>
<dt><big>alias <u>seconds</u>;
</big></dt>
<dd>Alias for converting TickDuration to <u>seconds</u>.<br><br>

</dd>
<dt><big>alias <u>msecs</u>;
</big></dt>
<dd>Alias for converting TickDuration to milliseconds.<br><br>

</dd>
<dt><big>alias <u>usecs</u>;
</big></dt>
<dd>Alias for converting TickDuration to microseconds.<br><br>

</dd>
<dt><big>alias <u>hnsecs</u>;
</big></dt>
<dd>Alias for converting TickDuration to hecto-nanoseconds (100 ns).<br><br>

</dd>
<dt><big>alias <u>nsecs</u>;
</big></dt>
<dd>Alias for converting TickDuration to nanoseconds.<br><br>

</dd>
<dt><big>pure nothrow TickDuration <u>from</u>(string units)(long <i>value</i>);
</big></dt>
<dd>Creates a TickDuration <u>from</u> the number of the given units.
<br><br>
<b>Params:</b><br>
<table><tr><td>units</td>
<td>The units to convert <u>from</u>. "seconds" and smaller.</td></tr>
<tr><td>value</td>
<td>The number of the units to convert <u>from</u>.</td></tr>
</table><br>

</dd>
<dt><big>const pure nothrow Duration <u>opCast</u>(T)();
</big></dt>
<dd>Returns a Duration with the same number of hnsecs as this TickDuration.<br><br>

</dd>
<dt><big>pure nothrow void <u>opOpAssign</u>(string op)(in TickDuration <i>rhs</i>);
</big></dt>
<dd>operator overloading "-=, +="
<br><br>
<b>BUG:</b><br>
This should be return "ref TickDuration", but bug2460 prevents that.<br><br>

</dd>
<dt><big>const pure nothrow TickDuration <u>opBinary</u>(string op)(in TickDuration <i>rhs</i>);
</big></dt>
<dd>operator overloading "-, +"<br><br>

</dd>
<dt><big>const pure nothrow TickDuration <u>opUnary</u>(string op)();
</big></dt>
<dd>Returns the negation of this TickDuration.<br><br>

</dd>
<dt><big>const pure nothrow @safe bool <u>opEquals</u>(ref const TickDuration <i>rhs</i>);
</big></dt>
<dd>operator overloading "=="<br><br>

</dd>
<dt><big>const pure nothrow @safe int <u>opCmp</u>(ref const TickDuration <i>rhs</i>);
</big></dt>
<dd>operator overloading "&lt;, &gt;, &lt;=, &gt;="<br><br>

</dd>
<dt><big>pure nothrow void <u>opOpAssign</u>(string op, T)(T <i>value</i>);
</big></dt>
<dd>The legal types of arithmetic for TickDuration using this operator overload are
<br><br>
<table>       <tr><td>TickDuration</td> <td>*</td> <td>long</td> <td>--&gt;</td> <td>TickDuration</td></tr>
        <tr><td>TickDuration</td> <td>*</td> <td>floating point</td> <td>--&gt;</td> <td>TickDuration</td></tr>
        </table>

<br><br>
<b>Params:</b><br>
<table><tr><td>value</td>
<td>The value to divide from this duration.</td></tr>
</table><br>

</dd>
<dt><big>pure void <u>opOpAssign</u>(string op, T)(T <i>value</i>);
</big></dt>
<dd>The legal types of arithmetic for TickDuration using this operator overload are
<br><br>
<table>       <tr><td>TickDuration</td> <td>/</td> <td>long</td> <td>--&gt;</td> <td>TickDuration</td></tr>
        <tr><td>TickDuration</td> <td>/</td> <td>floating point</td> <td>--&gt;</td> <td>TickDuration</td></tr>
        </table>

<br><br>
<b>Params:</b><br>
<table><tr><td>value</td>
<td>The value to divide from this duration.</td></tr>
</table><br>
<b>Throws:</b><br>
TimeException if an attempt to divide by 0 is made.<br><br>

</dd>
<dt><big>const pure nothrow TickDuration <u>opBinary</u>(string op, T)(T <i>value</i>);
</big></dt>
<dd>The legal types of arithmetic for TickDuration using this operator overload are
<br><br>
<table>       <tr><td>TickDuration</td> <td>*</td> <td>long</td> <td>--&gt;</td> <td>TickDuration</td></tr>
        <tr><td>TickDuration</td> <td>*</td> <td>floating point</td> <td>--&gt;</td> <td>TickDuration</td></tr>
        </table>

<br><br>
<b>Params:</b><br>
<table><tr><td>value</td>
<td>The value to divide from this duration.</td></tr>
</table><br>

</dd>
<dt><big>const pure TickDuration <u>opBinary</u>(string op, T)(T <i>value</i>);
</big></dt>
<dd>The legal types of arithmetic for TickDuration using this operator overload are
<br><br>
<table>       <tr><td>TickDuration</td> <td>/</td> <td>long</td> <td>--&gt;</td> <td>TickDuration</td></tr>
        <tr><td>TickDuration</td> <td>/</td> <td>floating point</td> <td>--&gt;</td> <td>TickDuration</td></tr>
        </table>

<br><br>
<b>Params:</b><br>
<table><tr><td>value</td>
<td>The value to divide from this duration.</td></tr>
</table><br>
<b>Throws:</b><br>
TimeException if an attempt to divide by 0 is made.<br><br>

</dd>
<dt><big>pure nothrow @safe  this(long <i>ticks</i>);
</big></dt>
<dd><b>Params:</b><br>
<table><tr><td>long <i>ticks</i></td>
<td>The number of <i>ticks</i> in the TickDuration.</td></tr>
</table><br>

</dd>
<dt><big>static @property @trusted TickDuration <u>currSystemTick</u>();
</big></dt>
<dd>The current system tick. The number of ticks per second varies from
        system to system. This uses a monotonic clock, so it's intended for
        precision timing by comparing relative time values, not for getting
        the current system time.
<br><br>
On Windows, QueryPerformanceCounter() is used. On Mac OS X,
        mach_absolute_time() is used, while on other Posix systems,
        clock_gettime() is used. If mach_absolute_time() or clock_gettime()
        is unavailable, then Posix systems use gettimeofday(), which
        unfortunately, is not monotonic, but without
        mach_absolute_time()/clock_gettime() available, gettimeofday() is the
        the best that you can do.

<br><br>
<b>Warning:</b><br>
On some systems, the monotonic clock may stop counting when
            the computer goes to sleep or hibernates. So, the monotonic
            clock could be off if that occurs. This is known to happen
            on Mac OS X. It has not been tested whether it occurs on
            either Windows or on Linux.

<br><br>
<b>Throws:</b><br>
TimeException if it fails to get the time.<br><br>

</dd>
</dl>
</dd>
<dt><big>pure nothrow long <u>convert</u>(string from, string to)(long <i>value</i>);
</big></dt>
<dd>Generic way of converting between two time units. Conversions to smaller
    units use truncating division.
<br><br>
<b>Params:</b><br>
<table><tr><td>tuFrom</td>
<td>The units of time to covert from.</td></tr>
<tr><td>tuFrom</td>
<td>The units of time to covert type.</td></tr>
<tr><td>value</td>
<td>The value to <u>convert</u>.</td></tr>
</table><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>assert</font>(<u>convert</u>!(<font color=red>"years"</font>, <font color=red>"months"</font>)(1) == 12);
<font color=blue>assert</font>(<u>convert</u>!(<font color=red>"months"</font>, <font color=red>"years"</font>)(12) == 1);
</pre>
<br><br>

</dd>
<dt><big>pure nothrow long <u>convert</u>(string from, string to)(long <i>value</i>);
</big></dt>
<dd>Generic way of converting between two time units. Conversions to smaller
    units use truncating division.
<br><br>
<b>Params:</b><br>
<table><tr><td>tuFrom</td>
<td>The units of time to covert from.</td></tr>
<tr><td>tuFrom</td>
<td>The units of time to covert type.</td></tr>
<tr><td>value</td>
<td>The value to <u>convert</u>.</td></tr>
</table><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>assert</font>(<u>convert</u>!(<font color=red>"weeks"</font>, <font color=red>"days"</font>)(1) == 7);
<font color=blue>assert</font>(<u>convert</u>!(<font color=red>"hours"</font>, <font color=red>"seconds"</font>)(1) == 3600);
<font color=blue>assert</font>(<u>convert</u>!(<font color=red>"seconds"</font>, <font color=red>"days"</font>)(1) == 0);
<font color=blue>assert</font>(<u>convert</u>!(<font color=red>"seconds"</font>, <font color=red>"days"</font>)(86_400) == 1);
</pre>
<br><br>

</dd>
<dt><big>pure nothrow long <u>convert</u>(string from, string to)(long <i>value</i>);
</big></dt>
<dd>Generic way of converting between two time units. Conversions to smaller
    units use truncating division.
<br><br>
<b>Params:</b><br>
<table><tr><td>tuFrom</td>
<td>The units of time to covert from.</td></tr>
<tr><td>tuFrom</td>
<td>The units of time to covert type.</td></tr>
<tr><td>value</td>
<td>The value to <u>convert</u>.</td></tr>
</table><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>assert</font>(<u>convert</u>!(<font color=red>"nsecs"</font>, <font color=red>"nsecs"</font>)(1) == 1);
<font color=blue>assert</font>(<u>convert</u>!(<font color=red>"nsecs"</font>, <font color=red>"hnsecs"</font>)(1) == 0);
<font color=blue>assert</font>(<u>convert</u>!(<font color=red>"hnsecs"</font>, <font color=red>"nsecs"</font>)(1) == 100);
<font color=blue>assert</font>(<u>convert</u>!(<font color=red>"nsecs"</font>, <font color=red>"seconds"</font>)(1) == 0);
<font color=blue>assert</font>(<u>convert</u>!(<font color=red>"seconds"</font>, <font color=red>"nsecs"</font>)(1) == 1_000_000_000);
</pre>
<br><br>

</dd>
<dt><big>struct <u>FracSec</u>;
</big></dt>
<dd>Represents fractional seconds.
<br><br>
This is the portion of the time which is smaller than a second and cannot
    hold values which would equal or exceed a second.
<br><br>

    It holds hnsecs internally, but you can create it using either milliseconds,
    microseconds, or hnsecs. What it does is allow for a simple way to set or adjust
    the fractional seconds portion of a Duration or a std.datetime.SysTime without
    having to worry about whether you're dealing with milliseconds, microseconds,
    or hnsecs.
<br><br>

    <u>FracSec</u>'s functions which take time unit strings do accept "nsecs", but the
    because the resolution for Duration and std.datetime.SysTime is hnsecs, you
    don't actually get precision higher than hnsecs. "nsecs" is accepted merely
    for convenience. Any values given as nsecs will be converted to hnsecs using
    convert!() (which uses truncation when converting to smaller units).<br><br>

<dl><dt><big>pure FracSec <u>from</u>(string units)(long <i>value</i>);
</big></dt>
<dd>Create a FracSec <u>from</u> the given units ("msecs", "usecs", or "hnsecs").
<br><br>
<b>Params:</b><br>
<table><tr><td>units</td>
<td>The units to create a FracSec <u>from</u>.</td></tr>
<tr><td>value</td>
<td>The number of the given units passed the second.</td></tr>
</table><br>
<b>Throws:</b><br>
TimeException if the given value is less than 0 or would result in a
            FracSec greater than or equal to 1 second.<br><br>

</dd>
<dt><big>const pure nothrow @property int <u>msecs</u>();
</big></dt>
<dd>The value of this FracSec as milliseconds.<br><br>

</dd>
<dt><big>pure @property void <u>msecs</u>(int <i>milliseconds</i>);
</big></dt>
<dd>The value of this FracSec as <i>milliseconds</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>int <i>milliseconds</i></td>
<td>The number of <i>milliseconds</i> passed the second.</td></tr>
</table><br>
<b>Throws:</b><br>
TimeException if the given value is not less than one second.<br><br>

</dd>
<dt><big>const pure nothrow @property int <u>usecs</u>();
</big></dt>
<dd>The value of this FracSec as microseconds.<br><br>

</dd>
<dt><big>pure @property void <u>usecs</u>(int <i>microseconds</i>);
</big></dt>
<dd>The value of this FracSec as <i>microseconds</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>int <i>microseconds</i></td>
<td>The number of <i>microseconds</i> passed the second.</td></tr>
</table><br>
<b>Throws:</b><br>
TimeException if the given value is not less than one second.<br><br>

</dd>
<dt><big>const pure nothrow @property int <u>hnsecs</u>();
</big></dt>
<dd>The value of this FracSec as <u>hnsecs</u>.<br><br>

</dd>
<dt><big>pure @property void <u>hnsecs</u>(int <u>hnsecs</u>);
</big></dt>
<dd>The value of this FracSec as <u>hnsecs</u>.
<br><br>
<b>Params:</b><br>
<table><tr><td>int <u>hnsecs</u></td>
<td>The number of <u>hnsecs</u> passed the second.</td></tr>
</table><br>
<b>Throws:</b><br>
TimeException if the given value is not less than one second.<br><br>

</dd>
<dt><big>const pure nothrow @property int <u>nsecs</u>();
</big></dt>
<dd>The value of this FracSec as <u>nsecs</u>.
<br><br>
Note that this does not give you any greater precision
        than getting the value of this FracSec as hnsecs.<br><br>

</dd>
<dt><big>pure @property void <u>nsecs</u>(long <u>nsecs</u>);
</big></dt>
<dd>The value of this FracSec as <u>nsecs</u>.
<br><br>
Note that this does not give you any greater precision
        than setting the value of this FracSec as hnsecs.

<br><br>
<b>Params:</b><br>
<table><tr><td>long <u>nsecs</u></td>
<td>The number of <u>nsecs</u> passed the second.</td></tr>
</table><br>
<b>Throws:</b><br>
TimeException if the given value is not less than one second.<br><br>

</dd>
<dt><big>const pure nothrow string <u>toString</u>();
</big></dt>
<dd>Converts this duration to a string.<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>TimeException</u>: object.Exception;
</big></dt>
<dd>Exception type used by core.time.<br><br>

<dl><dt><big>nothrow  this(string <i>msg</i>, string <i>file</i> = __FILE__, size_t <i>line</i> = __LINE__, Throwable <i>next</i> = null);
</big></dt>
<dd><b>Params:</b><br>
<table><tr><td>string <i>msg</i></td>
<td>The message for the exception.</td></tr>
<tr><td>string <i>file</i></td>
<td>The <i>file</i> where the exception occurred.</td></tr>
<tr><td>size_t <i>line</i></td>
<td>The <i>line</i> number where the exception occurred.</td></tr>
<tr><td>Throwable <i>next</i></td>
<td>The previous exception in the chain of exceptions, if any.</td></tr>
</table><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>. Copyright 2010 - 2011
</small>
        </body></html>
