<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>core.atomic</title>
        </head><body>
        <h1>core.atomic</h1>
        <!-- Generated by Ddoc from src\core\atomic.d -->
The <u>atomic</u> module provides basic support for lock-free
 concurrent programming.
<br><br>
<b>License:</b><br>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>
<br><br>
<b>Authors:</b><br>
Sean Kelly
<br><br>
<b>Source:</b><br>
<br><br>

<dl><dt><big>HeadUnshared!(T) <u>atomicOp</u>(string op, T, V1)(ref shared T <i>val</i>, V1 <i>mod</i>);
</big></dt>
<dd>Performs the binary operation 'op' on val using 'mod' as the modifier.
<br><br>
<b>Params:</b><br>
<table><tr><td>val</td>
<td>The target variable.</td></tr>
<tr><td>mod</td>
<td>The modifier to apply.</td></tr>
</table><br>
<b>Returns:</b><br>
The result of the operation.<br><br>

</dd>
<dt><big>bool <u>cas</u>(T, V1, V2)(shared(T)* <i>here</i>, const V1 <i>ifThis</i>, const V2 <i>writeThis</i>);
</big></dt>
<dd>Stores 'writeThis' to the memory referenced by 'here' if the value
 referenced by 'here' is equal to 'ifThis'.  This operation is both
 lock-free and atomic.
<br><br>
<b>Params:</b><br>
<table><tr><td>here</td>
<td>The address of the destination variable.</td></tr>
<tr><td>writeThis</td>
<td>The value to store.</td></tr>
<tr><td>ifThis</td>
<td>The comparison value.</td></tr>
</table><br>
<b>Returns:</b><br>
<b>true</b> if the store occurred, <b>false</b> if not.<br><br>

</dd>
<dt><big>HeadUnshared!(T) <u>atomicLoad</u>(msync ms = msync.seq, T)(ref const shared T <i>val</i>);
</big></dt>
<dd>Loads 'val' from memory and returns it.  The memory barrier specified
 by 'ms' is applied to the operation, which is fully sequenced by
 default.
<br><br>
<b>Params:</b><br>
<table><tr><td>val</td>
<td>The target variable.</td></tr>
</table><br>
<b>Returns:</b><br>
The value of 'val'.<br><br>

</dd>
<dt><big>void <u>atomicStore</u>(msync ms = msync.seq, T, V1)(ref shared T <i>val</i>, V1 <i>newval</i>);
</big></dt>
<dd>Writes 'newval' into 'val'.  The memory barrier specified by 'ms' is
 applied to the operation, which is fully sequenced by default.
<br><br>
<b>Params:</b><br>
<table><tr><td>val</td>
<td>The target variable.</td></tr>
<tr><td>newval</td>
<td>The value to store.</td></tr>
</table><br>

</dd>
<dt><big>enum <u>msync</u>;
</big></dt>
<dd><br><br>
<dl><dt><big><u>raw</u></big></dt>
<dd>not sequenced<br><br>

</dd>
<dt><big><u>acq</u></big></dt>
<dd>hoist-load + hoist-store barrier<br><br>

</dd>
<dt><big><u>rel</u></big></dt>
<dd>sink-load + sink-store barrier<br><br>

</dd>
<dt><big><u>seq</u></big></dt>
<dd>fully sequenced (acq + rel)<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>. Copyright Sean Kelly 2005 - 2010.
</small>
        </body></html>
