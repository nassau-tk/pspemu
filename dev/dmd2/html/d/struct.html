
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en-US">

<!--
	Copyright (c) 1999-2011 by Digital Mars
	All Rights Reserved Written by Walter Bright
	http://www.digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="keywords" content="D programming language" />
<meta name="description" content="D Programming Language" />
<title>Structs, Unions - D Programming Language 2.0 - Digital Mars</title>
<link rel="stylesheet" type="text/css" href="style.css" />
<link rel="stylesheet" type="text/css" href="print.css" media="print" />
<link rel="shortcut icon" href="favicon.ico" />

<!-- enable this for automated hyphenation, see http://code.google.com/p/hyphenator/ -->
<!--
<script src="http://erdani.com/js/Hyphenator.js" type="text/javascript"></script>
<script type="text/javascript">Hyphenator.run();</script>
-->

</head>

<body class="hyphenate">
<div id="heading">
	<a href="http://www.digitalmars.com/"><img src="dmlogo.gif" width="270" height="53" style="border-style:none" alt="www.digitalmars.com" align="left"></a>
	<p align="right">D Programming Language 2.0</p>
	<br>

	<div id="headingNav">
	<ul>	<li><a href="http://www.digitalmars.com/NewsGroup.html" title="User Forums"><img src="http://www.digitalmars.com/news.png" border=0 alt="User Forums"> Forum</a></li>
	<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/Struct" title="Read/write comments and feedback"><img src="wiki.png" border=0 alt="D Wiki"> Wiki</a></li>
	<li><a href="index.html" title="D Programming Language" class="dlink">&nbsp;<img src="d.png" border=0 alt="D Programming Language">&nbsp;</a></li>
	<li><a href="http://www.digitalmars.com/advancedsearch.html" title="Search Digital Mars web site"><img src="search.png" border=0 alt="Search">Search</a></li>
	<li><a href="http://www.digitalmars.com/d/download.html" title="download D"><img src="download.png" border=0 alt="Download">Downloads</a></li>
	<li><a href="http://www.digitalmars.com/" title="www.digitalmars.com"><img src="home.png" border=0 alt="digitalmars.com">Home</a></li>
	</ul>
	</div>

	<div id="lastupdate">Last update Fri Jul  8 22:24:13 2011
</div>
</div>
<!-- Generated by Ddoc from struct.dd -->



<div id="navigation">
  
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input id="q" name="q" size="10" value="Search" onFocus='if(this.value == "Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/d/2.0">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="index.html" title="D Programming Language">D 2.0 Home</a></li>
	<li><a href="spec.html" title="D Language Specification">Language Reference</a></li>
	<li><a href="phobos/phobos.html" title="D Runtime Library">Library Reference</a></li>
	<li><a href="comparison.html" title="Language Comparisons">Comparisons</a></li>
	<li><a href="http://www.digitalmars.com/d/1.0/index.html" title="D Programming Language 1.0">D 1.0 Home</a></li>
    </ul>
</div>
</div>

  
    <div class="navblock">
    <ul>	<li><a href="spec.html">Specification</a></li>
	<li><a href="intro.html">Introduction</a></li>
	<li><a href="lex.html">Lexical</a></li>
	<li><a href="module.html">Modules</a></li>
	<li><a href="declaration.html">Declarations</a></li>
	<li><a href="type.html">Types</a></li>
	<li><a href="property.html">Properties</a></li>
	<li><a href="attribute.html">Attributes</a></li>
	<li><a href="pragma.html">Pragmas</a></li>
	<li><a href="expression.html">Expressions</a></li>
	<li><a href="statement.html">Statements</a></li>
	<li><a href="arrays.html">Arrays</a></li>
	<li><a href="hash-map.html">Associative Arrays</a></li>
	<li><a href="struct.html">Structs &amp; Unions</a></li>
	<li><a href="class.html">Classes</a></li>
	<li><a href="interface.html">Interfaces</a></li>
	<li><a href="enum.html">Enums</a></li>
	<li><a href="const3.html">Const and Immutable</a></li>
	<li><a href="function.html">Functions</a></li>
	<li><a href="operatoroverloading.html">Operator Overloading</a></li>
	<li><a href="template.html">Templates</a></li>
	<li><a href="template-mixin.html">Template Mixins</a></li>
	<li><a href="dbc.html">Contracts</a></li>
	<li><a href="version.html">Conditional Compilation</a></li>
	<li><a href="traits.html">Traits</a></li>
	<li><a href="errors.html">Handling errors</a></li>
	<li><a href="unittest.html">Unit Tests</a></li>
	<li><a href="garbage.html">Garbage Collection</a></li>
	<li><a href="float.html">Floating Point</a></li>
	<li><a href="iasm.html">Inline Assembler</a></li>
	<li><a href="ddoc.html">Documentation Comments</a></li>
	<li><a href="interfaceToC.html">Interfacing To C</a></li>
	<li><a href="cpp_interface.html">Interfacing To C++</a></li>
	<li><a href="portability.html">Portability Guide</a></li>
	<li><a href="html.html">Embedding D in HTML</a></li>
	<li><a href="entity.html">Named Character Entities</a></li>
	<li><a href="memory-safe-d.html">Memory Safe D Spec</a></li>
	<li><a href="abi.html">Application Binary Interface</a></li>
    </ul>
    </div>
    
    <div class="navblock">
	<h2>Books</h2>
	<ul>		<li><a href="http://www.amazon.com/exec/obidos/ASIN/0321635361/classicempire">D Programming Language</a>
</li>
		<li><a href="http://www.amazon.com/exec/obidos/ASIN/1590599608/classicempire">Learn to Tango with D</a>
</li>
		<li><a href="http://www.amazon.com/exec/obidos/ASIN/0596520123/classicempire">Version Control with Git</a>
</li>
	</ul>
    </div>


    
<script src="http://www.gmodules.com/ig/ifr?url=http://www.google.com/ig/modules/translatemypage.xml&up_source_language=en&w=160&h=60&title=&border=&output=js"></script>
    



</div>
<div id="content">
  <h1>Structs, Unions</h1>
          <p>Whereas classes are reference types, structs are value types.
        Any C struct can be exactly represented as a D struct.
        In C++ parlance, a D struct is a
        <a href="glossary.html#pod">POD (Plain Old Data)</a> type,
        with a trivial constructors and destructors.
        Structs and unions are meant as simple aggregations of data, or as a way
        to paint a data structure over hardware or an external type. External
        types can be defined by the operating system API, or by a file format.
        Object oriented features are provided with the class data type.
        </p>

        <p>A struct is defined to not have an identity; that is,
        the implementation is free to make bit copies of the struct
        as convenient.</p>

        <table border=1 cellpadding=4 cellspacing=0><caption>Struct, Class Comparison Table</caption>
        <tr>       <th scope="col">Feature</th>
        <th scope="col">struct</th>
        <th scope="col">class</th>
        <th scope="col">C struct</th>
        <th scope="col">C++ struct</th>
        <th scope="col">C++ class</th>
        </tr>

        <tr>       <td>value type</td>
        <td>X</td>
        <td>&nbsp;</td>
        <td>X</td>
        <td>X</td>
        <td>X</td>
        </tr>

        <tr>       <td>reference type</td>
        <td>&nbsp;</td>
        <td>X</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        </tr>

        <tr>       <td>data members</td>
        <td>X</td>
        <td>X</td>
        <td>X</td>
        <td>X</td>
        <td>X</td>
        </tr>

        <tr>       <td>hidden members</td>

  <td>X</td>
        <td>X</td>
        <td>&nbsp;</td>
        <td>X</td>
        <td>X</td>
        </tr>

        <tr>       <td>static members</td>
        <td>X</td>
        <td>X</td>
        <td>&nbsp;</td>
        <td>X</td>
        <td>X</td>
        </tr>

        <tr>       <td>default member initializers</td>
        <td>X</td>
        <td>X</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        </tr>

        <tr>       <td>bit fields</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        <td>X</td>
        <td>X</td>
        <td>X</td>
        </tr>

        <tr>       <td>non-virtual member functions</td>
        <td>X</td>
        <td>X</td>
        <td>&nbsp;</td>
        <td>X</td>
        <td>X</td>
        </tr>

        <tr>       <td>virtual member functions</td>
        <td>&nbsp;</td>
        <td>X</td>
        <td>&nbsp;</td>
        <td>X</td>
        <td>X</td>
        </tr>


       <tr>       <td><a href="#Struct-Constructor">constructors</a></td>
        <td>X</td>
        <td>X</td>
        <td>&nbsp;</td>
        <td>X</td>
        <td>X</td>
        </tr>
        <tr>       <td><a href="#StructPostblit">postblit</a>/copy constructors</td>
        <td>X</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        <td>X</td>
        <td>X</td>
        </tr>
        <tr>       <td><a href="#StructDestructor">destructors</a></td>
        <td>X</td>
        <td>X</td>
        <td>&nbsp;</td>
        <td>X</td>
        <td>X</td>
        </tr>
        <tr>       <td><a href="class.html#SharedStaticConstructor">shared static constructors</a></td>
        <td>X</td>
        <td>X</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        </tr>
        <tr>       <td><a href="class.html#SharedStaticDestructor">shared static destructors</a></td>
        <td>X</td>
        <td>X</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        </tr>
        <tr>       <td>RAII</td>
        <td>X</td>
        <td>X</td>
        <td>&nbsp;</td>
        <td>X</td>
        <td>X</td>
        </tr>
        <tr>       <td><a href="#AssignOverload">assign overload</a></td>
        <td>X</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        <td>X</td>
        <td>X</td>
        </tr>


        <tr>       <td><a href="#StructLiteral">literals</a></td>
        <td>X</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        </tr>

        <tr>       <td>operator overloading</td>
        <td>X</td>
        <td>X</td>
        <td>&nbsp;</td>
        <td>X</td>
        <td>X</td>
        </tr>

        <tr>       <td>inheritance</td>
        <td>&nbsp;</td>
        <td>X</td>
        <td>&nbsp;</td>
        <td>X</td>
        <td>X</td>
        </tr>

        <tr>       <td>invariants</td>
        <td>X</td>
        <td>X</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        </tr>

        <tr>       <td>unit tests</td>
        <td>X</td>
        <td>X</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        </tr>

        <tr>       <td>synchronizable</td>
        <td>&nbsp;</td>
        <td>X</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        </tr>

        <tr>       <td>parameterizable</td>
        <td>X</td>
        <td>X</td>
        <td>&nbsp;</td>
        <td>X</td>
        <td>X</td>
        </tr>

        <tr>       <td>alignment control</td>
        <td>X</td>
        <td>X</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        </tr>

        <tr>       <td>member protection</td>
        <td>X</td>
        <td>X</td>
        <td>&nbsp;</td>
        <td>X</td>
        <td>X</td>
        </tr>

        <tr>       <td>default public</td>
        <td>X</td>
        <td>X</td>
        <td>X</td>
        <td>X</td>
        <td>&nbsp;</td>
        </tr>

        <tr>       <td>tag name space</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        <td>X</td>
        <td>X</td>
        <td>X</td>
        </tr>

        <tr>       <td>anonymous</td>
        <td>X</td>
        <td>&nbsp;</td>
        <td>X</td>
        <td>X</td>
        <td>X</td>
        </tr>

        <tr>       <td>static constructor</td>
        <td>X</td>
        <td>X</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        </tr>

        <tr>       <td>static destructor</td>
        <td>X</td>
        <td>X</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        </tr>

       <tr>       <td>const/immutable/shared</td>
        <td>X</td>
        <td>X</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        </tr>

        <tr>       <td>inner nesting</td>
        <td><a href="#nested">YES</a></td>
        <td><a href="class.html#nested">YES</a></td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        <td>&nbsp;</td>
        </tr>

        </table>

<pre class="bnf"><span class="notranslate"><a name="AggregateDeclaration"><i>AggregateDeclaration</i></a>:
    <b>struct</b> <i>Identifier</i> <a href="#StructBody"><i>StructBody</i></a>
    <b>union</b> <i>Identifier</i> <a href="#StructBody"><i>StructBody</i></a>
    <b>struct</b> <i>Identifier</i> <b>;</b>
    <b>union</b> <i>Identifier</i> <b>;</b>
    <a href="template.html#StructTemplateDeclaration"><i>StructTemplateDeclaration</i></a>
    <a href="template.html#UnionTemplateDeclaration"><i>UnionTemplateDeclaration</i></a>

<a name="StructBody"><i>StructBody</i></a>:
    <b>{</b> <b>}</b>
    <b>{</b> <a href="#StructBodyDeclarations"><i>StructBodyDeclarations</i></a> <b>}</b>

<a name="StructBodyDeclarations"><i>StructBodyDeclarations</i></a>:
    <a href="#StructBodyDeclaration"><i>StructBodyDeclaration</i></a>
    <a href="#StructBodyDeclaration"><i>StructBodyDeclaration</i></a> <i>StructBodyDeclarations</i>

<a name="StructBodyDeclaration"><i>StructBodyDeclaration</i></a>:
    <a href="module.html#DeclDef"><i>DeclDef</i></a>
    <a href="#StructAllocator"><i>StructAllocator</i></a>
    <a href="#StructDeallocator"><i>StructDeallocator</i></a>
    <a href="#StructPostblit"><i>StructPostblit</i></a>
    <a href="class.html#AliasThis"><i>AliasThis</i></a>

<a name="StructAllocator"><i>StructAllocator</i></a>:
    <a href="class.html#ClassAllocator"><i>ClassAllocator</i></a>

<a name="StructDeallocator"><i>StructDeallocator</i></a>:
    <a href="class.html#ClassDeallocator"><i>ClassDeallocator</i></a>
</span></pre>

<p>They work like they do in C, with the following exceptions:</p>

<ul>       <li>no bit fields</li>
        <li>alignment can be explicitly specified</li>
        <li>no separate tag name space - tag names go into the current scope</li>
        <li>declarations like:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">struct</span> ABC x;
</span></pre>
        are not allowed, replace with:

<pre class="d_code"><span class="notranslate">ABC x;
</span></pre>
        </li>
        <li>anonymous structs/unions are allowed as members of other structs/unions</li>
        <li>Default initializers for members can be supplied.</li>
        <li>Member functions and static members are allowed.</li>
</ul>



<h3>Static Initialization of Structs</h3>

        Static struct members are by default initialized to whatever the
        default initializer for the member is, and if none supplied, to
        the default initializer for the member's type.
        If a static initializer is supplied, the
        members are initialized by the member name,
        colon, expression syntax. The members may be initialized in any order.
        Initializers for statics must be evaluatable at compile time.
        Members not specified in the initializer list are default initialized.

<pre class="d_code"><span class="notranslate"><span class="d_keyword">struct</span> S { <span class="d_keyword">int</span> a; <span class="d_keyword">int</span> b; <span class="d_keyword">int</span> c; <span class="d_keyword">int</span> d = 7;}
<span class="d_keyword">static</span> S x = { a:1, b:2};            <span class="d_comment">// c is set to 0, d to 7
</span><span class="d_keyword">static</span> S z = { c:4, b:5, a:2 , d:5}; <span class="d_comment">// z.a = 2, z.b = 5, z.c = 4, z.d = 5
</span></span></pre>

        C-style initialization, based on the order of the members in the
        struct declaration, is also supported:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">static</span> S q = { 1, 2 }; <span class="d_comment">// q.a = 1, q.b = 2, q.c = 0, q.d = 7
</span></span></pre>

        <p>Struct literals can also be used to initialize statics, but
        they must be evaluable at compile time.</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">static</span> S q = S( 1, 2+3 ); <span class="d_comment">// q.a = 1, q.b = 5, q.c = 0, q.d = 7
</span></span></pre>

        <p>The static initializer syntax can also be used to initialize
        non-static variables, provided that the member names are not given.
        The initializer need not be evaluatable at compile time.</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">void</span> test(<span class="d_keyword">int</span> i) {
  S s = { 1, i }; <span class="d_comment">// q.a = 1, q.b = i, q.c = 0, q.d = 7
</span>}
</span></pre>


<h3>Static Initialization of Unions</h3>

        Unions are initialized explicitly.

<pre class="d_code"><span class="notranslate"><span class="d_keyword">union</span> U { <span class="d_keyword">int</span> a; <span class="d_keyword">double</span> b; }
<span class="d_keyword">static</span> U u = { b : 5.0 }; <span class="d_comment">// u.b = 5.0
</span></span></pre>

        Other members of the union that overlay the initializer,
        but occupy more storage, have
        the extra storage initialized to zero.

<h3>Dynamic Initialization of Structs</h3>

        <p>Structs can be dynamically initialized from another
        value of the same type:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">struct</span> S { <span class="d_keyword">int</span> a; }
S t;      <span class="d_comment">// default initialized
</span>t.a = 3;
S s = t;  <span class="d_comment">// s.a is set to 3
</span></span></pre>

        <p>If <tt>opCall</tt> is overridden for the struct, and the struct
        is initialized with a value that is of a different type,
        then the <tt>opCall</tt> operator is called:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">struct</span> S {
  <span class="d_keyword">int</span> a;

  <span class="d_keyword">static</span> S <b>opCall</b>(<span class="d_keyword">int</span> v)
  { S s;
    s.a = v;
    <span class="d_keyword">return</span> s;
  }

  <span class="d_keyword">static</span> S <b>opCall</b>(S v)
  { S s;
    s.a = v.a + 1;
    <span class="d_keyword">return</span> s;
  }
}

S s = 3; <span class="d_comment">// sets s.a to 3
</span>S t = s; <span class="d_comment">// sets t.a to 3, S.<b>opCall</b>(s) is not called
</span></span></pre>

<h3><a name="StructLiteral">Struct Literals</a></h3>

        <p>Struct literals consist of the name of the struct followed
        by a parenthesized argument list:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">struct</span> S { <span class="d_keyword">int</span> x; <span class="d_keyword">float</span> y; }

<span class="d_keyword">int</span> foo(S s) { <span class="d_keyword">return</span> s.x; }

foo( S(1, 2) ); <span class="d_comment">// set field x to 1, field y to 2
</span></span></pre>

        <p>Struct literals are syntactically like function calls.
        If a struct has a member function named <tt><span class="notranslate">opCall</span></tt>, then
        struct literals for that struct are not possible.
        It is an error if there are more arguments than fields of
        the struct.
        If there are fewer arguments than fields, the remaining
        fields are initialized with their respective default
        initializers.
        If there are anonymous unions in the struct, only the first
        member of the anonymous union can be initialized with a
        struct literal, and all subsequent non-overlapping fields are default
        initialized.
        </p>

<h3>Struct Properties</h3>

<table border=1 cellpadding=4 cellspacing=0><caption>Struct Properties</caption><tr><td>.sizeof</td> <td>Size in bytes of struct</td></tr>
<tr><td>.alignof</td> <td>Size boundary struct needs to be aligned on</td></tr>
<tr><td>.tupleof</td> <td>Gets type tuple of fields</td></tr>
</table>

<h3>Struct Field Properties</h3>

<table border=1 cellpadding=4 cellspacing=0><caption>Struct Field Properties</caption><tr><td>.offsetof</td> <td>Offset in bytes of field from beginning of struct</td></tr>
</table>

<h3><a name="ConstStruct">Const and Invariant Structs</a></h3>
        <p>A struct declaration can have a storage class of
        <tt><span class="notranslate">const</span></tt>, <tt><span class="notranslate">immutable</span></tt> or <tt><span class="notranslate">shared</span></tt>. It has an equivalent
        effect as declaring each member of the struct as
        <tt><span class="notranslate">const</span></tt>, <tt><span class="notranslate">immutable</span></tt> or <tt><span class="notranslate">shared</span></tt>.
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">const</span> <span class="d_keyword">struct</span> S { <span class="d_keyword">int</span> a; <span class="d_keyword">int</span> b = 2; }

<span class="d_keyword">void</span> main() {
  S s = S(3); <span class="d_comment">// initializes s.a to 3
</span>  S t;        <span class="d_comment">// initializes t.a to 0
</span>  t = s;      <span class="d_comment">// ok, t.a is now 3
</span>  t.a = 4;    <span class="d_comment">// error, t.a is const
</span>}
</span></pre>



<h3><a name="Struct-Constructor">Struct Constructors</a></h3>
        <p>Struct constructors are used to initialize an instance
        of a struct.
        The <i>ParameterList</i> may not be empty.
        Struct instances that are not instantiated with a constructor
        are default initialized to their <tt><span class="notranslate">.init</span></tt> value.
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">struct</span> S {
  <span class="d_keyword">int</span> x, y;

  <span class="d_keyword">this</span>()  <span class="d_comment">// error, cannot implement default ctor for structs
</span>  {
  }

  <span class="d_keyword">this</span>(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b)
  {
    x = a;
    y = b;
  }
}

<span class="d_keyword">void</span> main()
{
  S a = S(4, 5);
  <span class="d_keyword">auto</span> b = S();  <span class="d_comment">// same as auto b = S.init;
</span>}
</span></pre>



<h3><a name="StructPostblit">Struct Postblits</a></h3>
<pre class="bnf"><span class="notranslate"><a name="StructPostblit"><i>StructPostblit</i></a>:
    <b>this(this)</b> <a href="function.html#FunctionBody"><i>FunctionBody</i></a>
</span></pre>

        <p><i>Copy construction</i> is defined as initializing
         a struct instance from another struct of the same type.
         Copy construction is divided into two parts:</p>

        <ol>       <li>blitting the fields, i.e. copying the bits</li>
        <li>running <i>postblit</i> on the result</li>
        </ol>

        <p>The first part is done automatically by the language,
        the second part is done if a postblit function is defined
        for the struct.
        The postblit has access only to the destination struct object,
        not the source.
        Its job is to &lsquo;fix up&rsquo; the destination as necessary, such as
        making copies of referenced data, incrementing reference counts,
        etc. For example:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">struct</span> S {
  <span class="d_keyword">int</span>[] a;    <span class="d_comment">// array is privately owned by this instance
</span>  <span class="d_keyword">this</span>(<span class="d_keyword">this</span>) {
    a = a.dup;
  }
  ~<span class="d_keyword">this</span>() {
    <span class="d_keyword">delete</span> a;
  }
}
</span></pre>




<h3><a name="StructDestructor">Struct Destructors</a></h3>
        <p>Destructors are called when an object goes out of scope.
        Their purpose is to free up resources owned by the struct
        object.
        </p>



<h3><a name="AssignOverload">Assignment Overload</a></h3>
        <p>While copy construction takes care of initializing
        an object from another object of the same type,
        assignment is defined as copying the contents of one
        object over another, already initialized, type:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">struct</span> S { ... }
S s;      <span class="d_comment">// default construction of s
</span>S t = s;  <span class="d_comment">// t is copy-constructed from s
</span>t = s;    <span class="d_comment">// t is assigned from s
</span></span></pre>

        <p>Struct assignment <tt><span class="notranslate">t=s</span></tt> is defined to be semantically
        equivalent to:
        </p>

<pre class="d_code"><span class="notranslate">t = S.opAssign(s);
</span></pre>

        <p>where <tt><span class="notranslate">opAssign</span></tt> is a member function of S:</p>

<pre class="d_code"><span class="notranslate">S* opAssign(S s)
{   ... bitcopy *<span class="d_keyword">this</span> into tmp ...
    ... bitcopy s into *<span class="d_keyword">this</span> ...
    ... call destructor on tmp ...
    <span class="d_keyword">return</span> <span class="d_keyword">this</span>;
}
</span></pre>

        <p>While the compiler will generate a default <tt><span class="notranslate">opAssign</span></tt>
        as needed, a user-defined one can be supplied. The user-defined
        one must still implement the equivalent semantics, but can
        be more efficient.
        </p>

        <p>One reason a custom <tt><span class="notranslate">opAssign</span></tt> might be more efficient
        is if the struct has a reference to a local buffer:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">struct</span> S {
  <span class="d_keyword">int</span>[] buf;
  <span class="d_keyword">int</span> a;

  S* opAssign(<span class="d_keyword">ref</span> <span class="d_keyword">const</span> S s) {
    a = s.a;
    <span class="d_keyword">return</span> <span class="d_keyword">this</span>;
  }

  <span class="d_keyword">this</span>(<span class="d_keyword">this</span>) {
    buf = buf.dup;
  }

  ~<span class="d_keyword">this</span>() {
    <span class="d_keyword">delete</span> buf;
  }
}
</span></pre>

        <p>Here, <tt><span class="notranslate">S</span></tt> has a temporary workspace <tt><span class="notranslate">buf[]</span></tt>.
        The normal postblit
        will pointlessly free and reallocate it. The custom <tt><span class="notranslate">opAssign</span></tt>
        will reuse the existing storage.
        </p>




<h2><a name="nested">Nested Structs</a></h2>

        <p>A <i>nested struct</i> is a struct that is declared inside the scope
        of a function or a templated struct that has aliases to local
        functions as a template argument.
        Nested structs have member functions.
        It has access to the context of its enclosing scope
        (via an added hidden field).
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">void</span> foo() {
  <span class="d_keyword">int</span> i = 7;
  <span class="d_keyword">struct</span> SS {
    <span class="d_keyword">int</span> x,y;
    <span class="d_keyword">int</span> bar() { <span class="d_keyword">return</span> x + i + 1; }
  }
  SS s;
  s.x = 3;
  s.bar(); <span class="d_comment">// returns 11
</span>}
</span></pre>

        <p>Nested structs cannot be used as fields or as the
        element type of an array:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">void</span> foo() {
  <span class="d_keyword">int</span> i = 7;
  <span class="d_keyword">struct</span> SS {
    <span class="d_keyword">int</span> x,y;
    <span class="d_keyword">int</span> bar() { <span class="d_keyword">return</span> x + i + 1; }
  }
  <span class="d_keyword">struct</span> DD {
    SS s;  <span class="d_comment">// error, cannot be field
</span>  }
  SS[3] a; <span class="d_comment">// error, cannot be array element
</span>  SS[] a;  <span class="d_comment">// error, cannot be array element
</span>}
</span></pre>

        <p>A struct can be prevented from being nested by
        using the static attribute, but then of course it
        will not be able to access variables from its enclosing
        scope.</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">void</span> foo() {
  <span class="d_keyword">int</span> i = 7;
  <b><span class="d_keyword">static</span></b> <span class="d_keyword">struct</span> SS {
    <span class="d_keyword">int</span> x,y;
    <span class="d_keyword">int</span> bar() {
      <span class="d_keyword">return</span> i; <span class="d_comment">// error, SS is not a nested struct
</span>    }
  }
}
</span></pre>

        <p>A templated struct can become a nested struct if it
        has a local function passed as an aliased argument:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">struct</span> A(<span class="d_keyword">alias</span> F) {
  <span class="d_keyword">int</span> fun(<span class="d_keyword">int</span> i) { <span class="d_keyword">return</span> F(i); }
}

A!(F) makeA(<span class="d_keyword">alias</span> F)() {<span class="d_keyword">return</span> A!(F)(); }

<span class="d_keyword">void</span> main() {
  <span class="d_keyword">int</span> x = 40;
  <span class="d_keyword">int</span> fun(<span class="d_keyword">int</span> i) { <span class="d_keyword">return</span> x + i; }
  A!(fun) a = makeA!(fun)();
  a.fun(2);
}
</span></pre>



  
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="3651639259";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

</div>




<div id="footernav">
<a href="http://www.digitalmars.com/NewsGroup.html" title="User Forums">Forums</a> |
<a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/Struct" title="Read/write comments and feedback">Comments</a> |
<a href="index.html" title="D Programming Language" class="dlink">&nbsp;D&nbsp;</a> |
<a href="http://www.digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a> |
<a href="http://www.digitalmars.com/d/download.html" title="download D">Downloads</a> |
<a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a>
</div>
<div id="copyright">

Copyright &copy; 1999-2011 by Digital Mars &reg;, All Rights Reserved
 |
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>


<script src="http://completelyexpendable.info/editable_code.js"></script>
</body>
</html>

