<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html>

<!--
	Copyright (c) 1999-2010 by Digital Mars
	All Rights Reserved Written by Walter Bright
	http://www.digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>std.container - D Programming Language - Digital Mars</title>
<link rel="stylesheet" type="text/css" href="../style.css">

<script>
function listanchors()
{
    var a = document.getElementById("quickindex");
    if (!a) return;
    var newText = "";
    var hash = new Array;
    var n = 0;
    var values = new Array;
    // List all anchors.
    for (var i = 0; i < document.anchors.length; i++)
    {
        var a = document.anchors[i];
        var text = a.name;
        if (hash[text] > 0) continue;
        hash[text] = 1;
    values[n++] = a.name
    }

    values.sort();

    for(var i = 0; i < values.length; i++) {
        var a = values[i];
        newText += '<a href="#' + a + '"><span class="d_psymbol">'
                + a + '</span></a> ';
    }
    if (newText != "") newText = "<p><b>Jump to:</b> " + newText + '</p>';
    var a = document.getElementById("quickindex");
    a.innerHTML = newText;
}
</script>

</head>

<body onload="listanchors()">
<div id="heading">
	<a href="http://www.digitalmars.com/"><img src="../dmlogo.gif" width="270" height="53" border="0" alt="www.digitalmars.com" align="left"></a>
	<p align="right">D Programming Language 2.0</p>


	<div id="headingNav">
	<ul>	<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/Phobos/StdContainer" title="Read/write comments and feedback">Comments</a></li>
	<li><a href="../index.html" title="D Programming Language" class="dlink">D</a></li>
	<li><a href="http://www.digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a></li>
	<li><a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a></li>
	</ul>
	</div>

	<div id="lastupdate">Last update Sun Jul 10 10:47:16 2011
</div>
</div>

<div id="navigation">
    
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input id="q" name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/d/2.0/phobos">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="../index.html" title="D Programming Language">D</a></li>
	<li><a href="../lex.html" title="D Language Specification">Language</a></li>
	<li><a href="phobos.html" title="D Runtime Library">Phobos</a></li>
	<li><a href="../comparison.html" title="Language Comparisons">Comparisons</a></li>
    </ul>
</div>
</div>

    
<div class="navblock">
    <ul>	<li><a href="object.html" title="root of object hierarchy">object</a></li>
    </ul>
    <h2><a href="phobos.html#std" title="D standard modules">std</a></h2>
    <ul>	<li><a href="std_algorithm.html" title="General-purpose algorithms">std.algorithm</a></li>
	<li><a href="std_array.html" title="Array functions">std.array</a></li>
	<li><a href="std_base64.html" title="Encode/decode base64 format">std.base64</a></li>
	<li><a href="std_bigint.html" title="Arbitrary-precision ('bignum') arithmetic">std.bigint</a></li>
	<li><a href="std_bind.html" title="Function argument binding">std.bind</a></li>
	<li><a href="std_bitmanip.html" title="Bit-level manipulation">std.bitmanip</a></li>
	<li><a href="std_boxer.html" title="Box/unbox types">std.boxer</a></li>
	<li><a href="std_compiler.html" title="Information about the D compiler implementation">std.compiler</a></li>
	<li><a href="std_complex.html" title="Complex numbers">std.complex</a></li>
	<li><a href="std_concurrency.html" title="Message Passing">std.concurrency</a></li>
	<li><a href="std_container.html" title="Containers">std.container</a></li>
	<li><a href="std_contracts.html" title="Think assert">std.contracts</a></li>
	<li><a href="std_conv.html" title="Conversion of strings to integers">std.conv</a></li>
	<li><a href="std_cover.html" title="D coverage analyzer">std.cover</a></li>
	<li><a href="std_cpuid.html" title="CPU identification">std.cpuid</a></li>
	<li><a href="std_ctype.html" title="Simple character classification">std.ctype</a></li>
	<li><a href="std_date.html" title="Date and time functions">std.date</a></li>
	<li><a href="std_datetime.html" title="Date and time-related types and functions">std.datetime</a></li>
	<li><a href="std_demangle.html" title="Demangle D names">std.demangle</a></li>
	<li><a href="std_encoding.html" title="Character and string encoding">std.encoding</a></li>
	<li><a href="std_exception.html" title="Exceptions and error handling">std.exception</a></li>
	<li><a href="std_file.html" title="Basic file operations">std.file</a></li>
	<li><a href="std_format.html" title="Formatted conversions of values to strings">std.format</a></li>
	<li><a href="std_functional.html" title="functional">std.functional</a></li>
	<li><a href="std_gc.html" title="Control the garbage collector">std.gc</a></li>
	<li><a href="std_getopt.html" title="Command line options">std.getopt</a></li>
	<li><a href="std_gregorian.html" title="Gregorian Calendar">std.gregorian</a></li>
	<li><a href="std_intrinsic.html" title="Compiler built in intrinsic functions">std.intrinsic</a></li>
	<li><a href="std_json.html" title="JSON reader">std.json</a></li>
	<li><a href="std_math.html" title="the usual math functions">std.math</a></li>
	<li><a href="std_mathspecial.html" title="mathematical special functions">std.mathspecial</a></li>
	<li><a href="std_md5.html" title="Compute MD5 digests">std.md5</a></li>
	<li><a href="std_metastrings.html" title="Metaprogramming with strings">std.metastrings</a></li>
	<li><a href="std_mmfile.html" title="Memory mapped files">std.mmfile</a></li>
	<li><a href="std_numeric.html" title="Numeric algorithms">std.numeric</a></li>
	<li><a href="std_outbuffer.html" title="Assemble data into an array of bytes">std.outbuffer</a></li>
	<li><a href="std_outofmemory.html" title="Out of memory exception">std.outofmemory</a></li>
	<li><a href="std_path.html" title="Manipulate file names, path names, etc.">std.path</a></li>
	<li><a href="std_parallelism.html" title="High level primitives for SMP parallelism">std.parallelism</a></li>
	<li><a href="std_process.html" title="Create/destroy threads">std.process</a></li>
	<li><a href="std_random.html" title="Random number generation">std.random</a></li>
	<li><a href="std_range.html" title="Ranges">std.range</a></li>
	<li><a href="std_regex.html" title="regular expressions">std.regex</a></li>
	<li><a href="std_regexp.html" title="regular expressions (deprecated)">std.regexp</a></li>
	<li><a href="std_signals.html" title="Signals">std.signals</a></li>
	<li><a href="std_socket.html" title="Sockets">std.socket</a></li>
	<li><a href="std_socketstream.html" title="Stream for a blocking, connected Socket">std.socketstream</a></li>
	<li><a href="std_stdint.html" title="Integral types for various purposes">std.stdint</a></li>
	<li><a href="std_stdio.html" title="Standard I/O">std.stdio</a></li>
	<li><a href="std_cstream.html" title="Stream I/O">std.cstream</a></li>
	<li><a href="std_stream.html" title="Stream I/O">std.stream</a></li>
	<li><a href="std_string.html" title="Basic string operations">std.string</a></li>
	<li><a href="std_system.html" title="Inquire about the CPU, operating system">std.system</a></li>
	<li><a href="std_thread.html" title="Thread operations">std.thread</a></li>
	<li><a href="std_traits.html" title="Type traits">std.traits</a></li>
	<li><a href="std_typecons.html" title="Type constructors">std.typecons</a></li>
	<li><a href="std_typetuple.html" title="Type tuples">std.typetuple</a></li>
	<li><a href="std_uni.html" title="Unicode classification">std.uni</a></li>
	<li><a href="std_uri.html" title="Encode and decode Uniform Resource Identifiers (URIs)">std.uri</a></li>
	<li><a href="std_utf.html" title="Encode and decode utf character encodings">std.utf</a></li>
	<li><a href="std_variant.html" title="Stores all types in a uniform, dynamically-checked representation">std.variant</a></li>
	<li><a href="std_xml.html" title="XML file processing">std.xml</a></li>
	<li><a href="std_zip.html" title="Read/write zip archives">std.zip</a></li>
	<li><a href="std_zlib.html" title="Compression / Decompression of data">std.zlib</a></li>
	<li><a href="std_c_fenv.html" title="Floating point environment">std.c.fenv</a></li>
	<li><a href="std_c_locale.html" title="Locale">std.c.locale</a></li>
	<li><a href="std_c_math.html" title="Math">std.c.math</a></li>
	<li><a href="std_c_process.html" title="Process">std.c.process</a></li>
	<li><a href="std_c_stdarg.html" title="Variadic arguments">std.c.stdarg</a></li>
	<li><a href="std_c_stddef.html" title="Standard definitions">std.c.stddef</a></li>
	<li><a href="std_c_stdio.html" title="Standard I/O">std.c.stdio</a></li>
	<li><a href="std_c_stdlib.html" title="Standard library">std.c.stdlib</a></li>
	<li><a href="std_c_string.html" title="Strings">std.c.string</a></li>
	<li><a href="std_c_time.html" title="Time">std.c.time</a></li>
	<li><a href="std_c_wcharh.html" title="Wide characters">std.c.wcharh</a></li>
	<li><a href="std_net_isemail.html" title="Validate email addresses">std.net.isemail</a></li>
	<li><a href="std_windows_charset.html" title="Conversion to/from Windows character sets">std.windows.charset</a></li>
	<li><a href="phobos.html#std_windows" title="Modules specific to Windows">std.windows</a></li>
	<li><a href="phobos.html#std_linux" title="Modules specific to Windows">std.linux</a></li>
	<li><a href="phobos.html#std_c_windows" title="C Windows API">std.c.windows</a></li>
	<li><a href="phobos.html#std_c_linux" title="C Linux API">std.c.linux</a></li>
    </ul>
    <h2><a href="phobos.html#etc" title="D etc modules">etc</a></h2>
    <ul>	<li><a href="etc_c_curl.html" title="Interface to libcurl library">etc.c.curl</a></li>
	<li><a href="etc_c_zlib.html" title="Interface to zlib library">etc.c.zlib</a></li>
    </ul>
    <h2><a href="phobos.html#core" title="D core modules">core</a></h2>
    <ul>	<li><a href="core_atomic.html" title="Atomic operations">core.atomic</a></li>
	<li><a href="core_bitop.html" title="Bitwise operations">core.bitop</a></li>
	<li><a href="core_cpuid.html" title="CPU identification">core.cpuid</a></li>
	<li><a href="core_exception.html" title="Root of exception hierarchy">core.exception</a></li>
	<li><a href="core_memory.html" title="Interface to memory management">core.memory</a></li>
	<li><a href="core_runtime.html" title="Interface to D runtime library internals">core.runtime</a></li>
	<li><a href="core_time.html" title="Time">core.time</a></li>
	<li><a href="core_thread.html" title="Thread management">core.thread</a></li>
	<li><a href="core_vararg.html" title="Variable function arguments">core.vararg</a></li>
	<li><a href="core_sync_barrier.html" title="Synchronizing progress of a group of threads">core.sync.barrier</a></li>
	<li><a href="core_sync_condition.html" title="Synchronized condition checking">core.sync.condition</a></li>
	<li><a href="core_sync_config.html" title="Stuff for core.sync">core.sync.config</a></li>
	<li><a href="core_sync_exception.html" title="SyncException">core.sync.exception</a></li>
	<li><a href="core_sync_mutex.html" title="Mutexes">core.sync.mutex</a></li>
	<li><a href="core_sync_rwmutex.html" title="R/W mutually exclusive access">core.sync.rwmutex</a></li>
	<li><a href="core_sync_semaphore.html" title="Semaphores">core.sync.semaphore</a></li>
    </ul>
</div>

</div>
<div id="content">
    <h1>std.container</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from std\container.d -->
Defines generic containers.
<p></p>
<b>Source:</b><br>
<a href="https://github.com/D-Programming-Language/phobos/blob/master/std/container.d">std/container.d</a>
<p></p>
<b>License:</b><br>Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at <a href="http://boost.org/LICENSE_1_0.txt">boost.org/LICENSE_1_0.txt</a>).

<p></p>
<b>Authors:</b><br>Steven Schveighoffer, <a href="http://erdani.com">Andrei Alexandrescu</a>
<p></p>


<table cellspacing=0 cellpadding=5 valign=top class=book><caption>Container primitives. Below, <span class="d_inlinecode">C</span> means
a container type, <span class="d_inlinecode">c</span> is a value of container type, <span class="d_inlinecode">n<sub>x</sub>
</span> represents the effective length of value <span class="d_inlinecode">x</span>, which could be a
single element (in which case <span class="d_inlinecode">n<sub>x</sub>
</span> is <span class="d_inlinecode">1</span>), a container,
or a range.</caption><p></p>


<tr><th>Syntax</th> <th><i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">&middot;</span><b></i>)</i></b></th> <th>Description</th></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">C(x)</span></td> <td valign=top><span class="d_inlinecode">n<sub>x</sub>
</span></td> <td valign=top>Creates a
container of type <span class="d_inlinecode">C</span> from either another container or a range.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c.dup</span></td> <td valign=top><span class="d_inlinecode">n<sub>c</sub>
</span></td> <td valign=top>Returns a
duplicate of the container.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c ~ x</span></td> <td valign=top><span class="d_inlinecode">n<sub>c</sub>
 + n<sub>x</sub>
</span></td> <td valign=top>Returns the concatenation of <span class="d_inlinecode">c</span> and <span class="d_inlinecode">r</span>. <span class="d_inlinecode">x</span> may be a single
element or an input range.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">x ~ c</span></td> <td valign=top><span class="d_inlinecode">n<sub>c</sub>
 + n<sub>x</sub>
</span></td> <td valign=top>Returns the concatenation of <span class="d_inlinecode">x</span> and <span class="d_inlinecode">c</span>.  <span class="d_inlinecode">x</span> may be a
single element or an input range type.</td></tr>
<p></p>



<p></p>


<tr><td valign=top><span class="d_inlinecode">c.Range</span></td> <td valign=top></td> <td valign=top>The primary range
type associated with the container.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c[]</span></td> <td valign=top><span class="d_inlinecode">log n<sub>c</sub>
</span></td> <td valign=top>Returns a range
iterating over the entire container, in a container-defined order.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c[a, b]</span></td> <td valign=top><span class="d_inlinecode">log n<sub>c</sub>
</span></td> <td valign=top>Fetches a
portion of the container from key <span class="d_inlinecode">a</span> to key <span class="d_inlinecode">b</span>.</td></tr>
<p></p>



<p></p>


<tr><td valign=top><span class="d_inlinecode">c.empty</span></td> <td valign=top><span class="d_inlinecode">1</span></td> <td valign=top>Returns <span class="d_inlinecode"><b>true</b></span> if the
container has no elements, <span class="d_inlinecode"><b>false</b></span> otherwise.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c.length</span></td> <td valign=top><span class="d_inlinecode">log n<sub>c</sub>
</span></td> <td valign=top>Returns the
number of elements in the container.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c.length = n</span></td> <td valign=top><span class="d_inlinecode">n<sub>c</sub>
 + n</span></td> <td valign=top>Forces
the number of elements in the container to <span class="d_inlinecode">n</span>. If the container
ends up growing, the added elements are initialized in a
container-dependent manner (usually with <span class="d_inlinecode">T.init</span>).</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c.capacity</span></td> <td valign=top><span class="d_inlinecode">log n<sub>c</sub>
</span></td> <td valign=top>Returns the
maximum number of elements that can be stored in the container
without triggering a reallocation.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c.reserve(x)</span></td> <td valign=top><span class="d_inlinecode">n<sub>c</sub>
</span></td> <td valign=top>Forces <span class="d_inlinecode">capacity</span> to at least <span class="d_inlinecode">x</span> without reducing it.</td></tr>
<p></p>



<p></p>


<tr><td valign=top><span class="d_inlinecode">c.front</span></td> <td valign=top><span class="d_inlinecode">log n<sub>c</sub>
</span></td> <td valign=top>Returns the
first element of the container, in a container-defined order.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c.moveFront</span></td> <td valign=top><span class="d_inlinecode">log n<sub>c</sub>
</span></td> <td valign=top>Destructively reads and returns the first element of the
container. The slot is not removed from the container; it is left
initalized with <span class="d_inlinecode">T.init</span>. This routine need not be defined if <span class="d_inlinecode">front</span> returns a <span class="d_inlinecode">ref</span>.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c.front = v</span></td> <td valign=top><span class="d_inlinecode">log n<sub>c</sub>
</span></td> <td valign=top>Assigns
<span class="d_inlinecode">v</span> to the first element of the container.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c.back</span></td> <td valign=top><span class="d_inlinecode">log n<sub>c</sub>
</span></td> <td valign=top>Returns the
last element of the container, in a container-defined order.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c.moveBack</span></td> <td valign=top><span class="d_inlinecode">log n<sub>c</sub>
</span></td> <td valign=top>Destructively reads and returns the first element of the
<a name="container"></a><u>container</u>. The slot is not removed from the container; it is left
initalized with <span class="d_inlinecode">T.init</span>. This routine need not be defined if <span class="d_inlinecode">front</span> returns a <span class="d_inlinecode">ref</span>.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c.back = v</span></td> <td valign=top><span class="d_inlinecode">log n<sub>c</sub>
</span></td> <td valign=top>Assigns
<span class="d_inlinecode">v</span> to the last element of the container.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c[x]</span></td> <td valign=top><span class="d_inlinecode">log n<sub>c</sub>
</span></td> <td valign=top>Provides
indexed access into the container. The index type is
container-defined. A <a name="container"></a><u>container</u> may define several index types (and
consequently overloaded indexing).</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c.moveAt(x)</span></td> <td valign=top><span class="d_inlinecode">log n<sub>c</sub>
</span></td> <td valign=top>Destructively reads and returns the value at position <span class="d_inlinecode">x</span>. The slot
is not removed from the container; it is left initialized with <span class="d_inlinecode">T.init</span>.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c[x] = v</span></td> <td valign=top><span class="d_inlinecode">log n<sub>c</sub>
</span></td> <td valign=top>Sets
element at specified index into the container.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c[x] <i>op</i>= v</span></td> <td valign=top><span class="d_inlinecode">log n<sub>c</sub>
</span></td>
<td valign=top>Performs read-modify-write operation at specified index into the
container.</td></tr>
<p></p>



<p></p>


<tr><td valign=top><span class="d_inlinecode">e in c</span></td> <td valign=top><span class="d_inlinecode">log n<sub>c</sub>
</span></td> <td valign=top>Returns nonzero if e is found in <span class="d_inlinecode">c</span>.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c.lowerBound(v)</span></td> <td valign=top><span class="d_inlinecode">log n<sub>c</sub>
</span></td> <td valign=top>Returns a range of all elements strictly less than <span class="d_inlinecode">v</span>.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c.upperBound(v)</span></td> <td valign=top><span class="d_inlinecode">log n<sub>c</sub>
</span></td> <td valign=top>Returns a range of all elements strictly greater than <span class="d_inlinecode">v</span>.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c.equalRange(v)</span></td> <td valign=top><span class="d_inlinecode">log n<sub>c</sub>
</span></td> <td valign=top>Returns a range of all elements in <span class="d_inlinecode">c</span> that are equal to <span class="d_inlinecode">v</span>.</td></tr>
<p></p>



<p></p>


<tr><td valign=top><span class="d_inlinecode">c ~= x</span></td> <td valign=top><span class="d_inlinecode">n<sub>c</sub>
 + n<sub>x</sub>
</span></td>
<td valign=top>Appends <span class="d_inlinecode">x</span> to <span class="d_inlinecode">c</span>. <span class="d_inlinecode">x</span> may be a single element or an
input range type.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c.clear()</span></td> <td valign=top><span class="d_inlinecode">n<sub>c</sub>
</span></td> <td valign=top>Removes all
elements in <span class="d_inlinecode">c</span>.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c.insert(x)</span></td> <td valign=top><span class="d_inlinecode">n<sub>x</sub>
 * log n<sub>c</sub>
</span></td>
<td valign=top>Inserts <span class="d_inlinecode">x</span> in <span class="d_inlinecode">c</span> at a position (or positions) chosen by <span class="d_inlinecode">c</span>.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c.stableInsert(x)</span></td>
<td valign=top><span class="d_inlinecode">n<sub>x</sub>
 * log n<sub>c</sub>
</span></td> <td valign=top>Same as <span class="d_inlinecode">c.insert(x)</span>,
but is guaranteed to not invalidate any ranges.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c.linearInsert(v)</span></td> <td valign=top><span class="d_inlinecode">n<sub>c</sub>
</span></td> <td valign=top>Same
as <span class="d_inlinecode">c.insert(v)</span> but relaxes complexity to linear.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c.stableLinearInsert(v)</span></td> <td valign=top><span class="d_inlinecode">n<sub>c</sub>
</span></td>
<td valign=top>Same as <span class="d_inlinecode">c.stableInsert(v)</span> but relaxes complexity to linear.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c.removeAny()</span></td> <td valign=top><span class="d_inlinecode">log n<sub>c</sub>
</span></td>
<td valign=top>Removes some element from <span class="d_inlinecode">c</span> and returns it.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c.stableRemoveAny(v)</span></td> <td valign=top><span class="d_inlinecode">log n<sub>c</sub>
</span></td>
<td valign=top>Same as <span class="d_inlinecode">c.removeAny(v)</span>, but is guaranteed to not invalidate any
iterators.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c.insertFront(v)</span></td> <td valign=top><span class="d_inlinecode">log n<sub>c</sub>
</span></td>
<td valign=top>Inserts <span class="d_inlinecode">v</span> at the front of <span class="d_inlinecode">c</span>.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c.stableInsertFront(v)</span></td> <td valign=top><span class="d_inlinecode">log n<sub>c</sub>
</span></td>
<td valign=top>Same as <span class="d_inlinecode">c.insertFront(v)</span>, but guarantees no ranges will be
invalidated.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c.insertBack(v)</span></td> <td valign=top><span class="d_inlinecode">log n<sub>c</sub>
</span></td>
<td valign=top>Inserts <span class="d_inlinecode">v</span> at the back of <span class="d_inlinecode">c</span>.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c.stableInsertBack(v)</span></td> <td valign=top><span class="d_inlinecode">log n<sub>c</sub>
</span></td>
<td valign=top>Same as <span class="d_inlinecode">c.insertBack(v)</span>, but guarantees no ranges will be
invalidated.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c.removeFront()</span></td> <td valign=top><span class="d_inlinecode">log n<sub>c</sub>
</span></td>
<td valign=top>Removes the element at the front of <span class="d_inlinecode">c</span>.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c.stableRemoveFront()</span></td> <td valign=top><span class="d_inlinecode">log n<sub>c</sub>
</span></td>
<td valign=top>Same as <span class="d_inlinecode">c.removeFront()</span>, but guarantees no ranges will be
invalidated.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c.removeBack()</span></td> <td valign=top><span class="d_inlinecode">log n<sub>c</sub>
</span></td>
<td valign=top>Removes the value at the back of <span class="d_inlinecode">c</span>.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c.stableRemoveBack()</span></td> <td valign=top><span class="d_inlinecode">log n<sub>c</sub>
</span></td>
<td valign=top>Same as <span class="d_inlinecode">c.removeBack()</span>, but guarantees no ranges will be
invalidated.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c.remove(r)</span></td> <td valign=top><span class="d_inlinecode">n<sub>r</sub>
 * log n<sub>c</sub>
</span></td>
<td valign=top>Removes range <span class="d_inlinecode">r</span> from <span class="d_inlinecode">c</span>.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c.stableRemove(r)</span></td>
<td valign=top><span class="d_inlinecode">n<sub>r</sub>
 * log n<sub>c</sub>
</span></td>
<td valign=top>Same as <span class="d_inlinecode">c.remove(r)</span>, but guarantees iterators are not
invalidated.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c.linearRemove(r)</span></td> <td valign=top><span class="d_inlinecode">n<sub>c</sub>
</span></td>
<td valign=top>Removes range <span class="d_inlinecode">r</span> from <span class="d_inlinecode">c</span>.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c.stableLinearRemove(r)</span></td> <td valign=top><span class="d_inlinecode">n<sub>c</sub>
</span></td>
<td valign=top>Same as <span class="d_inlinecode">c.linearRemove(r)</span>, but guarantees iterators are not
invalidated.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode">c.removeKey(k)</span></td> <td valign=top><span class="d_inlinecode">log n<sub>c</sub>
</span></td>
<td valign=top>Removes an element from <span class="d_inlinecode">c</span> by using its key <span class="d_inlinecode">k</span>.
The key's type is defined by the container.</td></tr>
<p></p>


<tr><td valign=top><span class="d_inlinecode"></span></td> <td valign=top><span class="d_inlinecode"></span></td> <td valign=top></td></tr>
<p></p>


</table><p></p>

<dl><dt><div class="d_decl">Container <a name="make"></a><u>make</u>(Container, T...)(T <i>arguments</i>);
<br>Container <a name="make"></a><u>make</u>(Container, T...)(T <i>arguments</i>);
</div></dt>
<dd>Returns an initialized container. This function is mainly for
eliminating construction differences between <span class="d_inlinecode">class</span> containers and
<span class="d_inlinecode">struct</span> containers.<p></p>

</dd>
<dt><div class="d_decl">struct <a name="SList"></a><u>SList</u>(T);
</div></dt>
<dd>Implements a simple and fast singly-linked list.<p></p>

<dl><dt><div class="d_decl">auto this(U)(U[] <i>values</i>...);
</div></dt>
<dd>Constructor taking a number of nodes<p></p>

</dd>
<dt><div class="d_decl">auto this(Stuff)(Stuff <i>stuff</i>);
</div></dt>
<dd>Constructor taking an input range<p></p>

</dd>
<dt><div class="d_decl">const bool <a name="opEquals"></a><u>opEquals</u>(ref const SList <i>rhs</i>);
</div></dt>
<dd>Comparison for equality.
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">min(n, n1)</span><b></i>)</i></b> where <span class="d_inlinecode">n1</span> is the number of
elements in <span class="d_inlinecode"><i>rhs</i></span>.<p></p>

</dd>
<dt><div class="d_decl">struct <a name="Range"></a><u>Range</u>;
</div></dt>
<dd>Defines the container's primary range, which embodies a forward range.<p></p>

<dl><dt><div class="d_decl">const bool <a name="empty"></a><u>empty</u>();
<br>Range <a name="save"></a><u>save</u>();
<br>T <a name="front"></a><u>front</u>();
<br>void <a name="front"></a><u>front</u>(T <i>value</i>);
<br>void <a name="popFront"></a><u>popFront</u>();
</div></dt>
<dd>Forward range primitives.<p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">const bool <a name="empty"></a><u>empty</u>();
</div></dt>
<dd>Property returning <span class="d_inlinecode"><b>true</b></span> if and only if the container has no
elements.
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">1</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">SList <a name="dup"></a><u>dup</u>();
</div></dt>
<dd>Duplicates the container. The elements themselves are not transitively
duplicated.
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">n</span><b></i>)</i></b>.<p></p>

</dd>
<dt><div class="d_decl">Range <a name="opSlice"></a><u>opSlice</u>();
</div></dt>
<dd>Returns a range that iterates over all elements of the container, in
forward order.
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">1</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">T <a name="front"></a><u>front</u>();
</div></dt>
<dd>Forward to <span class="d_inlinecode">opSlice().<a name="front"></a><u>front</u></span>.
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">1</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">void <a name="front"></a><u>front</u>(T <i>value</i>);
</div></dt>
<dd>Forward to <span class="d_inlinecode">opSlice().<a name="front"></a><u>front</u>(<i>value</i>)</span>.
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">1</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">SList <a name="opBinary"></a><u>opBinary</u>(string op, Stuff)(Stuff <i>rhs</i>);
</div></dt>
<dd>Returns a new <span class="d_inlinecode">SList</span> that's the concatenation of <span class="d_inlinecode">this</span> and its
argument. <span class="d_inlinecode">opBinaryRight</span> is only defined if <span class="d_inlinecode">Stuff</span> does not
define <span class="d_inlinecode"><a name="opBinary"></a><u>opBinary</u></span>.<p></p>

</dd>
<dt><div class="d_decl">void <a name="clear"></a><u>clear</u>();
</div></dt>
<dd>Removes all contents from the <span class="d_inlinecode">SList</span>.
<p></p>
<b>Postcondition:</b><br>
<span class="d_inlinecode">empty</span>

<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">1</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">size_t <a name="insertFront"></a><u>insertFront</u>(Stuff)(Stuff <i>stuff</i>);
<br>size_t <a name="insertFront"></a><u>insertFront</u>(Stuff)(Stuff <i>stuff</i>);
<br>alias <a name="insert"></a><u>insert</u>;
<br>alias <a name="stableInsert"></a><u>stableInsert</u>;
<br>alias <a name="stableInsertFront"></a><u>stableInsertFront</u>;
</div></dt>
<dd>Inserts <span class="d_inlinecode">stuff</span> to the front of the container. <span class="d_inlinecode">stuff</span> can be a
value convertible to <span class="d_inlinecode">T</span> or a range of objects convertible to <span class="d_inlinecode">T</span>. The stable version behaves the same, but guarantees that ranges
iterating over the container are never invalidated.
<p></p>
<b>Returns:</b><br>The number of elements inserted

<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">log(n)</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">T <a name="removeAny"></a><u>removeAny</u>();
<br>alias <a name="stableRemoveAny"></a><u>stableRemoveAny</u>;
</div></dt>
<dd>Picks one value from the front of the container, removes it from the
container, and returns it.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode">!empty</span>

<p></p>
<b>Returns:</b><br>The element removed.

<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">1</span><b></i>)</i></b>.<p></p>

</dd>
<dt><div class="d_decl">void <a name="removeFront"></a><u>removeFront</u>();
<br>alias <a name="stableRemoveFront"></a><u>stableRemoveFront</u>;
</div></dt>
<dd>Removes the value at the front of the container. The stable version
behaves the same, but guarantees that ranges iterating over the
container are never invalidated.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode">!empty</span>

<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">1</span><b></i>)</i></b>.<p></p>

</dd>
<dt><div class="d_decl">size_t <a name="removeFront"></a><u>removeFront</u>(size_t <i>howMany</i>);
<br>alias <a name="stableRemoveFront"></a><u>stableRemoveFront</u>;
</div></dt>
<dd>Removes <span class="d_inlinecode"><i>howMany</i></span> values at the front or back of the
container. Unlike the unparameterized versions above, these functions
do not throw if they could not remove <span class="d_inlinecode"><i>howMany</i></span> elements. Instead,
if <span class="d_inlinecode"><i>howMany</i> &gt; n</span>, all elements are removed. The returned value is
the effective number of elements removed. The stable version behaves
the same, but guarantees that ranges iterating over the container are
never invalidated.
<p></p>
<b>Returns:</b><br>The number of elements removed

<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode"><i>howMany</i> * log(n)</span><b></i>)</i></b>.<p></p>

</dd>
<dt><div class="d_decl">size_t <a name="insertAfter"></a><u>insertAfter</u>(Stuff)(Range <i>r</i>, Stuff <i>stuff</i>);
</div></dt>
<dd>Inserts <span class="d_inlinecode">stuff</span> after range <span class="d_inlinecode">r</span>, which must be a range
previously extracted from this container. Given that all ranges for a
list end at the end of the list, this function essentially appends to
the list and uses <span class="d_inlinecode">r</span> as a potentially fast way to reach the last
node in the list. (Ideally <span class="d_inlinecode">r</span> is positioned near or at the last
element of the list.)
<p></p>
<span class="d_inlinecode">stuff</span> can be a value convertible to <span class="d_inlinecode">T</span> or a range of objects
convertible to <span class="d_inlinecode">T</span>. The stable version behaves the same, but
guarantees that ranges iterating over the container are never
invalidated.

<p></p>
<b>Returns:</b><br>The number of values inserted.

<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">k + m</span><b></i>)</i></b>, where <span class="d_inlinecode">k</span> is the number of elements in
<span class="d_inlinecode">r</span> and <span class="d_inlinecode">m</span> is the length of <span class="d_inlinecode">stuff</span>.<p></p>

</dd>
<dt><div class="d_decl">size_t <a name="insertAfter"></a><u>insertAfter</u>(Stuff)(Take!(Range) <i>r</i>, Stuff <i>stuff</i>);
<br>alias <a name="stableInsertAfter"></a><u>stableInsertAfter</u>;
</div></dt>
<dd>Similar to <span class="d_inlinecode"><a name="insertAfter"></a><u>insertAfter</u></span> above, but accepts a range bounded in
count. This is important for ensuring fast insertions in the middle of
the list.  For fast insertions after a specified position <span class="d_inlinecode">r</span>, use
<span class="d_inlinecode"><a name="insertAfter"></a><u>insertAfter</u>(take(r, 1), stuff)</span>. The complexity of that operation
only depends on the number of elements in <span class="d_inlinecode">stuff</span>.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode">r.original.empty || r.maxLength &gt; 0</span>

<p></p>
<b>Returns:</b><br>The number of values inserted.

<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">k + m</span><b></i>)</i></b>, where <span class="d_inlinecode">k</span> is the number of elements in
<span class="d_inlinecode">r</span> and <span class="d_inlinecode">m</span> is the length of <span class="d_inlinecode">stuff</span>.<p></p>

</dd>
<dt><div class="d_decl">Range <a name="linearRemove"></a><u>linearRemove</u>(Range <i>r</i>);
</div></dt>
<dd>Removes a range from the list in linear time.
<p></p>
<b>Returns:</b><br>An empty range.

<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">n</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">Range <a name="linearRemove"></a><u>linearRemove</u>(Take!(Range) <i>r</i>);
<br>alias <a name="stableLinearRemove"></a><u>stableLinearRemove</u>;
</div></dt>
<dd>Removes a <span class="d_inlinecode">Take!Range</span> from the list in linear time.
<p></p>
<b>Returns:</b><br>A range comprehending the elements after the removed range.

<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">n</span><b></i>)</i></b><p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">struct <a name="Array"></a><u>Array</u>(T) if (!is(T : const(bool)));
</div></dt>
<dd><a name="Array"></a><u>Array</u> type with deterministic control of memory. The memory allocated
for the array is reclaimed as soon as possible; there is no reliance
on the garbage collector. <span class="d_inlinecode"><a name="Array"></a><u>Array</u></span> uses <span class="d_inlinecode">malloc</span> and <span class="d_inlinecode">free</span>
for managing its own memory.<p></p>

<dl><dt><div class="d_decl">const bool <a name="opEquals"></a><u>opEquals</u>(ref const Array <i>rhs</i>);
</div></dt>
<dd>Comparison for equality.<p></p>

</dd>
<dt><div class="d_decl">struct <a name="Range"></a><u>Range</u>;
</div></dt>
<dd>Defines the container's primary range, which is a random-access range.<p></p>

</dd>
<dt><div class="d_decl">const bool <a name="empty"></a><u>empty</u>();
</div></dt>
<dd>Property returning <span class="d_inlinecode"><b>true</b></span> if and only if the container has no
elements.
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">1</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">Array <a name="dup"></a><u>dup</u>();
</div></dt>
<dd>Duplicates the container. The elements themselves are not transitively
duplicated.
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">n</span><b></i>)</i></b>.<p></p>

</dd>
<dt><div class="d_decl">const size_t <a name="length"></a><u>length</u>();
</div></dt>
<dd>Returns the number of elements in the container.
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">1</span><b></i>)</i></b>.<p></p>

</dd>
<dt><div class="d_decl">size_t <a name="capacity"></a><u>capacity</u>();
</div></dt>
<dd>Returns the maximum number of elements the container can store without
   (a) allocating memory, (b) invalidating iterators upon insertion.
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">1</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">void <a name="reserve"></a><u>reserve</u>(size_t <i>elements</i>);
</div></dt>
<dd>Ensures sufficient capacity to accommodate <span class="d_inlinecode">e</span> <i>elements</i>.
<p></p>
<b>Postcondition:</b><br>
<span class="d_inlinecode">capacity &gt;= e</span>

<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">1</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">Range <a name="opSlice"></a><u>opSlice</u>();
</div></dt>
<dd>Returns a range that iterates over elements of the container, in
forward order.
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">1</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">Range <a name="opSlice"></a><u>opSlice</u>(size_t <i>a</i>, size_t <i>b</i>);
</div></dt>
<dd>Returns <i>a</i> range that iterates over elements of the container from
index <span class="d_inlinecode"><i>a</i></span> up to (excluding) index <span class="d_inlinecode"><i>b</i></span>.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode"><i>a</i> &lt;= <i>b</i> &amp;&amp; <i>b</i> &lt;= length</span>

<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">1</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">const size_t <a name="opDollar"></a><u>opDollar</u>();
</div></dt>
<dd>@@@BUG@@@ This doesn't work yet<p></p>

</dd>
<dt><div class="d_decl">T <a name="front"></a><u>front</u>();
<br>void <a name="front"></a><u>front</u>(T <i>value</i>);
<br>T <a name="back"></a><u>back</u>();
<br>void <a name="back"></a><u>back</u>(T <i>value</i>);
</div></dt>
<dd>Forward to <span class="d_inlinecode">opSlice().<a name="front"></a><u>front</u></span> and <span class="d_inlinecode">opSlice().back</span>, respectively.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode">!empty</span>

<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">1</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">T <a name="opIndex"></a><u>opIndex</u>(size_t <i>i</i>);
<br>void <a name="opIndexAssign"></a><u>opIndexAssign</u>(T <i>value</i>, size_t <i>i</i>);
<br>void <a name="opIndexOpAssign"></a><u>opIndexOpAssign</u>(string op)(T <i>value</i>, size_t <i>i</i>);
</div></dt>
<dd>Indexing operators yield or modify the value at a specified index.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode"><i>i</i> &lt; length</span>

<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">1</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">Array <a name="opBinary"></a><u>opBinary</u>(string op, Stuff)(Stuff <i>stuff</i>);
</div></dt>
<dd>Returns a new container that's the concatenation of <span class="d_inlinecode">this</span> and its
argument. <span class="d_inlinecode">opBinaryRight</span> is only defined if <span class="d_inlinecode">Stuff</span> does not
define <span class="d_inlinecode"><a name="opBinary"></a><u>opBinary</u></span>.
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">n + m</span><b></i>)</i></b>, where m is the number of elements in <span class="d_inlinecode">stuff</span><p></p>

</dd>
<dt><div class="d_decl">void <a name="opOpAssign"></a><u>opOpAssign</u>(string op, Stuff)(Stuff <i>stuff</i>);
</div></dt>
<dd>Forwards to <span class="d_inlinecode">insertBack(stuff)</span>.<p></p>

</dd>
<dt><div class="d_decl">void <a name="clear"></a><u>clear</u>();
</div></dt>
<dd>Removes all contents from the container. The container decides how <span class="d_inlinecode">capacity</span> is affected.
<p></p>
<b>Postcondition:</b><br>
<span class="d_inlinecode">empty</span>

<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">n</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">void <a name="length"></a><u>length</u>(size_t <i>newLength</i>);
</div></dt>
<dd>Sets the number of elements in the container to <span class="d_inlinecode">newSize</span>. If <span class="d_inlinecode">newSize</span> is greater than <span class="d_inlinecode"><a name="length"></a><u>length</u></span>, the added elements are added to
unspecified positions in the container and initialized with <span class="d_inlinecode">T.init</span>.
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">abs(n - <i>newLength</i>)</span><b></i>)</i></b>

<p></p>
<b>Postcondition:</b><br>
<span class="d_inlinecode"><a name="length"></a><u>length</u> == <i>newLength</i></span><p></p>

</dd>
<dt><div class="d_decl">T <a name="removeAny"></a><u>removeAny</u>();
<br>alias <a name="stableRemoveAny"></a><u>stableRemoveAny</u>;
</div></dt>
<dd>Picks one value in an unspecified position in the container, removes
it from the container, and returns it. Implementations should pick the
value that's the most advantageous for the container, but document the
exact behavior. The stable version behaves the same, but guarantees
that ranges iterating over the container are never invalidated.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode">!empty</span>

<p></p>
<b>Returns:</b><br>The element removed.

<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">log(n)</span><b></i>)</i></b>.<p></p>

</dd>
<dt><div class="d_decl">size_t <a name="insertBack"></a><u>insertBack</u>(Stuff)(Stuff <i>stuff</i>);
<br>alias <a name="insert"></a><u>insert</u>;
</div></dt>
<dd>Inserts <span class="d_inlinecode">value</span> to the front or back of the container. <span class="d_inlinecode">stuff</span>
can be a value convertible to <span class="d_inlinecode">T</span> or a range of objects convertible
to <span class="d_inlinecode">T</span>. The stable version behaves the same, but guarantees that
ranges iterating over the container are never invalidated.
<p></p>
<b>Returns:</b><br>The number of elements inserted

<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">m * log(n)</span><b></i>)</i></b>, where <span class="d_inlinecode">m</span> is the number of
elements in <span class="d_inlinecode">stuff</span><p></p>

</dd>
<dt><div class="d_decl">void <a name="removeBack"></a><u>removeBack</u>();
<br>alias <a name="stableRemoveBack"></a><u>stableRemoveBack</u>;
</div></dt>
<dd>Removes the value at the back of the container. The stable version
behaves the same, but guarantees that ranges iterating over the
container are never invalidated.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode">!empty</span>

<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">log(n)</span><b></i>)</i></b>.<p></p>

</dd>
<dt><div class="d_decl">size_t <a name="removeBack"></a><u>removeBack</u>(size_t <i>howMany</i>);
<br>alias <a name="stableRemoveBack"></a><u>stableRemoveBack</u>;
</div></dt>
<dd>Removes <span class="d_inlinecode"><i>howMany</i></span> values at the front or back of the
container. Unlike the unparameterized versions above, these functions
do not throw if they could not remove <span class="d_inlinecode"><i>howMany</i></span> elements. Instead,
if <span class="d_inlinecode"><i>howMany</i> &gt; n</span>, all elements are removed. The returned value is
the effective number of elements removed. The stable version behaves
the same, but guarantees that ranges iterating over the container are
never invalidated.
<p></p>
<b>Returns:</b><br>The number of elements removed

<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode"><i>howMany</i></span><b></i>)</i></b>.<p></p>

</dd>
<dt><div class="d_decl">size_t <a name="insertBefore"></a><u>insertBefore</u>(Stuff)(Range <i>r</i>, Stuff <i>stuff</i>);
<br>size_t <a name="insertBefore"></a><u>insertBefore</u>(Stuff)(Range <i>r</i>, Stuff <i>stuff</i>);
<br>size_t <a name="insertAfter"></a><u>insertAfter</u>(Stuff)(Range <i>r</i>, Stuff <i>stuff</i>);
<br>size_t <a name="replace"></a><u>replace</u>(Stuff)(Range <i>r</i>, Stuff <i>stuff</i>);
<br>size_t <a name="replace"></a><u>replace</u>(Stuff)(Range <i>r</i>, Stuff <i>stuff</i>);
</div></dt>
<dd>Inserts <span class="d_inlinecode">stuff</span> before, after, or instead range <span class="d_inlinecode">r</span>, which must
be a valid range previously extracted from this container. <span class="d_inlinecode">stuff</span>
can be a value convertible to <span class="d_inlinecode">T</span> or a range of objects convertible
to <span class="d_inlinecode">T</span>. The stable version behaves the same, but guarantees that
ranges iterating over the container are never invalidated.
<p></p>
<b>Returns:</b><br>The number of values inserted.

<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">n + m</span><b></i>)</i></b>, where <span class="d_inlinecode">m</span> is the length of <span class="d_inlinecode">stuff</span><p></p>

</dd>
<dt><div class="d_decl">Range <a name="linearRemove"></a><u>linearRemove</u>(Range <i>r</i>);
<br>alias <a name="stableLinearRemove"></a><u>stableLinearRemove</u>;
</div></dt>
<dd>Removes all elements belonging to <span class="d_inlinecode"><i>r</i></span>, which must be a range
obtained originally from this container. The stable version behaves
the same, but guarantees that ranges iterating over the container are
never invalidated.
<p></p>
<b>Returns:</b><br>A range spanning the remaining elements in the container that
initially were right after <span class="d_inlinecode"><i>r</i></span>.

<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">n - m</span><b></i>)</i></b>, where <span class="d_inlinecode">m</span> is the number of elements in
<span class="d_inlinecode"><i>r</i></span><p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">struct <a name="BinaryHeap"></a><u>BinaryHeap</u>(Store,alias less = "a &lt; b") if (isRandomAccessRange!(Store) || isRandomAccessRange!(typeof(Store.init[])));
</div></dt>
<dd>Implements a <a href="http://en.wikipedia.org/wiki/Binary_heap">binary heap</a>
container on top of a given random-access range type (usually <span class="d_inlinecode">T[]</span>) or a random-access container type (usually <span class="d_inlinecode">Array!T</span>). The
documentation of <span class="d_inlinecode"><a name="BinaryHeap"></a><u>BinaryHeap</u></span> will refer to the underlying range or
container as the <i>store</i> of the heap.
<p></p>
The binary heap induces structure over the underlying store such that
accessing the largest element (by using the <span class="d_inlinecode">front</span> property) is a
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">1</span><b></i>)</i></b> operation and extracting it (by using the <span class="d_inlinecode">removeFront()</span> method) is done fast in <i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">log n</span><b></i>)</i></b> time.
<p></p>


If <span class="d_inlinecode">less</span> is the less-than operator, which is the default option,
then <span class="d_inlinecode"><a name="BinaryHeap"></a><u>BinaryHeap</u></span> defines a so-called max-heap that optimizes
extraction of the <i>largest</i> elements. To define a min-heap,
instantiate <a name="BinaryHeap"></a><u>BinaryHeap</u> with <span class="d_inlinecode">"a &gt; b"</span> as its predicate.
<p></p>


Simply extracting elements from a <span class="d_inlinecode"><a name="BinaryHeap"></a><u>BinaryHeap</u></span> container is
tantamount to lazily fetching elements of <span class="d_inlinecode">Store</span> in descending
order. Extracting elements from the <span class="d_inlinecode"><a name="BinaryHeap"></a><u>BinaryHeap</u></span> to completion
leaves the underlying store sorted in ascending order but, again,
yields elements in descending order.
<p></p>


If <span class="d_inlinecode">Store</span> is a range, the <span class="d_inlinecode"><a name="BinaryHeap"></a><u>BinaryHeap</u></span> cannot grow beyond the
size of that range. If <span class="d_inlinecode">Store</span> is a container that supports <span class="d_inlinecode">insertBack</span>, the <span class="d_inlinecode"><a name="BinaryHeap"></a><u>BinaryHeap</u></span> may grow by adding elements to the
container.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_comment">// Example from "Introduction to Algorithms" Cormen et al, p 146
</span><span class="d_keyword">int</span>[] a = [ 4, 1, 3, 2, 16, 9, 10, 14, 8, 7 ];
<span class="d_keyword">auto</span> h = heapify(a);
<span class="d_comment">// largest element
</span><span class="d_keyword">assert</span>(h.front == 16);
<span class="d_comment">// a has the heap property
</span><span class="d_keyword">assert</span>(equal(a, [ 16, 14, 10, 9, 8, 7, 4, 3, 2, 1 ]));
</pre>
<p></p>

<dl><dt><div class="d_decl">auto this(Store <i>s</i>, size_t <i>initialSize</i> = size_t.max);
</div></dt>
<dd>Converts the store <span class="d_inlinecode"><i>s</i></span> into a heap. If <span class="d_inlinecode"><i>initialSize</i></span> is
       specified, only the first <span class="d_inlinecode"><i>initialSize</i></span> elements in <span class="d_inlinecode"><i>s</i></span>
       are transformed into a heap, after which the heap can grow up
       to <span class="d_inlinecode">r.length</span> (if <span class="d_inlinecode">Store</span> is a range) or indefinitely (if
       <span class="d_inlinecode">Store</span> is a container with <span class="d_inlinecode">insertBack</span>). Performs
       <i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">min(r.length, <i>initialSize</i>)</span><b></i>)</i></b> evaluations of <span class="d_inlinecode">less</span>.<p></p>

</dd>
<dt><div class="d_decl">void <a name="acquire"></a><u>acquire</u>(Store <i>s</i>, size_t <i>initialSize</i> = size_t.max);
</div></dt>
<dd>Takes ownership of a store. After this, manipulating <span class="d_inlinecode"><i>s</i></span> may make
the heap work incorrectly.<p></p>

</dd>
<dt><div class="d_decl">void <a name="assume"></a><u>assume</u>(Store <i>s</i>, size_t <i>initialSize</i> = size_t.max);
</div></dt>
<dd>Takes ownership of a store assuming it already was organized as a
heap.<p></p>

</dd>
<dt><div class="d_decl">auto <a name="release"></a><u>release</u>();
</div></dt>
<dd>Clears the heap. Returns the portion of the store from <span class="d_inlinecode">0</span> up to
<span class="d_inlinecode">length</span>, which satisfies the <a href="http://
google.com/search?btnI=I%27m+Feeling+Lucky&ie=UTF-8&oe=UTF-8&q=heap property">heap property</a>.<p></p>

</dd>
<dt><div class="d_decl">bool <a name="empty"></a><u>empty</u>();
</div></dt>
<dd>Returns <span class="d_inlinecode"><b>true</b></span> if the heap is empty, <span class="d_inlinecode"><b>false</b></span> otherwise.<p></p>

</dd>
<dt><div class="d_decl">BinaryHeap <a name="dup"></a><u>dup</u>();
</div></dt>
<dd>Returns a duplicate of the heap. The underlying store must also
support a <span class="d_inlinecode"><a name="dup"></a><u>dup</u></span> method.<p></p>

</dd>
<dt><div class="d_decl">size_t <a name="length"></a><u>length</u>();
</div></dt>
<dd>Returns the length of the heap.<p></p>

</dd>
<dt><div class="d_decl">size_t <a name="capacity"></a><u>capacity</u>();
</div></dt>
<dd>Returns the capacity of the heap, which is the length of the
underlying store (if the store is a range) or the capacity of the
underlying store (if the store is a container).<p></p>

</dd>
<dt><div class="d_decl">ElementType!(Store) <a name="front"></a><u>front</u>();
</div></dt>
<dd>Returns a copy of the front of the heap, which is the largest element
according to <span class="d_inlinecode">less</span>.<p></p>

</dd>
<dt><div class="d_decl">void <a name="clear"></a><u>clear</u>();
</div></dt>
<dd>Clears the heap by detaching it from the underlying store.<p></p>

</dd>
<dt><div class="d_decl">size_t <a name="insert"></a><u>insert</u>(ElementType!(Store) <i>value</i>);
</div></dt>
<dd>Inserts <span class="d_inlinecode"><i>value</i></span> into the store. If the underlying store is a range
and <span class="d_inlinecode">length == capacity</span>, throws an exception.<p></p>

</dd>
<dt><div class="d_decl">void <a name="removeFront"></a><u>removeFront</u>();
</div></dt>
<dd>Removes the largest element from the heap.<p></p>

</dd>
<dt><div class="d_decl">ElementType!(Store) <a name="removeAny"></a><u>removeAny</u>();
</div></dt>
<dd>Removes the largest element from the heap and returns a copy of
it. The element still resides in the heap's store. For performance
reasons you may want to use <span class="d_inlinecode">removeFront</span> with heaps of objects
that are expensive to copy.<p></p>

</dd>
<dt><div class="d_decl">void <a name="replaceFront"></a><u>replaceFront</u>(ElementType!(Store) <i>value</i>);
</div></dt>
<dd>Replaces the largest element in the store with <span class="d_inlinecode"><i>value</i></span>.<p></p>

</dd>
<dt><div class="d_decl">bool <a name="conditionalInsert"></a><u>conditionalInsert</u>(ElementType!(Store) <i>value</i>);
</div></dt>
<dd>If the heap has room to grow, inserts <span class="d_inlinecode"><i>value</i></span> into the store and
returns <span class="d_inlinecode"><b>true</b></span>. Otherwise, if <span class="d_inlinecode">less(<i>value</i>, front)</span>, calls <span class="d_inlinecode">replaceFront(<i>value</i>)</span> and returns again <span class="d_inlinecode"><b>true</b></span>. Otherwise, leaves
the heap unaffected and returns <span class="d_inlinecode"><b>false</b></span>. This method is useful in
scenarios where the smallest <span class="d_inlinecode">k</span> elements of a set of candidates
must be collected.<p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">BinaryHeap!(Store) <a name="heapify"></a><u>heapify</u>(Store)(Store <i>s</i>, size_t <i>initialSize</i> = size_t.max);
</div></dt>
<dd>Convenience function that returns a <span class="d_inlinecode">BinaryHeap!Store</span> object
initialized with <span class="d_inlinecode">s</span> and <span class="d_inlinecode">initialSize</span>.<p></p>

</dd>
<dt><div class="d_decl">struct <a name="Array"></a><u>Array</u>(T) if (is(T == bool));
</div></dt>
<dd>Array specialized for <span class="d_inlinecode">bool</span>. Packs together values efficiently by
allocating one bit per element.<p></p>

<dl><dt><div class="d_decl">struct <a name="Range"></a><u>Range</u>;
</div></dt>
<dd>Defines the container's primary range.<p></p>

<dl><dt><div class="d_decl">Range <a name="save"></a><u>save</u>();
<br>bool <a name="empty"></a><u>empty</u>();
<br>T <a name="front"></a><u>front</u>();
<br>void <a name="front"></a><u>front</u>(bool <i>value</i>);
<br>T <a name="moveFront"></a><u>moveFront</u>();
<br>void <a name="popFront"></a><u>popFront</u>();
<br>T <a name="back"></a><u>back</u>();
<br>T <a name="moveBack"></a><u>moveBack</u>();
<br>void <a name="popBack"></a><u>popBack</u>();
<br>T <a name="opIndex"></a><u>opIndex</u>(size_t <i>i</i>);
<br>void <a name="opIndexAssign"></a><u>opIndexAssign</u>(T <i>value</i>, size_t <i>i</i>);
<br>T <a name="moveAt"></a><u>moveAt</u>(size_t <i>i</i>);
<br>const ulong <a name="length"></a><u>length</u>();
</div></dt>
<dd>Range primitives<p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">bool <a name="empty"></a><u>empty</u>();
</div></dt>
<dd>Property returning <span class="d_inlinecode"><b>true</b></span> if and only if the container has
       no elements.
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">1</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">Array!(bool) <a name="dup"></a><u>dup</u>();
</div></dt>
<dd>Returns a duplicate of the container. The elements themselves
       are not transitively duplicated.
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">n</span><b></i>)</i></b>.<p></p>

</dd>
<dt><div class="d_decl">ulong <a name="length"></a><u>length</u>();
</div></dt>
<dd>Returns the number of elements in the container.
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">log(n)</span><b></i>)</i></b>.<p></p>

</dd>
<dt><div class="d_decl">ulong <a name="capacity"></a><u>capacity</u>();
</div></dt>
<dd>Returns the maximum number of elements the container can store
       without (a) allocating memory, (b) invalidating iterators upon
       insertion.
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">log(n)</span><b></i>)</i></b>.<p></p>

</dd>
<dt><div class="d_decl">void <a name="reserve"></a><u>reserve</u>(ulong <i>e</i>);
</div></dt>
<dd>Ensures sufficient capacity to accommodate <span class="d_inlinecode">n</span> elements.
<p></p>
<b>Postcondition:</b><br>
<span class="d_inlinecode">capacity &gt;= n</span>

<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">log(<i>e</i> - capacity)</span><b></i>)</i></b> if <span class="d_inlinecode"><i>e</i> &gt; capacity</span>,
       otherwise <i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">1</span><b></i>)</i></b>.<p></p>

</dd>
<dt><div class="d_decl">Range <a name="opSlice"></a><u>opSlice</u>();
</div></dt>
<dd>Returns a range that iterates over all elements of the
       container, in a container-defined order. The container should
       choose the most convenient and fast method of iteration for <span class="d_inlinecode">      <a name="opSlice"></a><u>opSlice</u>()</span>.
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">log(n)</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">Range <a name="opSlice"></a><u>opSlice</u>(ulong <i>a</i>, ulong <i>b</i>);
</div></dt>
<dd>Returns <i>a</i> range that iterates the container between two
       specified positions.
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">log(n)</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">bool <a name="front"></a><u>front</u>();
<br>void <a name="front"></a><u>front</u>(bool <i>value</i>);
<br>bool <a name="back"></a><u>back</u>();
<br>void <a name="back"></a><u>back</u>(bool <i>value</i>);
</div></dt>
<dd>Equivalent to <span class="d_inlinecode">opSlice().<a name="front"></a><u>front</u></span> and <span class="d_inlinecode">opSlice().back</span>,
       respectively.
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">log(n)</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">bool <a name="opIndex"></a><u>opIndex</u>(ulong <i>i</i>);
<br>void <a name="opIndexAssign"></a><u>opIndexAssign</u>(bool <i>value</i>, ulong <i>i</i>);
<br>void <a name="opIndexOpAssign"></a><u>opIndexOpAssign</u>(string op)(bool <i>value</i>, ulong <i>i</i>);
<br>T <a name="moveAt"></a><u>moveAt</u>(ulong <i>i</i>);
</div></dt>
<dd>Indexing operators yield or modify the value at a specified index.<p></p>

</dd>
<dt><div class="d_decl">Array!(bool) <a name="opBinary"></a><u>opBinary</u>(string op, Stuff)(Stuff <i>rhs</i>);
</div></dt>
<dd>Returns a new container that's the concatenation of <span class="d_inlinecode">this</span>
       and its argument.
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">n + m</span><b></i>)</i></b>, where m is the number of elements
       in <span class="d_inlinecode">stuff</span><p></p>

</dd>
<dt><div class="d_decl">Array!(bool) <a name="opOpAssign"></a><u>opOpAssign</u>(string op, Stuff)(Stuff <i>stuff</i>);
</div></dt>
<dd>Forwards to <span class="d_inlinecode">insertAfter(this[], stuff)</span>.<p></p>

</dd>
<dt><div class="d_decl">void <a name="clear"></a><u>clear</u>();
</div></dt>
<dd>Removes all contents from the container. The container decides
       how <span class="d_inlinecode">capacity</span> is affected.
<p></p>
<b>Postcondition:</b><br>
<span class="d_inlinecode">empty</span>

<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">n</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">void <a name="length"></a><u>length</u>(ulong <i>newLength</i>);
</div></dt>
<dd>Sets the number of elements in the container to <span class="d_inlinecode">      newSize</span>. If <span class="d_inlinecode">newSize</span> is greater than <span class="d_inlinecode"><a name="length"></a><u>length</u></span>, the
       added elements are added to the container and initialized with
       <span class="d_inlinecode">ElementType.init</span>.
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">abs(n - <i>newLength</i>)</span><b></i>)</i></b>

<p></p>
<b>Postcondition:</b><br>
<span class="d_inlinecode">length == <i>newLength</i></span><p></p>

</dd>
<dt><div class="d_decl">alias <a name="insert"></a><u>insert</u>;
<br>alias <a name="stableInsert"></a><u>stableInsert</u>;
</div></dt>
<dd>Inserts <span class="d_inlinecode">stuff</span> in the container. <span class="d_inlinecode">stuff</span> can be a value
       convertible to <span class="d_inlinecode">ElementType</span> or a range of objects
       convertible to <span class="d_inlinecode">ElementType</span>.
<p></p>
The <span class="d_inlinecode">stable</span> version guarantees that ranges iterating over
       the container are never invalidated. Client code that counts on
       non-invalidating insertion should use <span class="d_inlinecode">stableInsert</span>.

<p></p>
<b>Returns:</b><br>The number of elements added.

<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">m * log(n)</span><b></i>)</i></b>, where <span class="d_inlinecode">m</span> is the number of
       elements in <span class="d_inlinecode">stuff</span><p></p>

</dd>
<dt><div class="d_decl">alias <a name="linearInsert"></a><u>linearInsert</u>;
<br>alias <a name="stableLinearInsert"></a><u>stableLinearInsert</u>;
</div></dt>
<dd>Same as <span class="d_inlinecode">insert(stuff)</span> and <span class="d_inlinecode">stableInsert(stuff)</span>
       respectively, but relax the complexity constraint to linear.<p></p>

</dd>
<dt><div class="d_decl">T <a name="removeAny"></a><u>removeAny</u>();
<br>alias <a name="stableRemoveAny"></a><u>stableRemoveAny</u>;
</div></dt>
<dd>Picks one value in the container, removes it from the
       container, and returns it. The stable version behaves the same,
       but guarantees that ranges iterating over the container are
       never invalidated.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode">!empty</span>

<p></p>
<b>Returns:</b><br>The element removed.

<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">log(n)</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">ulong <a name="insertBack"></a><u>insertBack</u>(Stuff)(Stuff <i>stuff</i>);
<br>ulong <a name="insertBack"></a><u>insertBack</u>(Stuff)(Stuff <i>stuff</i>);
<br>alias <a name="stableInsertBack"></a><u>stableInsertBack</u>;
</div></dt>
<dd>Inserts <span class="d_inlinecode">value</span> to the back of the container. <span class="d_inlinecode">stuff</span> can
       be a value convertible to <span class="d_inlinecode">ElementType</span> or a range of
       objects convertible to <span class="d_inlinecode">ElementType</span>. The stable version
       behaves the same, but guarantees that ranges iterating over the
       container are never invalidated.
<p></p>
<b>Returns:</b><br>The number of elements inserted

<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">log(n)</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">void <a name="removeBack"></a><u>removeBack</u>();
<br>alias <a name="stableRemoveBack"></a><u>stableRemoveBack</u>;
</div></dt>
<dd>Removes the value at the front or back of the container. The
       stable version behaves the same, but guarantees that ranges
       iterating over the container are never invalidated. The
       optional parameter <span class="d_inlinecode">howMany</span> instructs removal of that many
       elements. If <span class="d_inlinecode">howMany &gt; n</span>, all elements are removed and no
       exception is thrown.
<p></p>
<b>Precondition:</b><br>
<span class="d_inlinecode">!empty</span>

<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">log(n)</span><b></i>)</i></b>.<p></p>

</dd>
<dt><div class="d_decl">ulong <a name="removeBack"></a><u>removeBack</u>(ulong <i>howMany</i>);
</div></dt>
<dd>Removes <span class="d_inlinecode"><i>howMany</i></span> values at the front or back of the
       container. Unlike the unparameterized versions above, these
       functions do not throw if they could not remove <span class="d_inlinecode"><i>howMany</i></span>
       elements. Instead, if <span class="d_inlinecode"><i>howMany</i> &gt; n</span>, all elements are
       removed. The returned value is the effective number of elements
       removed. The stable version behaves the same, but guarantees
       that ranges iterating over the container are never invalidated.
<p></p>
<b>Returns:</b><br>The number of elements removed

<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode"><i>howMany</i> * log(n)</span><b></i>)</i></b>.
     
 ditto<p></p>

</dd>
<dt><div class="d_decl">ulong <a name="insertBefore"></a><u>insertBefore</u>(Stuff)(Range <i>r</i>, Stuff <i>stuff</i>);
<br>alias <a name="stableInsertBefore"></a><u>stableInsertBefore</u>;
<br>ulong <a name="insertAfter"></a><u>insertAfter</u>(Stuff)(Range <i>r</i>, Stuff <i>stuff</i>);
<br>alias <a name="stableInsertAfter"></a><u>stableInsertAfter</u>;
<br>size_t <a name="replace"></a><u>replace</u>(Stuff)(Range <i>r</i>, Stuff <i>stuff</i>);
<br>alias <a name="stableReplace"></a><u>stableReplace</u>;
</div></dt>
<dd>Inserts <span class="d_inlinecode">stuff</span> before, after, or instead range <span class="d_inlinecode">r</span>,
       which must be a valid range previously extracted from this
       container. <span class="d_inlinecode">stuff</span> can be a value convertible to <span class="d_inlinecode">      ElementType</span> or a range of objects convertible to <span class="d_inlinecode">      ElementType</span>. The stable version behaves the same, but
       guarantees that ranges iterating over the container are never
       invalidated.
<p></p>
<b>Returns:</b><br>The number of values inserted.

<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">n + m</span><b></i>)</i></b>, where <span class="d_inlinecode">m</span> is the length of <span class="d_inlinecode">stuff</span><p></p>

</dd>
<dt><div class="d_decl">Range <a name="linearRemove"></a><u>linearRemove</u>(Range <i>r</i>);
<br>alias <a name="stableLinearRemove"></a><u>stableLinearRemove</u>;
</div></dt>
<dd>Removes all elements belonging to <span class="d_inlinecode"><i>r</i></span>, which must be a range
       obtained originally from this container. The stable version
       behaves the same, but guarantees that ranges iterating over the
       container are never invalidated.
<p></p>
<b>Returns:</b><br>A range spanning the remaining elements in the container that
       initially were right after <span class="d_inlinecode"><i>r</i></span>.

<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">n</span><b></i>)</i></b><p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">class <a name="RedBlackTree"></a><u>RedBlackTree</u>(T,alias less = "a &lt; b",bool allowDuplicates = false) if (is(typeof(binaryFun!(less)(T.init,T.init))));
</div></dt>
<dd>Implementation of a <a href="http://
google.com/search?btnI=I%27m+Feeling+Lucky&ie=UTF-8&oe=UTF-8&q=red-black tree">red-black tree</a> container.
<p></p>
All inserts, removes, searches, and any function in general has complexity
 of <i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">lg(n)</span><b></i>)</i></b>.
<p></p>


 To use a different comparison than <span class="d_inlinecode">"a &lt; b"</span>, pass a different operator string
 that can be used by <a href="std_functional.html#binaryFun"><span class="d_inlinecode">std.functional.binaryFun</span></a>, or pass in a
 function, delegate, functor, or any type where <span class="d_inlinecode">less(a, b)</span> results in a <span class="d_inlinecode">bool</span>
 value.
<p></p>


 Note that less should produce a strict ordering.  That is, for two unequal
 elements <span class="d_inlinecode">a</span> and <span class="d_inlinecode">b</span>, <span class="d_inlinecode">less(a, b) == !less(b, a)</span>. <span class="d_inlinecode">less(a, a)</span> should
 always equal <span class="d_inlinecode"><b>false</b></span>.
<p></p>


 If <span class="d_inlinecode">allowDuplicates</span> is set to <span class="d_inlinecode"><b>true</b></span>, then inserting the same element more than
 once continues to add more elements.  If it is <span class="d_inlinecode"><b>false</b></span>, duplicate elements are
 ignored on insertion.  If duplicates are allowed, then new elements are
 inserted after all existing duplicate elements.<p></p>

<dl><dt><div class="d_decl">alias <a name="Elem"></a><u>Elem</u>;
</div></dt>
<dd>Element type for the tree<p></p>

</dd>
<dt><div class="d_decl">struct <a name="Range"></a><u>Range</u>;
</div></dt>
<dd>The range type for <span class="d_inlinecode">RedBlackTree</span><p></p>

<dl><dt><div class="d_decl">const bool <a name="empty"></a><u>empty</u>();
</div></dt>
<dd>Returns <span class="d_inlinecode"><b>true</b></span> if the range is empty<p></p>

</dd>
<dt><div class="d_decl">Elem <a name="front"></a><u>front</u>();
</div></dt>
<dd>Returns the first element in the range<p></p>

</dd>
<dt><div class="d_decl">Elem <a name="back"></a><u>back</u>();
</div></dt>
<dd>Returns the last element in the range<p></p>

</dd>
<dt><div class="d_decl">void <a name="popFront"></a><u>popFront</u>();
</div></dt>
<dd>pop the front element from the range
<p></p>
<b>complexity:</b><br>
amortized <i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">1</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">void <a name="popBack"></a><u>popBack</u>();
</div></dt>
<dd>pop the back element from the range
<p></p>
<b>complexity:</b><br>
amortized <i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">1</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">Range <a name="save"></a><u>save</u>();
</div></dt>
<dd>Trivial save implementation, needed for <span class="d_inlinecode">isForwardRange</span>.<p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">bool <a name="empty"></a><u>empty</u>();
</div></dt>
<dd>Check if any elements exist in the container.  Returns <span class="d_inlinecode"><b>true</b></span> if at least
 one element exists.<p></p>

</dd>
<dt><div class="d_decl">size_t <a name="length"></a><u>length</u>();
</div></dt>
<dd>Returns the number of elements in the container.
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">1</span><b></i>)</i></b>.<p></p>

</dd>
<dt><div class="d_decl">RedBlackTree <a name="dup"></a><u>dup</u>();
</div></dt>
<dd>Duplicate this container.  The resulting container contains a shallow
 copy of the elements.
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">n</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">Range <a name="opSlice"></a><u>opSlice</u>();
</div></dt>
<dd>Fetch a range that spans all the elements in the container.
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">log(n)</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">Elem <a name="front"></a><u>front</u>();
</div></dt>
<dd>The <a name="front"></a><u>front</u> element in the container
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">log(n)</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">Elem <a name="back"></a><u>back</u>();
</div></dt>
<dd>The last element in the container
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">log(n)</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">bool <a name="opBinaryRight"></a><u>opBinaryRight</u>(string op)(Elem <i>e</i>);
</div></dt>
<dd><span class="d_inlinecode">in</span> operator. Check to see if the given element exists in the
        container.
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">log(n)</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">void <a name="clear"></a><u>clear</u>();
</div></dt>
<dd>Removes all elements from the container.
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">1</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">size_t <a name="stableInsert"></a><u>stableInsert</u>(Stuff)(Stuff <i>stuff</i>);
</div></dt>
<dd>Insert a single element in the container.  Note that this does not
 invalidate any ranges currently iterating the container.
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">log(n)</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">size_t <a name="stableInsert"></a><u>stableInsert</u>(Stuff)(Stuff <i>stuff</i>);
<br>alias <a name="insert"></a><u>insert</u>;
</div></dt>
<dd>Insert a range of elements in the container.  Note that this does not
 invalidate any ranges currently iterating the container.
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">m * log(n)</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">Elem <a name="removeAny"></a><u>removeAny</u>();
</div></dt>
<dd>Remove an element from the container and return its value.
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">log(n)</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">void <a name="removeFront"></a><u>removeFront</u>();
</div></dt>
<dd>Remove the front element from the container.
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">log(n)</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">void <a name="removeBack"></a><u>removeBack</u>();
</div></dt>
<dd>Remove the back element from the container.
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">log(n)</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">Range <a name="remove"></a><u>remove</u>(Range <i>r</i>);
</div></dt>
<dd>Removes the given range from the container.
<p></p>
<b>Returns:</b><br>A range containing all of the elements that were after the
                 given range.

<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">m * log(n)</span><b></i>)</i></b> (where m is the number of elements in
                    the range)<p></p>

</dd>
<dt><div class="d_decl">Range <a name="remove"></a><u>remove</u>(Take!(Range) <i>r</i>);
</div></dt>
<dd>Removes the given <span class="d_inlinecode">Take!Range</span> from the container
<p></p>
<b>Returns:</b><br>A range containing all of the elements that were after the
                 given range.

<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">m * log(n)</span><b></i>)</i></b> (where m is the number of elements in
                    the range)<p></p>

</dd>
<dt><div class="d_decl">size_t <a name="removeKey"></a><u>removeKey</u>(U)(U[] <i>elems</i>...);
<br>size_t <a name="removeKey"></a><u>removeKey</u>(Stuff)(Stuff <i>stuff</i>);
</div></dt>
<dd>Removes elements from the container that are equal to the given values
       according to the less comparator. One element is removed for each value
       given which is in the container. If <span class="d_inlinecode">allowDuplicates</span> is <b>true</b>,
       duplicates are removed only if duplicate values are given.
<p></p>
<b>Returns:</b><br>The number of elements removed.

<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">m log(n)</span><b></i>)</i></b> (where m is the number of elements to remove)

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> rbt = redBlackTree!<span class="d_keyword">true</span>(0, 1, 1, 1, 4, 5, 7);
rbt.<span class="d_psymbol">removeKey</span>(1, 4, 7);
<span class="d_keyword">assert</span>(std.algorithm.equal(rbt[], [0, 1, 1, 5]));
rbt.<span class="d_psymbol">removeKey</span>(1, 1, 0);
<span class="d_keyword">assert</span>(std.algorithm.equal(rbt[], [5]));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">Range <a name="upperBound"></a><u>upperBound</u>(Elem <i>e</i>);
</div></dt>
<dd>Get a range from the container with all elements that are &gt; <i>e</i> according
 to the less comparator
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">log(n)</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">Range <a name="lowerBound"></a><u>lowerBound</u>(Elem <i>e</i>);
</div></dt>
<dd>Get a range from the container with all elements that are &lt; <i>e</i> according
 to the less comparator
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">log(n)</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">Range <a name="equalRange"></a><u>equalRange</u>(Elem <i>e</i>);
</div></dt>
<dd>Get a range from the container with all elements that are == <i>e</i> according
 to the less comparator
<p></p>
<b>Complexity:</b><br>
<i><b>&Omicron;</i>(</i></b><span class="d_inlinecode">log(n)</span><b></i>)</i></b><p></p>

</dd>
<dt><div class="d_decl">auto this();
</div></dt>
<dd><p></p>

</dd>
<dt><div class="d_decl">auto this(Elem[] <i>elems</i>...);
</div></dt>
<dd>Constructor.  Pass in an array of elements, or individual elements to
       initialize the tree with.<p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">auto <a name="redBlackTree"></a><u>redBlackTree</u>(E)(E[] <i>elems</i>...);
<br>auto <a name="redBlackTree"></a><u>redBlackTree</u>(bool allowDuplicates, E)(E[] <i>elems</i>...);
<br>auto <a name="redBlackTree"></a><u>redBlackTree</u>(alias less, E)(E[] <i>elems</i>...);
<br>auto <a name="redBlackTree"></a><u>redBlackTree</u>(alias less, bool allowDuplicates, E)(E[] <i>elems</i>...);
</div></dt>
<dd>Convenience function for creating a <span class="d_inlinecode">RedBlackTree!E</span> from a list of
    values.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> rbt1 = <span class="d_psymbol">redBlackTree</span>(0, 1, 5, 7);
<span class="d_keyword">auto</span> rbt2 = <span class="d_psymbol">redBlackTree</span>!string(<span class="d_string">"hello"</span>, <span class="d_string">"world"</span>);
<span class="d_keyword">auto</span> rbt3 = <span class="d_psymbol">redBlackTree</span>!<span class="d_keyword">true</span>(0, 1, 5, 7, 5);
<span class="d_keyword">auto</span> rbt4 = <span class="d_psymbol">redBlackTree</span>!<span class="d_string">"a &gt; b"</span>(0, 1, 5, 7);
<span class="d_keyword">auto</span> rbt5 = <span class="d_psymbol">redBlackTree</span>!(<span class="d_string">"a &gt; b"</span>, <span class="d_keyword">true</span>)(0.1, 1.3, 5.9, 7.2, 5.9);
</pre>
<p></p>

</dd>
</dl>

    
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="6203743411";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
 
</div>


<div id="copyright">
Red-black tree code copyright (C) 2008- by Steven Schveighoffer. Other code
copyright 2010- Andrei Alexandrescu. All rights reserved by the respective holders.

 |
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

