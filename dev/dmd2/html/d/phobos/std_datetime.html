<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html>

<!--
	Copyright (c) 1999-2010 by Digital Mars
	All Rights Reserved Written by Walter Bright
	http://www.digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>std.datetime - D Programming Language - Digital Mars</title>
<link rel="stylesheet" type="text/css" href="../style.css">

<script>
function listanchors()
{
    var a = document.getElementById("quickindex");
    if (!a) return;
    var newText = "";
    var hash = new Array;
    var n = 0;
    var values = new Array;
    // List all anchors.
    for (var i = 0; i < document.anchors.length; i++)
    {
        var a = document.anchors[i];
        var text = a.name;
        if (hash[text] > 0) continue;
        hash[text] = 1;
    values[n++] = a.name
    }

    values.sort();

    for(var i = 0; i < values.length; i++) {
        var a = values[i];
        newText += '<a href="#' + a + '"><span class="d_psymbol">'
                + a + '</span></a> ';
    }
    if (newText != "") newText = "<p><b>Jump to:</b> " + newText + '</p>';
    var a = document.getElementById("quickindex");
    a.innerHTML = newText;
}
</script>

</head>

<body onload="listanchors()">
<div id="heading">
	<a href="http://www.digitalmars.com/"><img src="../dmlogo.gif" width="270" height="53" border="0" alt="www.digitalmars.com" align="left"></a>
	<p align="right">D Programming Language 2.0</p>


	<div id="headingNav">
	<ul>	<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/" title="Read/write comments and feedback">Comments</a></li>
	<li><a href="../index.html" title="D Programming Language" class="dlink">D</a></li>
	<li><a href="http://www.digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a></li>
	<li><a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a></li>
	</ul>
	</div>

	<div id="lastupdate">Last update Sun Jul 10 10:47:21 2011
</div>
</div>

<div id="navigation">
    
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input id="q" name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/d/2.0/phobos">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="../index.html" title="D Programming Language">D</a></li>
	<li><a href="../lex.html" title="D Language Specification">Language</a></li>
	<li><a href="phobos.html" title="D Runtime Library">Phobos</a></li>
	<li><a href="../comparison.html" title="Language Comparisons">Comparisons</a></li>
    </ul>
</div>
</div>

    
<div class="navblock">
    <ul>	<li><a href="object.html" title="root of object hierarchy">object</a></li>
    </ul>
    <h2><a href="phobos.html#std" title="D standard modules">std</a></h2>
    <ul>	<li><a href="std_algorithm.html" title="General-purpose algorithms">std.algorithm</a></li>
	<li><a href="std_array.html" title="Array functions">std.array</a></li>
	<li><a href="std_base64.html" title="Encode/decode base64 format">std.base64</a></li>
	<li><a href="std_bigint.html" title="Arbitrary-precision ('bignum') arithmetic">std.bigint</a></li>
	<li><a href="std_bind.html" title="Function argument binding">std.bind</a></li>
	<li><a href="std_bitmanip.html" title="Bit-level manipulation">std.bitmanip</a></li>
	<li><a href="std_boxer.html" title="Box/unbox types">std.boxer</a></li>
	<li><a href="std_compiler.html" title="Information about the D compiler implementation">std.compiler</a></li>
	<li><a href="std_complex.html" title="Complex numbers">std.complex</a></li>
	<li><a href="std_concurrency.html" title="Message Passing">std.concurrency</a></li>
	<li><a href="std_container.html" title="Containers">std.container</a></li>
	<li><a href="std_contracts.html" title="Think assert">std.contracts</a></li>
	<li><a href="std_conv.html" title="Conversion of strings to integers">std.conv</a></li>
	<li><a href="std_cover.html" title="D coverage analyzer">std.cover</a></li>
	<li><a href="std_cpuid.html" title="CPU identification">std.cpuid</a></li>
	<li><a href="std_ctype.html" title="Simple character classification">std.ctype</a></li>
	<li><a href="std_date.html" title="Date and time functions">std.date</a></li>
	<li><a href="std_datetime.html" title="Date and time-related types and functions">std.datetime</a></li>
	<li><a href="std_demangle.html" title="Demangle D names">std.demangle</a></li>
	<li><a href="std_encoding.html" title="Character and string encoding">std.encoding</a></li>
	<li><a href="std_exception.html" title="Exceptions and error handling">std.exception</a></li>
	<li><a href="std_file.html" title="Basic file operations">std.file</a></li>
	<li><a href="std_format.html" title="Formatted conversions of values to strings">std.format</a></li>
	<li><a href="std_functional.html" title="functional">std.functional</a></li>
	<li><a href="std_gc.html" title="Control the garbage collector">std.gc</a></li>
	<li><a href="std_getopt.html" title="Command line options">std.getopt</a></li>
	<li><a href="std_gregorian.html" title="Gregorian Calendar">std.gregorian</a></li>
	<li><a href="std_intrinsic.html" title="Compiler built in intrinsic functions">std.intrinsic</a></li>
	<li><a href="std_json.html" title="JSON reader">std.json</a></li>
	<li><a href="std_math.html" title="the usual math functions">std.math</a></li>
	<li><a href="std_mathspecial.html" title="mathematical special functions">std.mathspecial</a></li>
	<li><a href="std_md5.html" title="Compute MD5 digests">std.md5</a></li>
	<li><a href="std_metastrings.html" title="Metaprogramming with strings">std.metastrings</a></li>
	<li><a href="std_mmfile.html" title="Memory mapped files">std.mmfile</a></li>
	<li><a href="std_numeric.html" title="Numeric algorithms">std.numeric</a></li>
	<li><a href="std_outbuffer.html" title="Assemble data into an array of bytes">std.outbuffer</a></li>
	<li><a href="std_outofmemory.html" title="Out of memory exception">std.outofmemory</a></li>
	<li><a href="std_path.html" title="Manipulate file names, path names, etc.">std.path</a></li>
	<li><a href="std_parallelism.html" title="High level primitives for SMP parallelism">std.parallelism</a></li>
	<li><a href="std_process.html" title="Create/destroy threads">std.process</a></li>
	<li><a href="std_random.html" title="Random number generation">std.random</a></li>
	<li><a href="std_range.html" title="Ranges">std.range</a></li>
	<li><a href="std_regex.html" title="regular expressions">std.regex</a></li>
	<li><a href="std_regexp.html" title="regular expressions (deprecated)">std.regexp</a></li>
	<li><a href="std_signals.html" title="Signals">std.signals</a></li>
	<li><a href="std_socket.html" title="Sockets">std.socket</a></li>
	<li><a href="std_socketstream.html" title="Stream for a blocking, connected Socket">std.socketstream</a></li>
	<li><a href="std_stdint.html" title="Integral types for various purposes">std.stdint</a></li>
	<li><a href="std_stdio.html" title="Standard I/O">std.stdio</a></li>
	<li><a href="std_cstream.html" title="Stream I/O">std.cstream</a></li>
	<li><a href="std_stream.html" title="Stream I/O">std.stream</a></li>
	<li><a href="std_string.html" title="Basic string operations">std.string</a></li>
	<li><a href="std_system.html" title="Inquire about the CPU, operating system">std.system</a></li>
	<li><a href="std_thread.html" title="Thread operations">std.thread</a></li>
	<li><a href="std_traits.html" title="Type traits">std.traits</a></li>
	<li><a href="std_typecons.html" title="Type constructors">std.typecons</a></li>
	<li><a href="std_typetuple.html" title="Type tuples">std.typetuple</a></li>
	<li><a href="std_uni.html" title="Unicode classification">std.uni</a></li>
	<li><a href="std_uri.html" title="Encode and decode Uniform Resource Identifiers (URIs)">std.uri</a></li>
	<li><a href="std_utf.html" title="Encode and decode utf character encodings">std.utf</a></li>
	<li><a href="std_variant.html" title="Stores all types in a uniform, dynamically-checked representation">std.variant</a></li>
	<li><a href="std_xml.html" title="XML file processing">std.xml</a></li>
	<li><a href="std_zip.html" title="Read/write zip archives">std.zip</a></li>
	<li><a href="std_zlib.html" title="Compression / Decompression of data">std.zlib</a></li>
	<li><a href="std_c_fenv.html" title="Floating point environment">std.c.fenv</a></li>
	<li><a href="std_c_locale.html" title="Locale">std.c.locale</a></li>
	<li><a href="std_c_math.html" title="Math">std.c.math</a></li>
	<li><a href="std_c_process.html" title="Process">std.c.process</a></li>
	<li><a href="std_c_stdarg.html" title="Variadic arguments">std.c.stdarg</a></li>
	<li><a href="std_c_stddef.html" title="Standard definitions">std.c.stddef</a></li>
	<li><a href="std_c_stdio.html" title="Standard I/O">std.c.stdio</a></li>
	<li><a href="std_c_stdlib.html" title="Standard library">std.c.stdlib</a></li>
	<li><a href="std_c_string.html" title="Strings">std.c.string</a></li>
	<li><a href="std_c_time.html" title="Time">std.c.time</a></li>
	<li><a href="std_c_wcharh.html" title="Wide characters">std.c.wcharh</a></li>
	<li><a href="std_net_isemail.html" title="Validate email addresses">std.net.isemail</a></li>
	<li><a href="std_windows_charset.html" title="Conversion to/from Windows character sets">std.windows.charset</a></li>
	<li><a href="phobos.html#std_windows" title="Modules specific to Windows">std.windows</a></li>
	<li><a href="phobos.html#std_linux" title="Modules specific to Windows">std.linux</a></li>
	<li><a href="phobos.html#std_c_windows" title="C Windows API">std.c.windows</a></li>
	<li><a href="phobos.html#std_c_linux" title="C Linux API">std.c.linux</a></li>
    </ul>
    <h2><a href="phobos.html#etc" title="D etc modules">etc</a></h2>
    <ul>	<li><a href="etc_c_curl.html" title="Interface to libcurl library">etc.c.curl</a></li>
	<li><a href="etc_c_zlib.html" title="Interface to zlib library">etc.c.zlib</a></li>
    </ul>
    <h2><a href="phobos.html#core" title="D core modules">core</a></h2>
    <ul>	<li><a href="core_atomic.html" title="Atomic operations">core.atomic</a></li>
	<li><a href="core_bitop.html" title="Bitwise operations">core.bitop</a></li>
	<li><a href="core_cpuid.html" title="CPU identification">core.cpuid</a></li>
	<li><a href="core_exception.html" title="Root of exception hierarchy">core.exception</a></li>
	<li><a href="core_memory.html" title="Interface to memory management">core.memory</a></li>
	<li><a href="core_runtime.html" title="Interface to D runtime library internals">core.runtime</a></li>
	<li><a href="core_time.html" title="Time">core.time</a></li>
	<li><a href="core_thread.html" title="Thread management">core.thread</a></li>
	<li><a href="core_vararg.html" title="Variable function arguments">core.vararg</a></li>
	<li><a href="core_sync_barrier.html" title="Synchronizing progress of a group of threads">core.sync.barrier</a></li>
	<li><a href="core_sync_condition.html" title="Synchronized condition checking">core.sync.condition</a></li>
	<li><a href="core_sync_config.html" title="Stuff for core.sync">core.sync.config</a></li>
	<li><a href="core_sync_exception.html" title="SyncException">core.sync.exception</a></li>
	<li><a href="core_sync_mutex.html" title="Mutexes">core.sync.mutex</a></li>
	<li><a href="core_sync_rwmutex.html" title="R/W mutually exclusive access">core.sync.rwmutex</a></li>
	<li><a href="core_sync_semaphore.html" title="Semaphores">core.sync.semaphore</a></li>
    </ul>
</div>

</div>
<div id="content">
    <h1>std.datetime</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from std\datetime.d -->
Module containing Date/Time functionality.
<p></p>
This module provides:
    <ul>       <li>Types to represent points in time: <span class="d_inlinecode">SysTime</span>, <span class="d_inlinecode">Date</span>,
             <span class="d_inlinecode">TimeOfDay</span>, and <span class="d_inlinecode">DateTime</span>.</li>
        <li>Types to represent intervals of time.</li>
        <li>Types to represent ranges over intervals of time.</li>
        <li>Types to represent time zones (used by <span class="d_inlinecode">SysTime</span>).</li>
        <li>A platform-independent, high precision stopwatch type:
             <span class="d_inlinecode">StopWatch</span></li>
        <li>Benchmarking functions.</li>
        <li>Various helper functions.</li>
    </ul>
<p></p>


    Closely related to std.<a name="datetime"></a><u>datetime</u> is <a href="core_time.html"><span class="d_inlinecode">core.time</span></a>,
    and some of the time types used in std.<a name="datetime"></a><u>datetime</u> come from there - such as
    , , and
    . So, you may want to look at its documentation as
    well. However, core.time is publically imported into std.<a name="datetime"></a><u>datetime</u>, so you
    don't have to import it separately.
<p></p>


    Three of the main concepts used in this module are time points, time
    durations, and time intervals.
<p></p>


    A time point is a specific point in time. e.g. January 5th, 2010
    or 5:00.
<p></p>


    A time duration is a length of time with units. e.g. 5 days or 231 seconds.
<p></p>


    A time interval indicates a period of time associated with a fixed point in
    time. So, it is either two time points associated with each other,
    indicating the time starting at the first point up to, but not including,
    the second point - e.g. [January 5th, 2010 - March 10th, 2010) - or
    it is a time point and a time duration associated with one another. e.g.
    January 5th, 2010 and 5 days, indicating [January 5th, 2010 -
    January 10th, 2010).
<p></p>


    Various arithmetic operations are supported between time points and
    durations (e.g. the difference between two time points is a time duration),
    and ranges can be gotten from time intervals, so range-based operations may
    be done on a series of time points.
<p></p>


    The types that the typical user is most likely to be interested in are
    <span class="d_inlinecode">Date</span> (if they want dates but don't care about time), <span class="d_inlinecode">DateTime</span>
    (if they want dates and times but don't care about time zones), <span class="d_inlinecode">SysTime</span>
    (if they want the date and time from the OS and/or do care about time
    zones), and StopWatch (a platform-independent, high precision stop watch).
    <span class="d_inlinecode">Date</span> and <span class="d_inlinecode">DateTime</span> are optimized for calendar-based operations,
    while <span class="d_inlinecode">SysTime</span> is designed for dealing with time from the OS. Check out
    their specific documentation for more details.
<p></p>


    To get the current time, use <span class="d_inlinecode">Clock.currTime</span>. It will return the current
    time as a <span class="d_inlinecode">SysTime</span>. If you want to print it, <span class="d_inlinecode">toString</span> is
    sufficient, but if you use <span class="d_inlinecode">toISOString</span>, <span class="d_inlinecode">toISOExtString</span>, or
    <span class="d_inlinecode">toSimpleString</span>, you can use the corresponding <span class="d_inlinecode">fromISOString</span>,
    <span class="d_inlinecode">fromISOExtString</span>, or <span class="d_inlinecode">fromISOExtString</span> to create a
    <span class="d_inlinecode">SysTime</span> from the string.
<p></p>


<pre class="d_code"><span class="d_keyword">auto</span> currentTime = Clock.currTime();
<span class="d_keyword">auto</span> timeString = currentTime.toISOExtString();
<span class="d_keyword">auto</span> restoredTime = SysTime.fromISOExtString(timeString);
</pre>

    Various functions take a string (or strings) to represent a unit of time
    (e.g. <span class="d_inlinecode">convert!("days", "hours")(numDays)</span>). The valid strings to use
    with such functions are <span class="d_inlinecode">"years"</span>, <span class="d_inlinecode">"months"</span>, <span class="d_inlinecode">"weeks"</span>,
    <span class="d_inlinecode">"days"</span>, <span class="d_inlinecode">"hours"</span>, <span class="d_inlinecode">"minutes"</span>, <span class="d_inlinecode">"seconds"</span>,
    <span class="d_inlinecode">"msecs"</span> (milliseconds), <span class="d_inlinecode">"usecs"</span> (microseconds),
    <span class="d_inlinecode">"hnsecs"</span> (hecto-nanoseconds - i.e. 100 ns), or some subset thereof.
    There are a few functions in core.time which take <span class="d_inlinecode">"nsecs"</span>, but because
    nothing in std.<a name="datetime"></a><u>datetime</u> has precision greater than hnsecs, and very little
    in core.time does, no functions in std.<a name="datetime"></a><u>datetime</u> accept <span class="d_inlinecode">"nsecs"</span>. If
    you need help remembering which units are abbreviated and which aren't,
    notice that all units seconds and greater use their full names, and all
    sub-second units are abbreviated (since they'd be rather long if they
    weren't).
<p></p>


    If you're looking for the definitions of <span class="d_inlinecode">Duration</span>, <span class="d_inlinecode">TickDuration</span>,
    or <span class="d_inlinecode">FracSec</span>, they're in core.time.

<p></p>
<b>Note:</b><br>
<span class="d_inlinecode">DateTimeException</span> is an alias for core.time's <span class="d_inlinecode">TimeException</span>,
        so you don't need to worry about core.time functions and std.<a name="datetime"></a><u>datetime</u>
        functions throwing different exception types (except in the rare case
        that they throw something other than <span class="d_inlinecode">TimeException</span> or
        <span class="d_inlinecode">DateTimeException</span>).

<p></p>
<b>See Also:</b><br><a href="http://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a>
        <a href="http://en.wikipedia.org/wiki/Tz_database">Wikipedia entry on TZ Database</a>
        <a href="http://en.wikipedia.org/wiki/List_of_tz_database_time_zones">              List of Time Zones</a>

<p></p>
<b>License:</b><br><a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.
<p></p>
<b>Authors:</b><br>Jonathan M Davis and Kato Shoichi
<p></p>
<b>Source:</b><br>
<a href="https://github.com/D-Programming-Language/phobos/blob/master/std/datetime.d">std/datetime.d</a><p></p>

<dl><dt><div class="d_decl">enum <a name="Month"></a><u>Month</u>;
</div></dt>
<dd>Represents the 12 months of the Gregorian year (January is 1).<p></p>

<dl><dt><div class="d_decl"><a name="jan"></a><u>jan</u></div></dt>
<dd><p></p>

</dd>
<dt><div class="d_decl"><a name="feb"></a><u>feb</u></div></dt>
<dd><p></p>

</dd>
<dt><div class="d_decl"><a name="mar"></a><u>mar</u></div></dt>
<dd><p></p>

</dd>
<dt><div class="d_decl"><a name="apr"></a><u>apr</u></div></dt>
<dd><p></p>

</dd>
<dt><div class="d_decl"><a name="may"></a><u>may</u></div></dt>
<dd><p></p>

</dd>
<dt><div class="d_decl"><a name="jun"></a><u>jun</u></div></dt>
<dd><p></p>

</dd>
<dt><div class="d_decl"><a name="jul"></a><u>jul</u></div></dt>
<dd><p></p>

</dd>
<dt><div class="d_decl"><a name="aug"></a><u>aug</u></div></dt>
<dd><p></p>

</dd>
<dt><div class="d_decl"><a name="sep"></a><u>sep</u></div></dt>
<dd><p></p>

</dd>
<dt><div class="d_decl"><a name="oct"></a><u>oct</u></div></dt>
<dd><p></p>

</dd>
<dt><div class="d_decl"><a name="nov"></a><u>nov</u></div></dt>
<dd><p></p>

</dd>
<dt><div class="d_decl"><a name="dec"></a><u>dec</u></div></dt>
<dd><p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">enum <a name="DayOfWeek"></a><u>DayOfWeek</u>;
</div></dt>
<dd>Represents the 7 days of the Gregorian week (Sunday is 0).<p></p>

<dl><dt><div class="d_decl"><a name="sun"></a><u>sun</u></div></dt>
<dd><p></p>

</dd>
<dt><div class="d_decl"><a name="mon"></a><u>mon</u></div></dt>
<dd><p></p>

</dd>
<dt><div class="d_decl"><a name="tue"></a><u>tue</u></div></dt>
<dd><p></p>

</dd>
<dt><div class="d_decl"><a name="wed"></a><u>wed</u></div></dt>
<dd><p></p>

</dd>
<dt><div class="d_decl"><a name="thu"></a><u>thu</u></div></dt>
<dd><p></p>

</dd>
<dt><div class="d_decl"><a name="fri"></a><u>fri</u></div></dt>
<dd><p></p>

</dd>
<dt><div class="d_decl"><a name="sat"></a><u>sat</u></div></dt>
<dd><p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">enum <a name="AllowDayOverflow"></a><u>AllowDayOverflow</u>;
</div></dt>
<dd>In some date calculations, adding months or years can cause the date to fall
    on a day of the month which is not valid (e.g. February 29th 2001 or
    June 31st 2000). If overflow is allowed (as is the default), then the month
    will be incremented accordingly (so, February 29th 2001 would become
    March 1st 2001, and June 31st 2000 would become July 1st 2000). If overflow
    is not allowed, then the day will be adjusted to the last valid day in that
    month (so, February 29th 2001 would become February 28th 2001 and
    June 31st 2000 would become June 30th 2000).
<p></p>
<a name="AllowDayOverflow"></a><u>AllowDayOverflow</u> only applies to calculations involving months or years.<p></p>

<dl><dt><div class="d_decl"><a name="no"></a><u>no</u></div></dt>
<dd>No, don't allow day overflow.<p></p>

</dd>
<dt><div class="d_decl"><a name="yes"></a><u>yes</u></div></dt>
<dd>Yes, allow day overflow.<p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">enum <a name="Direction"></a><u>Direction</u>;
</div></dt>
<dd>Indicates a direction in time. One example of its use is <span class="d_inlinecode">Interval</span>'s
    <span class="d_inlinecode">expand</span> function which uses it to indicate whether the interval should
    be expanded backwards (into the past), forwards (into the future), or both.<p></p>

<dl><dt><div class="d_decl"><a name="bwd"></a><u>bwd</u></div></dt>
<dd>Backward.<p></p>

</dd>
<dt><div class="d_decl"><a name="fwd"></a><u>fwd</u></div></dt>
<dd>Forward.<p></p>

</dd>
<dt><div class="d_decl"><a name="both"></a><u>both</u></div></dt>
<dd>Both backward and forward.<p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">enum <a name="PopFirst"></a><u>PopFirst</u>;
</div></dt>
<dd>Used to indicate whether <span class="d_inlinecode">popFront</span> should be called immediately upon
    creating a range. The idea is that for some functions used to generate a
    range for an interval, <span class="d_inlinecode">front</span> is not necessarily a time point which
    would ever be generated by the range, and if you want the first time point
    in the range to match what the function generates, then you use
    <span class="d_inlinecode"><a name="PopFirst"></a><u>PopFirst</u>.yes</span> to indicate that the range should have <span class="d_inlinecode">popFront</span>
    called on it before the range is returned so that <span class="d_inlinecode">front</span> is a time point
    which the function would generate.
<p></p>
For instance, if the function used to generate a range of time points
    generated successive Easters (i.e. you're iterating over all of the Easters
    within the interval), the initial date probably isn't an Easter. By using
    <span class="d_inlinecode"><a name="PopFirst"></a><u>PopFirst</u>.yes</span>, you would be telling the function which returned the
    range that you wanted <span class="d_inlinecode">popFront</span> to be called so that front would then be
    an Easter - the next one generated by the function (which if you were
    iterating forward, would be the Easter following the original <span class="d_inlinecode">front</span>,
    while if you were iterating backward, it would be the Easter prior to the
    original <span class="d_inlinecode">front</span>). If <span class="d_inlinecode"><a name="PopFirst"></a><u>PopFirst</u>.no</span> were used, then <span class="d_inlinecode">front</span> would
    remain the original time point and it would not necessarily be a time point
    which would be generated by the range-generating function (which in many
    cases is exactly what you
    want - e.g. if you were iterating over every day starting at the beginning
    of the interval).<p></p>

<dl><dt><div class="d_decl"><a name="no"></a><u>no</u></div></dt>
<dd>No, don't call popFront() before returning the range.<p></p>

</dd>
<dt><div class="d_decl"><a name="yes"></a><u>yes</u></div></dt>
<dd>Yes, call popFront() before returning the range.<p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">enum <a name="AutoStart"></a><u>AutoStart</u>;
</div></dt>
<dd>Used by StopWatch to indicate whether it should start immediately upon
   construction.<p></p>

<dl><dt><div class="d_decl"><a name="no"></a><u>no</u></div></dt>
<dd>No, don't start the StopWatch when it is constructed.<p></p>

</dd>
<dt><div class="d_decl"><a name="yes"></a><u>yes</u></div></dt>
<dd>Yes, do start the StopWatch when it is constructed.<p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">immutable string[] <a name="timeStrings"></a><u>timeStrings</u>;
</div></dt>
<dd>Array of the strings representing time units, starting with the smallest
    unit and going to the largest. It does not include <span class="d_inlinecode">"nsecs"</span>.
<p></p>
Includes <span class="d_inlinecode">"hnsecs"</span> (hecto-nanoseconds (100 ns)),
   <span class="d_inlinecode">"usecs"</span> (microseconds), <span class="d_inlinecode">"msecs"</span> (milliseconds), <span class="d_inlinecode">"seconds"</span>,
   <span class="d_inlinecode">"minutes"</span>, <span class="d_inlinecode">"hours"</span>, <span class="d_inlinecode">"days"</span>, <span class="d_inlinecode">"weeks"</span>, <span class="d_inlinecode">"months"</span>, and
   <span class="d_inlinecode">"years"</span><p></p>

</dd>
<dt><div class="d_decl">alias <a name="DateTimeException"></a><u>DateTimeException</u>;
</div></dt>
<dd>Exception type used by std.datetime. It's an alias to TimeException, which
    is what core.time uses. So, you can catch either and not worry about which
    module it came from.<p></p>

</dd>
<dt><div class="d_decl">class <a name="Clock"></a><u>Clock</u>;
</div></dt>
<dd>Effectively a namespace to make it clear that the methods it contains are
    getting the time from the system clock. It cannot be instantiated.<p></p>

<dl><dt><div class="d_decl">static SysTime <a name="currTime"></a><u>currTime</u>(immutable TimeZone <i>tz</i> = LocalTime());
</div></dt>
<dd>Returns the current time in the given time zone.
<p></p>
<b>Throws:</b><br><span class="d_inlinecode">ErrnoException</span> (on Posix) or <span class="d_inlinecode">Exception</span> (on Windows)
            if it fails to get the time of day.<p></p>

</dd>
<dt><div class="d_decl">static @property @trusted long <a name="currStdTime"></a><u>currStdTime</u>();
</div></dt>
<dd>Returns the number of hnsecs since midnight, January 1st, 1 A.D. for the
        current time.
<p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if it fails to get the time.<p></p>

</dd>
<dt><div class="d_decl">static @property @safe TickDuration <a name="currSystemTick"></a><u>currSystemTick</u>();
</div></dt>
<dd>The current system tick. The number of ticks per second varies from
        system to system. <a name="currSystemTick"></a><u>currSystemTick</u> uses a monotonic clock, so it's
        intended for precision timing by comparing relative time values, not
        for getting the current system time.
<p></p>
<b>Warning:</b><br>
On some systems, the monotonic clock may stop counting when
            the computer goes to sleep or hibernates. So, the monotonic
            clock could be off if that occurs. This is known to happen
            on Mac OS X. It has not been tested whether it occurs on
            either Windows or Linux.

<p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if it fails to get the time.<p></p>

</dd>
<dt><div class="d_decl">static @property @safe TickDuration <a name="currAppTick"></a><u>currAppTick</u>();
</div></dt>
<dd>The current number of system ticks since the application started.
        The number of ticks per second varies from system to system.
        This uses a monotonic clock.
<p></p>
<b>Warning:</b><br>
On some systems, the monotonic clock may stop counting when
            the computer goes to sleep or hibernates. So, the monotonic
            clock could be off if that occurs. This is known to happen
            on Mac OS X. It has not been tested whether it occurs on
            either Windows or on Linux.

<p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if it fails to get the time.<p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">struct <a name="SysTime"></a><u>SysTime</u>;
</div></dt>
<dd><span class="d_inlinecode"><a name="SysTime"></a><u>SysTime</u></span> is the type used when you want to get the current time from the
    system or if you're doing anything that involves time zones. Unlike
    <span class="d_inlinecode">DateTime</span>, the time zone is an integral part of <span class="d_inlinecode"><a name="SysTime"></a><u>SysTime</u></span> (though if
    all you care about is local time, you can pretty much ignore time zones, and
    it will work, since it defaults to using the local time zone). It holds its
    internal time in std time (hnsecs since midnight, January 1st, 1 A.D. UTC),
    so it interfaces well with the system time. However, that means that, unlike
    <span class="d_inlinecode">DateTime</span>, it is not optimized for calendar-based operations, and
    getting individual units from it such as years or days is going to involve
    conversions and be less efficient.
<p></p>
Basically, if you care about calendar-based operations and don't
    necessarily care about time zones, then <span class="d_inlinecode">DateTime</span> would be the type to
    use. However, if what you care about is the system time, then <span class="d_inlinecode"><a name="SysTime"></a><u>SysTime</u></span>
    would be the type to use.
<p></p>


    <span class="d_inlinecode">Clock.currTime</span> will return the current time as a <span class="d_inlinecode"><a name="SysTime"></a><u>SysTime</u></span>. If you
    want to convert a <span class="d_inlinecode"><a name="SysTime"></a><u>SysTime</u></span> to a <span class="d_inlinecode">Date</span> or <span class="d_inlinecode">DateTime</span>, simply cast
    it. And if you ever want to convert a <span class="d_inlinecode">Date</span> or <span class="d_inlinecode">DateTime</span> to a
    <span class="d_inlinecode"><a name="SysTime"></a><u>SysTime</u></span>, use <span class="d_inlinecode"><a name="SysTime"></a><u>SysTime</u></span>'s constructor, and you can pass in the
    intended time zone with it (or don't pass in a <span class="d_inlinecode">TimeZone</span>, and the local
    time zone will be used). Be aware, however, that converting from a
    <span class="d_inlinecode">DateTime</span> to a <span class="d_inlinecode"><a name="SysTime"></a><u>SysTime</u></span> will not necessarily be 100% accurate due to
    DST (one hour of the year doesn't exist and another occurs twice). So, if
    you don't want to risk any conversion errors, keep your times as
    <span class="d_inlinecode"><a name="SysTime"></a><u>SysTime</u></span>s. Aside from DST though, there shouldn't be any conversion
    problems.
<p></p>


    If you care about using time zones other than local time or UTC, you can use
    <span class="d_inlinecode">PosixTimeZone</span> on Posix systems (or on Windows, if you provide the TZ
    Database files), and you can use <span class="d_inlinecode">WindowsTimeZone</span> on Windows systems.
    The time in <span class="d_inlinecode"><a name="SysTime"></a><u>SysTime</u></span> is kept internally in hnsecs from midnight,
    January 1st, 1 A.D. UTC. So, you never get conversion errors when changing
    the time zone of a <span class="d_inlinecode"><a name="SysTime"></a><u>SysTime</u></span>. <span class="d_inlinecode">LocalTime</span> is the <span class="d_inlinecode">TimeZone</span> class
    which represents the local time, and <span class="d_inlinecode">UTC</span> is the <span class="d_inlinecode">TimeZone</span> class
    which represents UTC. <span class="d_inlinecode"><a name="SysTime"></a><u>SysTime</u></span> uses <span class="d_inlinecode">LocalTime</span> if no <span class="d_inlinecode">TimeZone</span>
    is provided. For more details on time zones, look at the documentation for
    <span class="d_inlinecode">TimeZone</span>, <span class="d_inlinecode">PosixTimeZone</span>, and <span class="d_inlinecode">WindowsTimeZone</span>.
<p></p>


    <span class="d_inlinecode"><a name="SysTime"></a><u>SysTime</u></span>'s range is from approximately 29,000 B.C. to approximately
    29,000 A.D.<p></p>

<dl><dt><div class="d_decl">nothrow  this(in DateTime <i>dateTime</i>, immutable TimeZone <i>tz</i> = null);
</div></dt>
<dd><b>Parameters:</b><table class=parms><tr><td valign=top>DateTime <i>dateTime</i></td>
<td valign=top>The <span class="d_inlinecode">DateTime</span> to use to set this <span class="d_inlinecode">SysTime</span>'s
                       internal std time. As <span class="d_inlinecode">DateTime</span> has no concept of
                       time zone, <i>tz</i> is used as its time zone.</td></tr>
<tr><td valign=top>TimeZone <i>tz</i></td>
<td valign=top>The <span class="d_inlinecode">TimeZone</span> to use for this <span class="d_inlinecode">SysTime</span>. If <b>null</b>,
                       <span class="d_inlinecode">LocalTime</span> will be used. The given <span class="d_inlinecode">DateTime</span> is
                       assumed to be in the given time zone.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">nothrow  this(in DateTime <i>dateTime</i>, in FracSec <i>fsec</i>, immutable TimeZone <i>tz</i> = null);
</div></dt>
<dd><b>Parameters:</b><table class=parms><tr><td valign=top>DateTime <i>dateTime</i></td>
<td valign=top>The <span class="d_inlinecode">DateTime</span> to use to set this <span class="d_inlinecode">SysTime</span>'s
                       internal std time. As <span class="d_inlinecode">DateTime</span> has no concept of
                       time zone, <i>tz</i> is used as its time zone.</td></tr>
<tr><td valign=top>FracSec <i>fsec</i></td>
<td valign=top>The fractional seconds portion of the time.</td></tr>
<tr><td valign=top>TimeZone <i>tz</i></td>
<td valign=top>The <span class="d_inlinecode">TimeZone</span> to use for this <span class="d_inlinecode">SysTime</span>. If <b>null</b>,
                       <span class="d_inlinecode">LocalTime</span> will be used. The given <span class="d_inlinecode">DateTime</span> is
                       assumed to be in the given time zone.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">nothrow  this(in Date <i>date</i>, immutable TimeZone <i>tz</i> = null);
</div></dt>
<dd><b>Parameters:</b><table class=parms><tr><td valign=top>Date <i>date</i></td>
<td valign=top>The <span class="d_inlinecode">Date</span> to use to set this <span class="d_inlinecode">SysTime</span>'s internal std
                   time. As <span class="d_inlinecode">Date</span> has no concept of time zone, <i>tz</i> is used as
                   its time zone.</td></tr>
<tr><td valign=top>TimeZone <i>tz</i></td>
<td valign=top>The <span class="d_inlinecode">TimeZone</span> to use for this <span class="d_inlinecode">SysTime</span>. If <b>null</b>,
                   <span class="d_inlinecode">LocalTime</span> will be used. The given <span class="d_inlinecode">Date</span> is assumed
                   to be in the given time zone.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">pure nothrow  this(long <i>stdTime</i>, immutable TimeZone <i>tz</i> = null);
</div></dt>
<dd><b>Note:</b><br>
Whereas the other constructors take in the given date/time, assume
            that it's in the given time zone, and convert it to hnsecs in UTC
            since midnight, January 1st, 1 A.D. UTC - i.e. std time - this
            constructor takes a std time, which is specifically already in UTC,
            so no conversion takes place. Of course, the various getter
            properties and functions will use the given time zone's conversion
            function to convert the results to that time zone, but no conversion
            of the arguments to this constructor takes place.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>long <i>stdTime</i></td>
<td valign=top>The number of hnsecs since midnight, January 1st, 1 A.D. UTC.</td></tr>
<tr><td valign=top>TimeZone <i>tz</i></td>
<td valign=top>The <span class="d_inlinecode">TimeZone</span> to use for this <span class="d_inlinecode">SysTime</span>. If <b>null</b>,
                      <span class="d_inlinecode">LocalTime</span> will be used.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">pure nothrow ref SysTime <a name="opAssign"></a><u>opAssign</u>(ref const SysTime <i>rhs</i>);
</div></dt>
<dd><b>Parameters:</b><table class=parms><tr><td valign=top>SysTime <i>rhs</i></td>
<td valign=top>The <span class="d_inlinecode">SysTime</span> to assign to this one.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">pure nothrow ref SysTime <a name="opAssign"></a><u>opAssign</u>(SysTime <i>rhs</i>);
</div></dt>
<dd><b>Parameters:</b><table class=parms><tr><td valign=top>SysTime <i>rhs</i></td>
<td valign=top>The <span class="d_inlinecode">SysTime</span> to assign to this one.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">const pure nothrow bool <a name="opEquals"></a><u>opEquals</u>(ref const SysTime <i>rhs</i>);
</div></dt>
<dd>Checks for equality between this <span class="d_inlinecode">SysTime</span> and the given
        <span class="d_inlinecode">SysTime</span>.
<p></p>
Note that the time zone is ignored. Only the internal
        std times (which are in UTC) are compared.<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow int <a name="opCmp"></a><u>opCmp</u>(in SysTime <i>rhs</i>);
</div></dt>
<dd>Compares this <span class="d_inlinecode">SysTime</span> with the given <span class="d_inlinecode">SysTime</span>.
<p></p>
Time zone is irrelevant when comparing <span class="d_inlinecode">SysTime</span>s.

<p></p>
<b>Returns:</b><br><table cellspacing=0 cellpadding=5><caption>           <tr><td valign=top>this &lt; <i>rhs</i></td> <td valign=top>&lt; 0</td></tr>
            <tr><td valign=top>this == <i>rhs</i></td> <td valign=top>0</td></tr>
            <tr><td valign=top>this &gt; <i>rhs</i></td> <td valign=top>&gt; 0</td></tr>
            </caption>           <tr><td valign=top>this &lt; <i>rhs</i></td> <td valign=top>&lt; 0</td></tr>
            <tr><td valign=top>this == <i>rhs</i></td> <td valign=top>0</td></tr>
            <tr><td valign=top>this &gt; <i>rhs</i></td> <td valign=top>&gt; 0</td></tr>
            </table><p></p>

</dd>
<dt><div class="d_decl">const nothrow @property short <a name="year"></a><u>year</u>();
</div></dt>
<dd>Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive
        are B.C.<p></p>

</dd>
<dt><div class="d_decl">@property void <a name="year"></a><u>year</u>(int <a name="year"></a><u>year</u>);
</div></dt>
<dd>Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive
        are B.C.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>int <a name="year"></a><u>year</u></td>
<td valign=top>The <a name="year"></a><u>year</u> to set this <span class="d_inlinecode">SysTime</span>'s <a name="year"></a><u>year</u> to.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the new <a name="year"></a><u>year</u> is not a leap <a name="year"></a><u>year</u> and the
            resulting date would be on February 29th.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(SysTime(DateTime(1999, 7, 6, 9, 7, 5)).<span class="d_psymbol">year</span> == 1999);
<span class="d_keyword">assert</span>(SysTime(DateTime(2010, 10, 4, 0, 0, 30)).<span class="d_psymbol">year</span> == 2010);
<span class="d_keyword">assert</span>(SysTime(DateTime(-7, 4, 5, 7, 45, 2)).<span class="d_psymbol">year</span> == -7);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const @property ushort <a name="yearBC"></a><u>yearBC</u>();
</div></dt>
<dd>Year B.C. of the Gregorian Calendar counting year 0 as 1 B.C.
<p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if <span class="d_inlinecode">isAD</span> is <b>true</b>.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(SysTime(DateTime(0, 1, 1, 12, 30, 33)).<span class="d_psymbol">yearBC</span> == 1);
<span class="d_keyword">assert</span>(SysTime(DateTime(-1, 1, 1, 10, 7, 2)).<span class="d_psymbol">yearBC</span> == 2);
<span class="d_keyword">assert</span>(SysTime(DateTime(-100, 1, 1, 4, 59, 0)).<span class="d_psymbol">yearBC</span> == 101);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">@property void <a name="yearBC"></a><u>yearBC</u>(int <i>year</i>);
</div></dt>
<dd>Year B.C. of the Gregorian Calendar counting <i>year</i> 0 as 1 B.C.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>int <i>year</i></td>
<td valign=top>The <i>year</i> B.C. to set this <span class="d_inlinecode">SysTime</span>'s <i>year</i> to.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if a non-positive value is given.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> st = SysTime(DateTime(2010, 1, 1, 7, 30, 0));
st.<span class="d_psymbol">yearBC</span> = 1;
<span class="d_keyword">assert</span>(st == SysTime(DateTime(0, 1, 1, 7, 30, 0)));

st.<span class="d_psymbol">yearBC</span> = 10;
<span class="d_keyword">assert</span>(st == SysTime(DateTime(-9, 1, 1, 7, 30, 0)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const nothrow @property Month <a name="month"></a><u>month</u>();
</div></dt>
<dd>Month of a Gregorian Year.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(SysTime(DateTime(1999, 7, 6, 9, 7, 5)).<span class="d_psymbol">month</span> == 7);
<span class="d_keyword">assert</span>(SysTime(DateTime(2010, 10, 4, 0, 0, 30)).<span class="d_psymbol">month</span> == 10);
<span class="d_keyword">assert</span>(SysTime(DateTime(-7, 4, 5, 7, 45, 2)).<span class="d_psymbol">month</span> == 4);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">@property void <a name="month"></a><u>month</u>(Month <a name="month"></a><u>month</u>);
</div></dt>
<dd>Month of a Gregorian Year.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Month <a name="month"></a><u>month</u></td>
<td valign=top>The <a name="month"></a><u>month</u> to set this <span class="d_inlinecode">SysTime</span>'s <a name="month"></a><u>month</u> to.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given <a name="month"></a><u>month</u> is not a valid <a name="month"></a><u>month</u>.<p></p>

</dd>
<dt><div class="d_decl">const nothrow @property ubyte <a name="day"></a><u>day</u>();
</div></dt>
<dd>Day of a Gregorian Month.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(SysTime(DateTime(1999, 7, 6, 9, 7, 5)).<span class="d_psymbol">day</span> == 6);
<span class="d_keyword">assert</span>(SysTime(DateTime(2010, 10, 4, 0, 0, 30)).<span class="d_psymbol">day</span> == 4);
<span class="d_keyword">assert</span>(SysTime(DateTime(-7, 4, 5, 7, 45, 2)).<span class="d_psymbol">day</span> == 5);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">@property void <a name="day"></a><u>day</u>(int <a name="day"></a><u>day</u>);
</div></dt>
<dd>Day of a Gregorian Month.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>int <a name="day"></a><u>day</u></td>
<td valign=top>The <a name="day"></a><u>day</u> of the month to set this <span class="d_inlinecode">SysTime</span>'s <a name="day"></a><u>day</u> to.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given <a name="day"></a><u>day</u> is not a valid <a name="day"></a><u>day</u> of the
            current month.<p></p>

</dd>
<dt><div class="d_decl">const nothrow @property ubyte <a name="hour"></a><u>hour</u>();
</div></dt>
<dd>Hours past midnight.<p></p>

</dd>
<dt><div class="d_decl">@property void <a name="hour"></a><u>hour</u>(int <a name="hour"></a><u>hour</u>);
</div></dt>
<dd>Hours past midnight.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>int <a name="hour"></a><u>hour</u></td>
<td valign=top>The hours to set this <span class="d_inlinecode">SysTime</span>'s <a name="hour"></a><u>hour</u> to.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given <a name="hour"></a><u>hour</u> are not a valid <a name="hour"></a><u>hour</u> of
            the day.<p></p>

</dd>
<dt><div class="d_decl">const nothrow @property ubyte <a name="minute"></a><u>minute</u>();
</div></dt>
<dd>Minutes past the current hour.<p></p>

</dd>
<dt><div class="d_decl">@property void <a name="minute"></a><u>minute</u>(int <a name="minute"></a><u>minute</u>);
</div></dt>
<dd>Minutes past the current hour.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>minutes</td>
<td valign=top>The <a name="minute"></a><u>minute</u> to set this <span class="d_inlinecode">SysTime</span>'s <a name="minute"></a><u>minute</u> to.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given <a name="minute"></a><u>minute</u> are not a valid <a name="minute"></a><u>minute</u>
            of an hour.<p></p>

</dd>
<dt><div class="d_decl">const nothrow @property ubyte <a name="second"></a><u>second</u>();
</div></dt>
<dd>Seconds past the current minute.<p></p>

</dd>
<dt><div class="d_decl">@property void <a name="second"></a><u>second</u>(int <a name="second"></a><u>second</u>);
</div></dt>
<dd>Seconds past the current minute.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>int <a name="second"></a><u>second</u></td>
<td valign=top>The <a name="second"></a><u>second</u> to set this <span class="d_inlinecode">SysTime</span>'s <a name="second"></a><u>second</u> to.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given <a name="second"></a><u>second</u> are not a valid <a name="second"></a><u>second</u>
            of a minute.<p></p>

</dd>
<dt><div class="d_decl">const nothrow @property FracSec <a name="fracSec"></a><u>fracSec</u>();
</div></dt>
<dd>Fractional seconds passed the second.<p></p>

</dd>
<dt><div class="d_decl">nothrow @property void <a name="fracSec"></a><u>fracSec</u>(FracSec <a name="fracSec"></a><u>fracSec</u>);
</div></dt>
<dd>Fractional seconds passed the second.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>FracSec <a name="fracSec"></a><u>fracSec</u></td>
<td valign=top>The fractional seconds to set this <span class="d_inlinecode">SysTimes</span>'s
                      fractional seconds to.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property long <a name="stdTime"></a><u>stdTime</u>();
</div></dt>
<dd>The total hnsecs from midnight, January 1st, 1 A.D. UTC. This is the
        internal representation of <span class="d_inlinecode">SysTime</span>.<p></p>

</dd>
<dt><div class="d_decl">pure nothrow @property void <a name="stdTime"></a><u>stdTime</u>(long <a name="stdTime"></a><u>stdTime</u>);
</div></dt>
<dd>The total hnsecs from midnight, January 1st, 1 A.D. UTC. This is the
        internal representation of <span class="d_inlinecode">SysTime</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>long <a name="stdTime"></a><u>stdTime</u></td>
<td valign=top>The number of hnsecs since January 1st, 1 A.D. UTC.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property immutable(TimeZone) <a name="timezone"></a><u>timezone</u>();
</div></dt>
<dd>The current time zone of this <span class="d_inlinecode">SysTime</span>. Its internal time is always
        kept in UTC, so there are no conversion issues between time zones due to
        DST. Functions which return all or part of the time - such as hours -
        adjust the time to this <span class="d_inlinecode">SysTime</span>'s time zone before returning.<p></p>

</dd>
<dt><div class="d_decl">pure nothrow @property void <a name="timezone"></a><u>timezone</u>(immutable TimeZone <a name="timezone"></a><u>timezone</u>);
</div></dt>
<dd>The current time zone of this <span class="d_inlinecode">SysTime</span>. It's internal time is always
        kept in UTC, so there are no conversion issues between time zones due to
        DST. Functions which return all or part of the time - such as hours -
        adjust the time to this <span class="d_inlinecode">SysTime</span>'s time zone before returning.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>tz</td>
<td valign=top>The <span class="d_inlinecode">TimeZone</span> to set this <span class="d_inlinecode">SysTime</span>'s time zone to.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">const nothrow @property bool <a name="dstInEffect"></a><u>dstInEffect</u>();
</div></dt>
<dd>Returns whether DST is in effect for this <span class="d_inlinecode">SysTime</span>.<p></p>

</dd>
<dt><div class="d_decl">const nothrow SysTime <a name="toLocalTime"></a><u>toLocalTime</u>();
</div></dt>
<dd>Returns a <span class="d_inlinecode">SysTime</span> with the same std time as this one, but with
        <span class="d_inlinecode">LocalTime</span> as its time zone.<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow SysTime <a name="toUTC"></a><u>toUTC</u>();
</div></dt>
<dd>Returns a <span class="d_inlinecode">SysTime</span> with the same std time as this one, but with
        <span class="d_inlinecode">UTC</span> as its time zone.<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow SysTime <a name="toOtherTZ"></a><u>toOtherTZ</u>(immutable TimeZone <i>tz</i>);
</div></dt>
<dd>Returns a <span class="d_inlinecode">SysTime</span> with the same std time as this one, but with
        given time zone as its time zone.<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow time_t <a name="toUnixTime"></a><u>toUnixTime</u>();
</div></dt>
<dd>Returns a <span class="d_inlinecode">time_t</span> which represents the same time as this
        <span class="d_inlinecode">SysTime</span>.
<p></p>
Note that like all conversions in std.datetime, this is a truncating
        conversion.
<p></p>


        If <span class="d_inlinecode">time_t</span> is 32 bits, rather than 64, and the result can't fit in a
        32-bit value, then the closest value that can be held in 32 bits will be
        used (so <span class="d_inlinecode">time_t.max</span> if it goes over and <span class="d_inlinecode">time_t.min</span> if it goes
        under).<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow timeval <a name="toTimeVal"></a><u>toTimeVal</u>();
</div></dt>
<dd>Returns a <span class="d_inlinecode">timeval</span> which represents this <span class="d_inlinecode">SysTime</span>.
<p></p>
Note that like all conversions in std.datetime, this is a truncating
        conversion.
<p></p>


        If <span class="d_inlinecode">time_t</span> is 32 bits, rather than 64, and the result can't fit in a
        32-bit value, then the closest value that can be held in 32 bits will be
        used for <span class="d_inlinecode">tv_sec</span>. (so <span class="d_inlinecode">time_t.max</span> if it goes over and
        <span class="d_inlinecode">time_t.min</span> if it goes under).<p></p>

</dd>
<dt><div class="d_decl">const nothrow tm <a name="toTM"></a><u>toTM</u>();
</div></dt>
<dd>Returns a <span class="d_inlinecode">tm</span> which represents this <span class="d_inlinecode">SysTime</span>.<p></p>

</dd>
<dt><div class="d_decl">nothrow SysTime <a name="add"></a><u>add</u>(string units)(long <i>value</i>, AllowDayOverflow <i>allowOverflow</i> = AllowDayOverflow.yes);
</div></dt>
<dd>Adds the given number of years or months to this <span class="d_inlinecode">SysTime</span>. A
        negative number will subtract.
<p></p>
Note that if day overflow is allowed, and the date with the adjusted
        year/month overflows the number of days in the new month, then the month
        will be incremented by one, and the day set to the number of days
        overflowed. (e.g. if the day were 31 and the new month were June, then
        the month would be incremented to July, and the new day would be 1). If
        day overflow is not allowed, then the day will be set to the last valid
        day in the month (e.g. June 31st would become June 30th).

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>units</td>
<td valign=top>The type of units to <a name="add"></a><u>add</u> ("years" or "months").</td></tr>
<tr><td valign=top>value</td>
<td valign=top>The number of months or years to <a name="add"></a><u>add</u> to this
                            <span class="d_inlinecode">SysTime</span>.</td></tr>
<tr><td valign=top>allowOverflow</td>
<td valign=top>Whether the days should be allowed to overflow,
                            causing the month to increment.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> st1 = SysTime(DateTime(2010, 1, 1, 12, 30, 33));
st1.<span class="d_psymbol">add</span>!<span class="d_string">"months"</span>(11);
<span class="d_keyword">assert</span>(st1 == SysTime(DateTime(2010, 12, 1, 12, 30, 33)));

<span class="d_keyword">auto</span> st2 = SysTime(DateTime(2010, 1, 1, 12, 30, 33));
st2.<span class="d_psymbol">add</span>!<span class="d_string">"months"</span>(-11);
<span class="d_keyword">assert</span>(st2 == SysTime(DateTime(2009, 2, 1, 12, 30, 33)));

<span class="d_keyword">auto</span> st3 = SysTime(DateTime(2000, 2, 29, 12, 30, 33));
st3.<span class="d_psymbol">add</span>!<span class="d_string">"years"</span>(1);
<span class="d_keyword">assert</span>(st3 == SysTime(DateTime(2001, 3, 1, 12, 30, 33)));

<span class="d_keyword">auto</span> st4 = SysTime(DateTime(2000, 2, 29, 12, 30, 33));
st4.<span class="d_psymbol">add</span>!<span class="d_string">"years"</span>(1, AllowDayOverflow.no);
<span class="d_keyword">assert</span>(st4 == SysTime(DateTime(2001, 2, 28, 12, 30, 33)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">nothrow void <a name="roll"></a><u>roll</u>(string units)(long <i>value</i>, AllowDayOverflow <i>allowOverflow</i> = AllowDayOverflow.yes);
</div></dt>
<dd>Adds the given number of years or months to this <span class="d_inlinecode">SysTime</span>. A
        negative number will subtract.
<p></p>
The difference between rolling and adding is that rolling does not
        affect larger units. So, if you <a name="roll"></a><u>roll</u> a <span class="d_inlinecode">SysTime</span> 12 months, you
        get the exact same <span class="d_inlinecode">SysTime</span>. However, the days can still be affected
        due to the differing number of days in each month.
<p></p>


        Because there are no units larger than years, there is no difference
        between adding and rolling years.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>units</td>
<td valign=top>The type of units to add ("years" or "months").</td></tr>
<tr><td valign=top>value</td>
<td valign=top>The number of months or years to add to this
                            <span class="d_inlinecode">SysTime</span>.</td></tr>
<tr><td valign=top>allowOverflow</td>
<td valign=top>Whether the days should be allowed to overflow,
                            causing the month to increment.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> st1 = SysTime(DateTime(2010, 1, 1, 12, 33, 33));
st1.<span class="d_psymbol">roll</span>!<span class="d_string">"months"</span>(1);
<span class="d_keyword">assert</span>(st1 == SysTime(DateTime(2010, 2, 1, 12, 33, 33)));

<span class="d_keyword">auto</span> st2 = SysTime(DateTime(2010, 1, 1, 12, 33, 33));
st2.<span class="d_psymbol">roll</span>!<span class="d_string">"months"</span>(-1);
<span class="d_keyword">assert</span>(st2 == SysTime(DateTime(2010, 12, 1, 12, 33, 33)));

<span class="d_keyword">auto</span> st3 = SysTime(DateTime(1999, 1, 29, 12, 33, 33));
st3.<span class="d_psymbol">roll</span>!<span class="d_string">"months"</span>(1);
<span class="d_keyword">assert</span>(st3 == SysTime(DateTime(1999, 3, 1, 12, 33, 33)));

<span class="d_keyword">auto</span> st4 = SysTime(DateTime(1999, 1, 29, 12, 33, 33));
st4.<span class="d_psymbol">roll</span>!<span class="d_string">"months"</span>(1, AllowDayOverflow.no);
<span class="d_keyword">assert</span>(st4 == SysTime(DateTime(1999, 2, 28, 12, 33, 33)));

<span class="d_keyword">auto</span> st5 = SysTime(DateTime(2000, 2, 29, 12, 30, 33));
st5.<span class="d_psymbol">roll</span>!<span class="d_string">"years"</span>(1);
<span class="d_keyword">assert</span>(st5 == SysTime(DateTime(2001, 3, 1, 12, 30, 33)));

<span class="d_keyword">auto</span> st6 = SysTime(DateTime(2000, 2, 29, 12, 30, 33));
st6.<span class="d_psymbol">roll</span>!<span class="d_string">"years"</span>(1, AllowDayOverflow.no);
<span class="d_keyword">assert</span>(st6 == SysTime(DateTime(2001, 2, 28, 12, 30, 33)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">nothrow void <a name="roll"></a><u>roll</u>(string units)(long <i>value</i>);
</div></dt>
<dd>Adds the given number of units to this <span class="d_inlinecode">SysTime</span>. A negative number
        will subtract.
<p></p>
The difference between rolling and adding is that rolling does not
        affect larger units. So, for instance, if you <a name="roll"></a><u>roll</u> a <span class="d_inlinecode">SysTime</span> one
        year's worth of days, then you get the exact same <span class="d_inlinecode">SysTime</span>.
<p></p>


        Accepted units are <span class="d_inlinecode">"days"</span>, <span class="d_inlinecode">"minutes"</span>, <span class="d_inlinecode">"hours"</span>,
        <span class="d_inlinecode">"minutes"</span>, <span class="d_inlinecode">"seconds"</span>, <span class="d_inlinecode">"msecs"</span>, <span class="d_inlinecode">"usecs"</span>, and
        <span class="d_inlinecode">"hnsecs"</span>.
<p></p>


        Note that when rolling msecs, usecs or hnsecs, they all add up to a
        second. So, for example, rolling 1000 msecs is exactly the same as
        rolling 100,000 usecs.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>units</td>
<td valign=top>The units to add.</td></tr>
<tr><td valign=top>value</td>
<td valign=top>The number of <span class="d_param">units</span> to add to this <span class="d_inlinecode">SysTime</span>.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> st1 = SysTime(DateTime(2010, 1, 1, 11, 23, 12));
st1.<span class="d_psymbol">roll</span>!<span class="d_string">"days"</span>(1);
<span class="d_keyword">assert</span>(st1 == SysTime(DateTime(2010, 1, 2, 11, 23, 12)));
st1.<span class="d_psymbol">roll</span>!<span class="d_string">"days"</span>(365);
<span class="d_keyword">assert</span>(st1 == SysTime(DateTime(2010, 1, 26, 11, 23, 12)));
st1.<span class="d_psymbol">roll</span>!<span class="d_string">"days"</span>(-32);
<span class="d_keyword">assert</span>(st1 == SysTime(DateTime(2010, 1, 25, 11, 23, 12)));

<span class="d_keyword">auto</span> st2 = SysTime(DateTime(2010, 7, 4, 12, 0, 0));
st2.<span class="d_psymbol">roll</span>!<span class="d_string">"hours"</span>(1);
<span class="d_keyword">assert</span>(st2 == SysTime(DateTime(2010, 7, 4, 13, 0, 0)));

<span class="d_keyword">auto</span> st3 = SysTime(DateTime(2010, 1, 1, 0, 0, 0));
st3.<span class="d_psymbol">roll</span>!<span class="d_string">"seconds"</span>(-1);
<span class="d_keyword">assert</span>(st3 == SysTime(DateTime(2010, 1, 1, 0, 0, 59)));

<span class="d_keyword">auto</span> st4 = SysTime(DateTime(2010, 1, 1, 0, 0, 0),
                   FracSec.from!<span class="d_string">"usecs"</span>(2_400));
st4.<span class="d_psymbol">roll</span>!<span class="d_string">"usecs"</span>(-1_200_000);
<span class="d_keyword">assert</span>(st4 == SysTime(DateTime(2010, 1, 1, 0, 0, 0),
                      FracSec.from!<span class="d_string">"usecs"</span>(802_400)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow SysTime <a name="opBinary"></a><u>opBinary</u>(string op, D)(in D <i>duration</i>);
</div></dt>
<dd>Gives the result of adding or subtracting a duration from this
        <span class="d_inlinecode">SysTime</span>.
<p></p>
The legal types of arithmetic for <span class="d_inlinecode">SysTime</span> using this operator are
<p></p>


        <table cellspacing=0 cellpadding=5><caption>       <tr><td valign=top>SysTime</td> <td valign=top>+</td> <td valign=top>duration</td> <td valign=top>--&gt;</td> <td valign=top>SysTime</td></tr>
        <tr><td valign=top>SysTime</td> <td valign=top>-</td> <td valign=top>duration</td> <td valign=top>--&gt;</td> <td valign=top>SysTime</td></tr>
        </caption>       <tr><td valign=top>SysTime</td> <td valign=top>+</td> <td valign=top>duration</td> <td valign=top>--&gt;</td> <td valign=top>SysTime</td></tr>
        <tr><td valign=top>SysTime</td> <td valign=top>-</td> <td valign=top>duration</td> <td valign=top>--&gt;</td> <td valign=top>SysTime</td></tr>
        </table>

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>duration</td>
<td valign=top>The duration to add to or subtract from this
                       <span class="d_inlinecode">SysTime</span>.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">pure nothrow SysTime <a name="opOpAssign"></a><u>opOpAssign</u>(string op, D)(in D <i>duration</i>);
</div></dt>
<dd>Gives the result of adding or subtracting a duration from this
        <span class="d_inlinecode">SysTime</span>, as well as assigning the result to this <span class="d_inlinecode">SysTime</span>.
<p></p>
The legal types of arithmetic for <span class="d_inlinecode">SysTime</span> using this operator are
<p></p>


        <table cellspacing=0 cellpadding=5><caption>       <tr><td valign=top>SysTime</td> <td valign=top>+</td> <td valign=top>duration</td> <td valign=top>--&gt;</td> <td valign=top>SysTime</td></tr>
        <tr><td valign=top>SysTime</td> <td valign=top>-</td> <td valign=top>duration</td> <td valign=top>--&gt;</td> <td valign=top>SysTime</td></tr>
        </caption>       <tr><td valign=top>SysTime</td> <td valign=top>+</td> <td valign=top>duration</td> <td valign=top>--&gt;</td> <td valign=top>SysTime</td></tr>
        <tr><td valign=top>SysTime</td> <td valign=top>-</td> <td valign=top>duration</td> <td valign=top>--&gt;</td> <td valign=top>SysTime</td></tr>
        </table>

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>duration</td>
<td valign=top>The duration to add to or subtract from this
                       <span class="d_inlinecode">SysTime</span>.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">const pure nothrow Duration <a name="opBinary"></a><u>opBinary</u>(string op)(in SysTime <i>rhs</i>);
</div></dt>
<dd>Gives the difference between two <span class="d_inlinecode">SysTime</span>s.
<p></p>
The legal types of arithmetic for <span class="d_inlinecode">SysTime</span> using this operator are
<p></p>


        <table cellspacing=0 cellpadding=5><caption>       <tr><td valign=top>SysTime</td> <td valign=top>-</td> <td valign=top>SysTime</td> <td valign=top>--&gt;</td> <td valign=top>duration</td></tr>
        </caption>       <tr><td valign=top>SysTime</td> <td valign=top>-</td> <td valign=top>SysTime</td> <td valign=top>--&gt;</td> <td valign=top>duration</td></tr>
        </table><p></p>

</dd>
<dt><div class="d_decl">const nothrow int <a name="diffMonths"></a><u>diffMonths</u>(in SysTime <i>rhs</i>);
</div></dt>
<dd>Returns the difference between the two <span class="d_inlinecode">SysTime</span>s in months.
<p></p>
You can get the difference in years by subtracting the year property
        of two <span class="d_inlinecode">SysTime</span>s, and you can get the difference in days or weeks by
        subtracting the <span class="d_inlinecode">SysTime</span>s themselves and using the <span class="d_inlinecode">Duration</span>
        that results, but because you cannot convert between months and smaller
        units without a specific date (which <span class="d_inlinecode">Duration</span>s don't have), you
        cannot get the difference in months without doing some math using both
        the year and month properties, so this is a convenience function for
        getting the difference in months.
<p></p>


        Note that the number of days in the months or how far into the month
        either date is is irrelevant. It is the difference in the month property
        combined with the difference in years * 12. So, for instance,
        December 31st and January 1st are one month apart just as December 1st
        and January 31st are one month apart.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>SysTime <i>rhs</i></td>
<td valign=top>The <span class="d_inlinecode">SysTime</span> to subtract from this one.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(SysTime(Date(1999, 2, 1)).<span class="d_psymbol">diffMonths</span>(SysTime(Date(1999, 1, 31))) == 1);
<span class="d_keyword">assert</span>(SysTime(Date(1999, 1, 31)).<span class="d_psymbol">diffMonths</span>(SysTime(Date(1999, 2, 1))) == -1);
<span class="d_keyword">assert</span>(SysTime(Date(1999, 3, 1)).<span class="d_psymbol">diffMonths</span>(SysTime(Date(1999, 1, 1))) == 2);
<span class="d_keyword">assert</span>(SysTime(Date(1999, 1, 1)).<span class="d_psymbol">diffMonths</span>(SysTime(Date(1999, 3, 31))) == -2);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const nothrow @property bool <a name="isLeapYear"></a><u>isLeapYear</u>();
</div></dt>
<dd>Whether this <span class="d_inlinecode">SysTime</span> is in a leap year.<p></p>

</dd>
<dt><div class="d_decl">const nothrow @property DayOfWeek <a name="dayOfWeek"></a><u>dayOfWeek</u>();
</div></dt>
<dd>Day of the week this <span class="d_inlinecode">SysTime</span> is on.<p></p>

</dd>
<dt><div class="d_decl">const nothrow @property ushort <a name="dayOfYear"></a><u>dayOfYear</u>();
</div></dt>
<dd>Day of the year this <span class="d_inlinecode">SysTime</span> is on.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(SysTime(DateTime(1999, 1, 1, 12, 22, 7)).<span class="d_psymbol">dayOfYear</span> == 1);
<span class="d_keyword">assert</span>(SysTime(DateTime(1999, 12, 31, 7, 2, 59)).<span class="d_psymbol">dayOfYear</span> == 365);
<span class="d_keyword">assert</span>(SysTime(DateTime(2000, 12, 31, 21, 20, 0)).<span class="d_psymbol">dayOfYear</span> == 366);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">@property void <a name="dayOfYear"></a><u>dayOfYear</u>(int <i>day</i>);
</div></dt>
<dd>Day of the year.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>int <i>day</i></td>
<td valign=top>The <i>day</i> of the year to set which <i>day</i> of the year this
                  <span class="d_inlinecode">SysTime</span> is on.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">const nothrow @property int <a name="dayOfGregorianCal"></a><u>dayOfGregorianCal</u>();
</div></dt>
<dd>The Xth day of the Gregorian Calendar that this <span class="d_inlinecode">SysTime</span> is on.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(SysTime(DateTime(1, 1, 1, 0, 0, 0)).<span class="d_psymbol">dayOfGregorianCal</span> == 1);
<span class="d_keyword">assert</span>(SysTime(DateTime(1, 12, 31, 23, 59, 59)).<span class="d_psymbol">dayOfGregorianCal</span> == 365);
<span class="d_keyword">assert</span>(SysTime(DateTime(2, 1, 1, 2, 2, 2)).<span class="d_psymbol">dayOfGregorianCal</span> == 366);

<span class="d_keyword">assert</span>(SysTime(DateTime(0, 12, 31, 7, 7, 7)).<span class="d_psymbol">dayOfGregorianCal</span> == 0);
<span class="d_keyword">assert</span>(SysTime(DateTime(0, 1, 1, 19, 30, 0)).<span class="d_psymbol">dayOfGregorianCal</span> == -365);
<span class="d_keyword">assert</span>(SysTime(DateTime(-1, 12, 31, 4, 7, 0)).<span class="d_psymbol">dayOfGregorianCal</span> == -366);

<span class="d_keyword">assert</span>(SysTime(DateTime(2000, 1, 1, 9, 30, 20)).<span class="d_psymbol">dayOfGregorianCal</span> == 730_120);
<span class="d_keyword">assert</span>(SysTime(DateTime(2010, 12, 31, 15, 45, 50)).<span class="d_psymbol">dayOfGregorianCal</span> == 734_137);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">nothrow @property void <a name="dayOfGregorianCal"></a><u>dayOfGregorianCal</u>(int <i>days</i>);
</div></dt>
<dd>The Xth day of the Gregorian Calendar that this <span class="d_inlinecode">SysTime</span> is on.
        Setting this property does not affect the time portion of <span class="d_inlinecode">SysTime</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>int <i>days</i></td>
<td valign=top>The day of the Gregorian Calendar to set this <span class="d_inlinecode">SysTime</span>
                   to.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> st = SysTime(DateTime(0, 0, 0, 12, 0, 0));
st.<span class="d_psymbol">dayOfGregorianCal</span> = 1;
<span class="d_keyword">assert</span>(st == SysTime(DateTime(1, 1, 1, 12, 0, 0)));

st.<span class="d_psymbol">dayOfGregorianCal</span> = 365;
<span class="d_keyword">assert</span>(st == SysTime(DateTime(1, 12, 31, 12, 0, 0)));

st.<span class="d_psymbol">dayOfGregorianCal</span> = 366;
<span class="d_keyword">assert</span>(st == SysTime(DateTime(2, 1, 1, 12, 0, 0)));

st.<span class="d_psymbol">dayOfGregorianCal</span> = 0;
<span class="d_keyword">assert</span>(st == SysTime(DateTime(0, 12, 31, 12, 0, 0)));

st.<span class="d_psymbol">dayOfGregorianCal</span> = -365;
<span class="d_keyword">assert</span>(st == SysTime(DateTime(-0, 1, 1, 12, 0, 0)));

st.<span class="d_psymbol">dayOfGregorianCal</span> = -366;
<span class="d_keyword">assert</span>(st == SysTime(DateTime(-1, 12, 31, 12, 0, 0)));

st.<span class="d_psymbol">dayOfGregorianCal</span> = 730_120;
<span class="d_keyword">assert</span>(st == SysTime(DateTime(2000, 1, 1, 12, 0, 0)));

st.<span class="d_psymbol">dayOfGregorianCal</span> = 734_137;
<span class="d_keyword">assert</span>(st == SysTime(DateTime(2010, 12, 31, 12, 0, 0)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const nothrow @property ubyte <a name="isoWeek"></a><u>isoWeek</u>();
</div></dt>
<dd>The ISO 8601 week of the year that this <span class="d_inlinecode">SysTime</span> is in.
<p></p>
<b>See Also:</b><br><a href="http://en.wikipedia.org/wiki/ISO_week_date">ISO Week Date</a>.<p></p>

</dd>
<dt><div class="d_decl">const nothrow @property SysTime <a name="endOfMonth"></a><u>endOfMonth</u>();
</div></dt>
<dd><span class="d_inlinecode">SysTime</span> for the last day in the month that this Date is in.
        The time portion of <a name="endOfMonth"></a><u>endOfMonth</u> is always 23:59:59.9999999.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(SysTime(DateTime(1999, 1, 6, 0, 0, 0)).<span class="d_psymbol">endOfMonth</span> ==
       SysTime(DateTime(1999, 1, 31, 23, 59, 59),
               FracSec.from!<span class="d_string">"hnsecs"</span>(9_999_999)));

<span class="d_keyword">assert</span>(SysTime(DateTime(1999, 2, 7, 19, 30, 0),
               FracSec.from!<span class="d_string">"msecs"</span>(24)).<span class="d_psymbol">endOfMonth</span> ==
       SysTime(DateTime(1999, 2, 28, 23, 59, 59),
               FracSec.from!<span class="d_string">"hnsecs"</span>(9_999_999)));

<span class="d_keyword">assert</span>(SysTime(DateTime(2000, 2, 7, 5, 12, 27),
               FracSec.from!<span class="d_string">"usecs"</span>(5203)).<span class="d_psymbol">endOfMonth</span> ==
       SysTime(DateTime(2000, 2, 29, 23, 59, 59),
               FracSec.from!<span class="d_string">"hnsecs"</span>(9_999_999)));

<span class="d_keyword">assert</span>(SysTime(DateTime(2000, 6, 4, 12, 22, 9),
               FracSec.from!<span class="d_string">"hnsecs"</span>(12345)).<span class="d_psymbol">endOfMonth</span> ==
       SysTime(DateTime(2000, 6, 30, 23, 59, 59),
               FracSec.from!<span class="d_string">"hnsecs"</span>(9_999_999)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const nothrow @property ubyte <a name="daysInMonth"></a><u>daysInMonth</u>();
</div></dt>
<dd>The last day in the month that this <span class="d_inlinecode">SysTime</span> is in.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(SysTime(DateTime(1999, 1, 6, 0, 0, 0)).<span class="d_psymbol">daysInMonth</span> == 31);
<span class="d_keyword">assert</span>(SysTime(DateTime(1999, 2, 7, 19, 30, 0)).<span class="d_psymbol">daysInMonth</span> == 28);
<span class="d_keyword">assert</span>(SysTime(DateTime(2000, 2, 7, 5, 12, 27)).<span class="d_psymbol">daysInMonth</span> == 29);
<span class="d_keyword">assert</span>(SysTime(DateTime(2000, 6, 4, 12, 22, 9)).<span class="d_psymbol">daysInMonth</span> == 30);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">alias <a name="endofMonthDay"></a><u>endofMonthDay</u>;
</div></dt>
<dd><span style="color:red">Scheduled for deprecation in January 2012.
              Please use daysInMonth instead.</span><p></p>

</dd>
<dt><div class="d_decl">const nothrow @property bool <a name="isAD"></a><u>isAD</u>();
</div></dt>
<dd>Whether the current year is a date in A.D.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(SysTime(DateTime(1, 1, 1, 12, 7, 0)).<span class="d_psymbol">isAD</span>);
<span class="d_keyword">assert</span>(SysTime(DateTime(2010, 12, 31, 0, 0, 0)).<span class="d_psymbol">isAD</span>);
<span class="d_keyword">assert</span>(!SysTime(DateTime(0, 12, 31, 23, 59, 59)).<span class="d_psymbol">isAD</span>);
<span class="d_keyword">assert</span>(!SysTime(DateTime(-2010, 1, 1, 2, 2, 2)).<span class="d_psymbol">isAD</span>);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const nothrow @property long <a name="julianDay"></a><u>julianDay</u>();
</div></dt>
<dd>The julian day for this <span class="d_inlinecode">SysTime</span> at the given time. For example,
        prior to noon, 1996-03-31 would be the julian day number 2450_173, so
        this function returns 2450_173, while from noon onward, the julian
        day number would be 2450_174, so this function returns 2450_174.<p></p>

</dd>
<dt><div class="d_decl">const nothrow @property long <a name="modJulianDay"></a><u>modJulianDay</u>();
</div></dt>
<dd>The modified julian day for any time on this date (since, the modified
        julian day changes at midnight).<p></p>

</dd>
<dt><div class="d_decl">const nothrow Date <a name="opCast"></a><u>opCast</u>(T)();
</div></dt>
<dd>Returns a <span class="d_inlinecode">Date</span> equivalent to this <span class="d_inlinecode">SysTime</span>.<p></p>

</dd>
<dt><div class="d_decl">const nothrow DateTime <a name="opCast"></a><u>opCast</u>(T)();
</div></dt>
<dd>Returns a <span class="d_inlinecode">DateTime</span> equivalent to this <span class="d_inlinecode">SysTime</span>.<p></p>

</dd>
<dt><div class="d_decl">const nothrow TimeOfDay <a name="opCast"></a><u>opCast</u>(T)();
</div></dt>
<dd>Returns a <span class="d_inlinecode">TimeOfDay</span> equivalent to this <span class="d_inlinecode">SysTime</span>.<p></p>

</dd>
<dt><div class="d_decl">const nothrow string <a name="toISOString"></a><u>toISOString</u>();
</div></dt>
<dd>Converts this <span class="d_inlinecode">SysTime</span> to a string with the format
        YYYYMMDDTHHMMSS.FFFFFFFTZ (where F is fractional seconds and TZ is time
        zone).
<p></p>
Note that the number of digits in the fractional seconds varies with the
        number of fractional seconds. It's a maximum of 7 (which would be
        hnsecs), but only has as many as are necessary to hold the correct value
        (so no trailing zeroes), and if there are no fractional seconds, then
        there is no decimal point.
<p></p>


        If this <span class="d_inlinecode">SysTime</span>'s time zone is <span class="d_inlinecode">LocalTime</span>, then TZ is empty.
        If its time zone is <span class="d_inlinecode">UTC</span>, then it is "Z". Otherwise, it is the
        offset from UTC (e.g. +1:00 or -7:00). Note that the offset from UTC
        is <i>not</i> enough to uniquely identify the time zone.
<p></p>


        Time zone offsets will be in the form +HH:MM or -HH:MM.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(SysTime(DateTime(2010, 7, 4, 7, 6, 12)).<span class="d_psymbol">toISOString</span>() ==
       <span class="d_string">"20100704T070612"</span>);

<span class="d_keyword">assert</span>(SysTime(DateTime(1998, 12, 25, 2, 15, 0),
               FracSec.from!<span class="d_string">"msecs"</span>(24)).<span class="d_psymbol">toISOString</span>() ==
       <span class="d_string">"19981225T021500.024"</span>);

<span class="d_keyword">assert</span>(SysTime(DateTime(0, 1, 5, 23, 9, 59)).<span class="d_psymbol">toISOString</span>() ==
       <span class="d_string">"00000105T230959"</span>);

<span class="d_keyword">assert</span>(SysTime(DateTime(-4, 1, 5, 0, 0, 2),
               FracSec.from!<span class="d_string">"hnsecs"</span>(520_920)).<span class="d_psymbol">toISOString</span>() ==
       <span class="d_string">"-00040105T000002.052092"</span>);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const nothrow string <a name="toISOExtString"></a><u>toISOExtString</u>();
</div></dt>
<dd>Converts this <span class="d_inlinecode">SysTime</span> to a string with the format
        YYYY-MM-DDTHH:MM:SS.FFFFFFFTZ (where F is fractional seconds and TZ
        is the time zone).
<p></p>
Note that the number of digits in the fractional seconds varies with the
        number of fractional seconds. It's a maximum of 7 (which would be
        hnsecs), but only has as many as are necessary to hold the correct value
        (so no trailing zeroes), and if there are no fractional seconds, then
        there is no decimal point.
<p></p>


        If this <span class="d_inlinecode">SysTime</span>'s time zone is <span class="d_inlinecode">LocalTime</span>, then TZ is empty. If
        its time zone is <span class="d_inlinecode">UTC</span>, then it is "Z". Otherwise, it is the offset
        from UTC (e.g. +1:00 or -7:00). Note that the offset from UTC is
        <i>not</i> enough to uniquely identify the time zone.
<p></p>


        Time zone offsets will be in the form +HH:MM or -HH:MM.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(SysTime(DateTime(2010, 7, 4, 7, 6, 12)).<span class="d_psymbol">toISOExtString</span>() ==
       <span class="d_string">"2010-07-04T07:06:12"</span>);

<span class="d_keyword">assert</span>(SysTime(DateTime(1998, 12, 25, 2, 15, 0),
               FracSec.from!<span class="d_string">"msecs"</span>(24)).<span class="d_psymbol">toISOExtString</span>() ==
       <span class="d_string">"1998-12-25T02:15:00.024"</span>);

<span class="d_keyword">assert</span>(SysTime(DateTime(0, 1, 5, 23, 9, 59)).<span class="d_psymbol">toISOExtString</span>() ==
       <span class="d_string">"0000-01-05T23:09:59"</span>);

<span class="d_keyword">assert</span>(SysTime(DateTime(-4, 1, 5, 0, 0, 2),
               FracSec.from!<span class="d_string">"hnsecs"</span>(520_920)).<span class="d_psymbol">toISOExtString</span>() ==
       <span class="d_string">"-0004-01-05T00:00:02.052092"</span>);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">alias <a name="toISOExtendedString"></a><u>toISOExtendedString</u>;
</div></dt>
<dd><span style="color:red">Scheduled for deprecation in November 2011.
              Please use toISOExtString instead.</span><p></p>

</dd>
<dt><div class="d_decl">const nothrow string <a name="toSimpleString"></a><u>toSimpleString</u>();
</div></dt>
<dd>Converts this <span class="d_inlinecode">SysTime</span> to a string with the format
        YYYY-Mon-DD HH:MM:SS.FFFFFFFTZ (where F is fractional seconds and TZ
        is the time zone).
<p></p>
Note that the number of digits in the fractional seconds varies with the
        number of fractional seconds. It's a maximum of 7 (which would be
        hnsecs), but only has as many as are necessary to hold the correct value
        (so no trailing zeroes), and if there are no fractional seconds, then
        there is no decimal point.
<p></p>


        If this <span class="d_inlinecode">SysTime</span>'s time zone is <span class="d_inlinecode">LocalTime</span>, then TZ is empty. If
        its time zone is <span class="d_inlinecode">UTC</span>, then it is "Z". Otherwise, it is the offset
        from UTC (e.g. +1:00 or -7:00). Note that the offset from UTC is
        <i>not</i> enough to uniquely identify the time zone.
<p></p>


        Time zone offsets will be in the form +HH:MM or -HH:MM.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(SysTime(DateTime(2010, 7, 4, 7, 6, 12)).<span class="d_psymbol">toSimpleString</span>() ==
       <span class="d_string">"2010-Jul-04 07:06:12"</span>);

<span class="d_keyword">assert</span>(SysTime(DateTime(1998, 12, 25, 2, 15, 0),
               FracSec.from!<span class="d_string">"msecs"</span>(24)).<span class="d_psymbol">toSimpleString</span>() ==
       <span class="d_string">"1998-Dec-25 02:15:00.024"</span>);

<span class="d_keyword">assert</span>(SysTime(DateTime(0, 1, 5, 23, 9, 59)).<span class="d_psymbol">toSimpleString</span>() ==
       <span class="d_string">"0000-Jan-05 23:09:59"</span>);

<span class="d_keyword">assert</span>(SysTime(DateTime(-4, 1, 5, 0, 0, 2),
               FracSec.from!<span class="d_string">"hnsecs"</span>(520_920)).<span class="d_psymbol">toSimpleString</span>() ==
        <span class="d_string">"-0004-Jan-05 00:00:02.052092"</span>);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const nothrow string <a name="toString"></a><u>toString</u>();
</div></dt>
<dd>Converts this <span class="d_inlinecode">SysTime</span> to a string.<p></p>

</dd>
<dt><div class="d_decl">SysTime <a name="fromISOString"></a><u>fromISOString</u>(S)(in S <i>isoString</i>, immutable TimeZone <i>tz</i> = null);
</div></dt>
<dd>Creates a <span class="d_inlinecode">SysTime</span> from a string with the format
        YYYYMMDDTHHMMSS.FFFFFFFTZ (where F is fractional seconds is the time
        zone). Whitespace is stripped from the given string.
<p></p>
The exact format is exactly as described in <span class="d_inlinecode">toISOString</span> except that
        trailing zeroes are permitted - including having fractional seconds with
        all zeroes. However, a decimal point with nothing following it is
        invalid.
<p></p>


        If there is no time zone in the string, then <span class="d_inlinecode">LocalTime</span> is used. If
        the time zone is "Z", then <span class="d_inlinecode">UTC</span> is used. Otherwise, a
        <span class="d_inlinecode">SimpleTimeZone</span> which corresponds to the given offset from UTC is
        used. If you wish the returned <span class="d_inlinecode">SysTime</span> to be a particular time
        zone, then pass in that time zone and the <span class="d_inlinecode">SysTime</span> to be returned
        will be converted to that time zone (though it will still be read in as
        whatever time zone is in its string).
<p></p>


        The accepted formats for time zone offsets
        are +H, -H, +HH, -HH, +H:MM, -H:MM, +HH:MM, and -HH:MM.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>isoString</td>
<td valign=top>A string formatted in the ISO format for dates and times.</td></tr>
<tr><td valign=top>tz</td>
<td valign=top>The time zone to convert the given time to (no
                        conversion occurs if <b>null</b>).</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given string is not in the ISO format
            or if the resulting <span class="d_inlinecode">SysTime</span> would not be valid.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(SysTime.<span class="d_psymbol">fromISOString</span>(<span class="d_string">"20100704T070612"</span>) ==
       SysTime(DateTime(2010, 7, 4, 7, 6, 12)));
<span class="d_keyword">assert</span>(SysTime.<span class="d_psymbol">fromISOString</span>(<span class="d_string">"19981225T021500.007"</span>) ==
       SysTime(DateTime(1998, 12, 25, 2, 15, 0), FracSec.from!<span class="d_string">"msecs"</span>(7)));
<span class="d_keyword">assert</span>(SysTime.<span class="d_psymbol">fromISOString</span>(<span class="d_string">"00000105T230959.00002"</span>) ==
       SysTime(DateTime(0, 1, 5, 23, 9, 59), FracSec.from!<span class="d_string">"usecs"</span>(20)));
<span class="d_keyword">assert</span>(SysTime.<span class="d_psymbol">fromISOString</span>(<span class="d_string">"-00040105T000002"</span>) ==
       SysTime(DateTime(-4, 1, 5, 0, 0, 2)));
<span class="d_keyword">assert</span>(SysTime.<span class="d_psymbol">fromISOString</span>(<span class="d_string">" 20100704T070612 "</span>) ==
       SysTime(DateTime(2010, 7, 4, 7, 6, 12)));

<span class="d_keyword">assert</span>(SysTime.<span class="d_psymbol">fromISOString</span>(<span class="d_string">"20100704T070612Z"</span>) ==
       SysTime(DateTime(2010, 7, 4, 7, 6, 12), UTC()));
<span class="d_keyword">assert</span>(SysTime.<span class="d_psymbol">fromISOString</span>(<span class="d_string">"20100704T070612-8:00"</span>) ==
       SysTime(DateTime(2010, 7, 4, 7, 6, 12), <span class="d_keyword">new</span> SimpleTimeZone(-480)));
<span class="d_keyword">assert</span>(SysTime.<span class="d_psymbol">fromISOString</span>(<span class="d_string">"20100704T070612+8:00"</span>) ==
       SysTime(DateTime(2010, 7, 3, 7, 6, 12), <span class="d_keyword">new</span> SimpleTimeZone(480)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">SysTime <a name="fromISOExtString"></a><u>fromISOExtString</u>(S)(in S <i>isoExtString</i>, immutable TimeZone <i>tz</i> = null);
</div></dt>
<dd>Creates a <span class="d_inlinecode">SysTime</span> from a string with the format
        YYYY-MM-DDTHH:MM:SS.FFFFFFFTZ (where F is fractional seconds is the
        time zone). Whitespace is stripped from the given string.
<p></p>
The exact format is exactly as described in <span class="d_inlinecode">toISOExtString</span>
        except that trailing zeroes are permitted - including having fractional
        seconds with all zeroes. However, a decimal point with nothing following
        it is invalid.
<p></p>


        If there is no time zone in the string, then <span class="d_inlinecode">LocalTime</span> is used. If
        the time zone is "Z", then <span class="d_inlinecode">UTC</span> is used. Otherwise, a
        <span class="d_inlinecode">SimpleTimeZone</span> which corresponds to the given offset from UTC is
        used. If you wish the returned <span class="d_inlinecode">SysTime</span> to be a particular time
        zone, then pass in that time zone and the <span class="d_inlinecode">SysTime</span> to be returned
        will be converted to that time zone (though it will still be read in as
        whatever time zone is in its string).
<p></p>


        The accepted formats for time zone offsets
        are +H, -H, +HH, -HH, +H:MM, -H:MM, +HH:MM, and -HH:MM.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>isoString</td>
<td valign=top>A string formatted in the ISO Extended format for dates
                        and times.</td></tr>
<tr><td valign=top>tz</td>
<td valign=top>The time zone to convert the given time to (no
                        conversion occurs if <b>null</b>).</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given string is not in the ISO format
            or if the resulting <span class="d_inlinecode">SysTime</span> would not be valid.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(SysTime.<span class="d_psymbol">fromISOExtString</span>(<span class="d_string">"2010-07-04T07:06:12"</span>) ==
       SysTime(DateTime(2010, 7, 4, 7, 6, 12)));
<span class="d_keyword">assert</span>(SysTime.<span class="d_psymbol">fromISOExtString</span>(<span class="d_string">"1998-12-25T02:15:00.007"</span>) ==
       SysTime(DateTime(1998, 12, 25, 2, 15, 0), FracSec.from!<span class="d_string">"msecs"</span>(7)));
<span class="d_keyword">assert</span>(SysTime.<span class="d_psymbol">fromISOExtString</span>(<span class="d_string">"0000-01-05T23:09:59.00002"</span>) ==
       SysTime(DateTime(0, 1, 5, 23, 9, 59), FracSec.from!<span class="d_string">"usecs"</span>(20)));
<span class="d_keyword">assert</span>(SysTime.<span class="d_psymbol">fromISOExtString</span>(<span class="d_string">"-0004-01-05T00:00:02"</span>) ==
       SysTime(DateTime(-4, 1, 5, 0, 0, 2)));
<span class="d_keyword">assert</span>(SysTime.<span class="d_psymbol">fromISOExtString</span>(<span class="d_string">" 2010-07-04T07:06:12 "</span>) ==
       SysTime(DateTime(2010, 7, 4, 7, 6, 12)));

<span class="d_keyword">assert</span>(SysTime.<span class="d_psymbol">fromISOExtString</span>(<span class="d_string">"2010-07-04T07:06:12Z"</span>) ==
       SysTime(DateTime(2010, 7, 4, 7, 6, 12), UTC()));
<span class="d_keyword">assert</span>(SysTime.<span class="d_psymbol">fromISOExtString</span>(<span class="d_string">"2010-07-04T07:06:12-8:00"</span>) ==
       SysTime(DateTime(2010, 7, 4, 7, 6, 12), <span class="d_keyword">new</span> SimpleTimeZone(-480)));
<span class="d_keyword">assert</span>(SysTime.<span class="d_psymbol">fromISOExtString</span>(<span class="d_string">"2010-07-04T07:06:12+8:00"</span>) ==
       SysTime(DateTime(2010, 7, 4, 7, 6, 12), <span class="d_keyword">new</span> SimpleTimeZone(480)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">SysTime <a name="fromISOExtendedString"></a><u>fromISOExtendedString</u>(S)(in S <i>isoExtString</i>, immutable TimeZone <i>tz</i> = null);
</div></dt>
<dd><span style="color:red">Scheduled for deprecation in November 2011.
              Please use fromISOExtString instead.</span><p></p>

</dd>
<dt><div class="d_decl">SysTime <a name="fromSimpleString"></a><u>fromSimpleString</u>(S)(in S <i>simpleString</i>, immutable TimeZone <i>tz</i> = null);
</div></dt>
<dd>Creates a <span class="d_inlinecode">SysTime</span> from a string with the format
        YYYY-MM-DD HH:MM:SS.FFFFFFFTZ (where F is fractional seconds is the
        time zone). Whitespace is stripped from the given string.
<p></p>
The exact format is exactly as described in <span class="d_inlinecode">toSimpleString</span> except
        that trailing zeroes are permitted - including having fractional seconds
        with all zeroes. However, a decimal point with nothing following it is
        invalid.
<p></p>


        If there is no time zone in the string, then <span class="d_inlinecode">LocalTime</span> is used. If
        the time zone is "Z", then <span class="d_inlinecode">UTC</span> is used. Otherwise, a
        <span class="d_inlinecode">SimpleTimeZone</span> which corresponds to the given offset from UTC is
        used. If you wish the returned <span class="d_inlinecode">SysTime</span> to be a particular time
        zone, then pass in that time zone and the <span class="d_inlinecode">SysTime</span> to be returned
        will be converted to that time zone (though it will still be read in as
        whatever time zone is in its string).
<p></p>


        The accepted formats for time zone offsets
        are +H, -H, +HH, -HH, +H:MM, -H:MM, +HH:MM, and -HH:MM.
<p></p>



<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>simpleString</td>
<td valign=top>A string formatted in the way that
                           <span class="d_inlinecode">toSimpleString</span> formats dates and times.</td></tr>
<tr><td valign=top>tz</td>
<td valign=top>The time zone to convert the given time to (no
                           conversion occurs if <b>null</b>).</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given string is not in the ISO format
            or if the resulting <span class="d_inlinecode">SysTime</span> would not be valid.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(SysTime.<span class="d_psymbol">fromSimpleString</span>(<span class="d_string">"2010-Jul-04 07:06:12"</span>) ==
       SysTime(DateTime(2010, 7, 4, 7, 6, 12)));
<span class="d_keyword">assert</span>(SysTime.<span class="d_psymbol">fromSimpleString</span>(<span class="d_string">"1998-Dec-25 02:15:00.007"</span>) ==
       SysTime(DateTime(1998, 12, 25, 2, 15, 0), FracSec.from!<span class="d_string">"msecs"</span>(7)));
<span class="d_keyword">assert</span>(SysTime.<span class="d_psymbol">fromSimpleString</span>(<span class="d_string">"0000-Jan-05 23:09:59.00002"</span>) ==
       SysTime(DateTime(0, 1, 5, 23, 9, 59), FracSec.from!<span class="d_string">"usecs"</span>(20)));
<span class="d_keyword">assert</span>(SysTime.<span class="d_psymbol">fromSimpleString</span>(<span class="d_string">"-0004-Jan-05 00:00:02"</span>) ==
       SysTime(DateTime(-4, 1, 5, 0, 0, 2)));
<span class="d_keyword">assert</span>(SysTime.<span class="d_psymbol">fromSimpleString</span>(<span class="d_string">" 2010-Jul-04 07:06:12 "</span>) ==
       SysTime(DateTime(2010, 7, 4, 7, 6, 12)));

<span class="d_keyword">assert</span>(SysTime.<span class="d_psymbol">fromSimpleString</span>(<span class="d_string">"2010-Jul-04 07:06:12Z"</span>) ==
       SysTime(DateTime(2010, 7, 4, 7, 6, 12), UTC()));
<span class="d_keyword">assert</span>(SysTime.<span class="d_psymbol">fromSimpleString</span>(<span class="d_string">"2010-Jul-04 07:06:12-8:00"</span>) ==
       SysTime(DateTime(2010, 7, 4, 7, 6, 12), <span class="d_keyword">new</span> SimpleTimeZone(-480)));
<span class="d_keyword">assert</span>(SysTime.<span class="d_psymbol">fromSimpleString</span>(<span class="d_string">"2010-Jul-04 07:06:12+8:00"</span>) ==
       SysTime(DateTime(2010, 7, 4, 7, 6, 12), <span class="d_keyword">new</span> SimpleTimeZone(480)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">static pure nothrow @property SysTime <a name="min"></a><u>min</u>();
</div></dt>
<dd>Returns the <span class="d_inlinecode">SysTime</span> farthest in the past which is representable
        by <span class="d_inlinecode">SysTime</span>.
<p></p>
The <span class="d_inlinecode">SysTime</span> which is returned is in UTC.<p></p>

</dd>
<dt><div class="d_decl">static pure nothrow @property SysTime <a name="max"></a><u>max</u>();
</div></dt>
<dd>Returns the <span class="d_inlinecode">SysTime</span> farthest in the future which is representable
        by <span class="d_inlinecode">SysTime</span>.
<p></p>
The <span class="d_inlinecode">SysTime</span> which is returned is in UTC.<p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">struct <a name="Date"></a><u>Date</u>;
</div></dt>
<dd>Represents a date in the Proleptic Gregorian Calendar ranging from
    32,768 B.C. to 32,767 A.D. Positive years are A.D. Non-positive years are
    B.C.
<p></p>
Year, month, and day are kept separately internally so that <span class="d_inlinecode"><a name="Date"></a><u>Date</u></span> is
    optimized for calendar-based operations.
<p></p>


    <span class="d_inlinecode"><a name="Date"></a><u>Date</u></span> uses the Proleptic Gregorian Calendar, so it assumes the Gregorian
    leap year calculations for its entire length. And, as per
    <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a>, it also treats 1 B.C. as
    year 0. So, 1 B.C. is 0, 2 B.C. is -1, etc. Use <span class="d_inlinecode">yearBC</span> if want B.C. as
    a positive integer with 1 B.C. being the year prior to 1 A.D.
<p></p>


    Year 0 is a leap year.<p></p>

<dl><dt><div class="d_decl">pure  this(int <i>year</i>, int <i>month</i>, int <i>day</i>);
</div></dt>
<dd><b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the resulting <span class="d_inlinecode">Date</span> would not be valid.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>int <i>year</i></td>
<td valign=top>Year of the Gregorian Calendar. Positive values are A.D.
                    Non-positive values are B.C. with <i>year</i> 0 being the <i>year</i>
                    prior to 1 A.D.</td></tr>
<tr><td valign=top>int <i>month</i></td>
<td valign=top>Month of the <i>year</i>.</td></tr>
<tr><td valign=top>int <i>day</i></td>
<td valign=top>Day of the <i>month</i>.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">pure nothrow  this(int <i>day</i>);
</div></dt>
<dd><b>Parameters:</b><table class=parms><tr><td valign=top>int <i>day</i></td>
<td valign=top>The Xth <i>day</i> of the Gregorian Calendar that the constructed
                  <span class="d_inlinecode">Date</span> will be for.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">const pure nothrow int <a name="opCmp"></a><u>opCmp</u>(in Date <i>rhs</i>);
</div></dt>
<dd>Compares this <span class="d_inlinecode">Date</span> with the given <span class="d_inlinecode">Date</span>.
<p></p>
<b>Returns:</b><br><table cellspacing=0 cellpadding=5><caption>           <tr><td valign=top>this &lt; <i>rhs</i></td> <td valign=top>&lt; 0</td></tr>
            <tr><td valign=top>this == <i>rhs</i></td> <td valign=top>0</td></tr>
            <tr><td valign=top>this &gt; <i>rhs</i></td> <td valign=top>&gt; 0</td></tr>
            </caption>           <tr><td valign=top>this &lt; <i>rhs</i></td> <td valign=top>&lt; 0</td></tr>
            <tr><td valign=top>this == <i>rhs</i></td> <td valign=top>0</td></tr>
            <tr><td valign=top>this &gt; <i>rhs</i></td> <td valign=top>&gt; 0</td></tr>
            </table><p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property short <a name="year"></a><u>year</u>();
</div></dt>
<dd>Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive
        are B.C.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(Date(1999, 7, 6).<span class="d_psymbol">year</span> == 1999);
<span class="d_keyword">assert</span>(Date(2010, 10, 4).<span class="d_psymbol">year</span> == 2010);
<span class="d_keyword">assert</span>(Date(-7, 4, 5).<span class="d_psymbol">year</span> == -7);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">pure @property void <a name="year"></a><u>year</u>(int <a name="year"></a><u>year</u>);
</div></dt>
<dd>Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive
        are B.C.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>int <a name="year"></a><u>year</u></td>
<td valign=top>The <a name="year"></a><u>year</u> to set this Date's <a name="year"></a><u>year</u> to.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the new <a name="year"></a><u>year</u> is not a leap <a name="year"></a><u>year</u> and the
            resulting date would be on February 29th.<p></p>

</dd>
<dt><div class="d_decl">const pure @property ushort <a name="yearBC"></a><u>yearBC</u>();
</div></dt>
<dd>Year B.C. of the Gregorian Calendar counting year 0 as 1 B.C.
<p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if <span class="d_inlinecode">isAD</span> is <b>true</b>.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(Date(0, 1, 1).<span class="d_psymbol">yearBC</span> == 1);
<span class="d_keyword">assert</span>(Date(-1, 1, 1).<span class="d_psymbol">yearBC</span> == 2);
<span class="d_keyword">assert</span>(Date(-100, 1, 1).<span class="d_psymbol">yearBC</span> == 101);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">pure @property void <a name="yearBC"></a><u>yearBC</u>(int <i>year</i>);
</div></dt>
<dd>Year B.C. of the Gregorian Calendar counting <i>year</i> 0 as 1 B.C.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>int <i>year</i></td>
<td valign=top>The <i>year</i> B.C. to set this <span class="d_inlinecode">Date</span>'s <i>year</i> to.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if a non-positive value is given.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> date = Date(2010, 1, 1);
date.<span class="d_psymbol">yearBC</span> = 1;
<span class="d_keyword">assert</span>(date == Date(0, 1, 1));

date.<span class="d_psymbol">yearBC</span> = 10;
<span class="d_keyword">assert</span>(date == Date(-9, 1, 1));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property Month <a name="month"></a><u>month</u>();
</div></dt>
<dd>Month of a Gregorian Year.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(Date(1999, 7, 6).<span class="d_psymbol">month</span> == 7);
<span class="d_keyword">assert</span>(Date(2010, 10, 4).<span class="d_psymbol">month</span> == 10);
<span class="d_keyword">assert</span>(Date(-7, 4, 5).<span class="d_psymbol">month</span> == 4);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">pure @property void <a name="month"></a><u>month</u>(Month <a name="month"></a><u>month</u>);
</div></dt>
<dd>Month of a Gregorian Year.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Month <a name="month"></a><u>month</u></td>
<td valign=top>The <a name="month"></a><u>month</u> to set this <span class="d_inlinecode">Date</span>'s <a name="month"></a><u>month</u> to.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given <a name="month"></a><u>month</u> is not a valid <a name="month"></a><u>month</u> or if
            the current day would not be valid in the given <a name="month"></a><u>month</u>.<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property ubyte <a name="day"></a><u>day</u>();
</div></dt>
<dd>Day of a Gregorian Month.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(Date(1999, 7, 6).<span class="d_psymbol">day</span> == 6);
<span class="d_keyword">assert</span>(Date(2010, 10, 4).<span class="d_psymbol">day</span> == 4);
<span class="d_keyword">assert</span>(Date(-7, 4, 5).<span class="d_psymbol">day</span> == 5);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">pure @property void <a name="day"></a><u>day</u>(int <a name="day"></a><u>day</u>);
</div></dt>
<dd>Day of a Gregorian Month.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>int <a name="day"></a><u>day</u></td>
<td valign=top>The <a name="day"></a><u>day</u> of the month to set this <span class="d_inlinecode">Date</span>'s <a name="day"></a><u>day</u> to.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given <a name="day"></a><u>day</u> is not a valid <a name="day"></a><u>day</u> of the
            current month.<p></p>

</dd>
<dt><div class="d_decl">pure nothrow void <a name="add"></a><u>add</u>(string units)(long <i>value</i>, AllowDayOverflow <i>allowOverflow</i> = AllowDayOverflow.yes);
</div></dt>
<dd>Adds the given number of years or months to this <span class="d_inlinecode">Date</span>. A negative
        number will subtract.
<p></p>
Note that if day overflow is allowed, and the date with the adjusted
        year/month overflows the number of days in the new month, then the month
        will be incremented by one, and the day set to the number of days
        overflowed. (e.g. if the day were 31 and the new month were June, then
        the month would be incremented to July, and the new day would be 1). If
        day overflow is not allowed, then the day will be set to the last valid
        day in the month (e.g. June 31st would become June 30th).

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>units</td>
<td valign=top>The type of units to <a name="add"></a><u>add</u> ("years" or "months").</td></tr>
<tr><td valign=top>value</td>
<td valign=top>The number of months or years to <a name="add"></a><u>add</u> to this
                            <span class="d_inlinecode">Date</span>.</td></tr>
<tr><td valign=top>allowOverflow</td>
<td valign=top>Whether the day should be allowed to overflow,
                            causing the month to increment.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> d1 = Date(2010, 1, 1);
d1.<span class="d_psymbol">add</span>!<span class="d_string">"months"</span>(11);
<span class="d_keyword">assert</span>(d1 == Date(2010, 12, 1));

<span class="d_keyword">auto</span> d2 = Date(2010, 1, 1);
d2.<span class="d_psymbol">add</span>!<span class="d_string">"months"</span>(-11);
<span class="d_keyword">assert</span>(d2 == Date(2009, 2, 1));

<span class="d_keyword">auto</span> d3 = Date(2000, 2, 29);
d3.<span class="d_psymbol">add</span>!<span class="d_string">"years"</span>(1);
<span class="d_keyword">assert</span>(d3 == Date(2001, 3, 1));

<span class="d_keyword">auto</span> d4 = Date(2000, 2, 29);
d4.<span class="d_psymbol">add</span>!<span class="d_string">"years"</span>(1, AllowDayOverflow.no);
<span class="d_keyword">assert</span>(d4 == Date(2001, 2, 28));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">pure nothrow void <a name="roll"></a><u>roll</u>(string units)(long <i>value</i>, AllowDayOverflow <i>allowOverflow</i> = AllowDayOverflow.yes);
</div></dt>
<dd>Adds the given number of years or months to this <span class="d_inlinecode">Date</span>. A negative
        number will subtract.
<p></p>
The difference between rolling and adding is that rolling does not
        affect larger units. So, if you <a name="roll"></a><u>roll</u> a <span class="d_inlinecode">Date</span> 12 months, you get
        the exact same <span class="d_inlinecode">Date</span>. However, the days can still be affected due to
        the differing number of days in each month.
<p></p>


        Because there are no units larger than years, there is no difference
        between adding and rolling years.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>units</td>
<td valign=top>The type of units to add ("years" or "months").</td></tr>
<tr><td valign=top>value</td>
<td valign=top>The number of months or years to add to this
                            <span class="d_inlinecode">Date</span>.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> d1 = Date(2010, 1, 1);
d1.<span class="d_psymbol">roll</span>!<span class="d_string">"months"</span>(1);
<span class="d_keyword">assert</span>(d1 == Date(2010, 2, 1));

<span class="d_keyword">auto</span> d2 = Date(2010, 1, 1);
d2.<span class="d_psymbol">roll</span>!<span class="d_string">"months"</span>(-1);
<span class="d_keyword">assert</span>(d2 == Date(2010, 12, 1));

<span class="d_keyword">auto</span> d3 = Date(1999, 1, 29);
d3.<span class="d_psymbol">roll</span>!<span class="d_string">"months"</span>(1);
<span class="d_keyword">assert</span>(d3 == Date(1999, 3, 1));

<span class="d_keyword">auto</span> d4 = Date(1999, 1, 29);
d4.<span class="d_psymbol">roll</span>!<span class="d_string">"months"</span>(1, AllowDayOverflow.no);
<span class="d_keyword">assert</span>(d4 == Date(1999, 2, 28));

<span class="d_keyword">auto</span> d5 = Date(2000, 2, 29);
d5.<span class="d_psymbol">roll</span>!<span class="d_string">"years"</span>(1);
<span class="d_keyword">assert</span>(d5 == Date(2001, 3, 1));

<span class="d_keyword">auto</span> d6 = Date(2000, 2, 29);
d6.<span class="d_psymbol">roll</span>!<span class="d_string">"years"</span>(1, AllowDayOverflow.no);
<span class="d_keyword">assert</span>(d6 == Date(2001, 2, 28));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">pure nothrow void <a name="roll"></a><u>roll</u>(string units)(long <i>days</i>);
</div></dt>
<dd>Adds the given number of units to this <span class="d_inlinecode">Date</span>. A negative number will
        subtract.
<p></p>
The difference between rolling and adding is that rolling does not
        affect larger units. So, for instance, if you <a name="roll"></a><u>roll</u> a <span class="d_inlinecode">Date</span> one
        year's worth of days, then you get the exact same <span class="d_inlinecode">Date</span>.
<p></p>


        The only accepted units are <span class="d_inlinecode">"days"</span>.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>units</td>
<td valign=top>The units to add. Must be <span class="d_inlinecode">"days"</span>.</td></tr>
<tr><td valign=top>value</td>
<td valign=top>The number of days to add to this <span class="d_inlinecode">Date</span>.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> d = Date(2010, 1, 1);
d.<span class="d_psymbol">roll</span>!<span class="d_string">"days"</span>(1);
<span class="d_keyword">assert</span>(d == Date(2010, 1, 2));
d.<span class="d_psymbol">roll</span>!<span class="d_string">"days"</span>(365);
<span class="d_keyword">assert</span>(d == Date(2010, 1, 26));
d.<span class="d_psymbol">roll</span>!<span class="d_string">"days"</span>(-32);
<span class="d_keyword">assert</span>(d == Date(2010, 1, 25));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow Date <a name="opBinary"></a><u>opBinary</u>(string op, D)(in D <i>duration</i>);
</div></dt>
<dd>Gives the result of adding or subtracting a duration from this
        <span class="d_inlinecode">Date</span>.
<p></p>
The legal types of arithmetic for Date using this operator are
<p></p>


        <table cellspacing=0 cellpadding=5><caption>       <tr><td valign=top>Date</td> <td valign=top>+</td> <td valign=top>duration</td> <td valign=top>--&gt;</td> <td valign=top>Date</td></tr>
        <tr><td valign=top>Date</td> <td valign=top>-</td> <td valign=top>duration</td> <td valign=top>--&gt;</td> <td valign=top>Date</td></tr>
        </caption>       <tr><td valign=top>Date</td> <td valign=top>+</td> <td valign=top>duration</td> <td valign=top>--&gt;</td> <td valign=top>Date</td></tr>
        <tr><td valign=top>Date</td> <td valign=top>-</td> <td valign=top>duration</td> <td valign=top>--&gt;</td> <td valign=top>Date</td></tr>
        </table>

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>duration</td>
<td valign=top>The duration to add to or subtract from this <span class="d_inlinecode">Date</span>.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">pure nothrow Date <a name="opOpAssign"></a><u>opOpAssign</u>(string op, D)(in D <i>duration</i>);
</div></dt>
<dd>Gives the result of adding or subtracting a duration from this
        <span class="d_inlinecode">Date</span>, as well as assigning the result to this <span class="d_inlinecode">Date</span>.
<p></p>
The legal types of arithmetic for <span class="d_inlinecode">Date</span> using this operator are
<p></p>


        <table cellspacing=0 cellpadding=5><caption>       <tr><td valign=top>Date</td> <td valign=top>+</td> <td valign=top>duration</td> <td valign=top>--&gt;</td> <td valign=top>Date</td></tr>
        <tr><td valign=top>Date</td> <td valign=top>-</td> <td valign=top>duration</td> <td valign=top>--&gt;</td> <td valign=top>Date</td></tr>
        </caption>       <tr><td valign=top>Date</td> <td valign=top>+</td> <td valign=top>duration</td> <td valign=top>--&gt;</td> <td valign=top>Date</td></tr>
        <tr><td valign=top>Date</td> <td valign=top>-</td> <td valign=top>duration</td> <td valign=top>--&gt;</td> <td valign=top>Date</td></tr>
        </table>

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>duration</td>
<td valign=top>The duration to add to or subtract from this <span class="d_inlinecode">Date</span>.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">const pure nothrow Duration <a name="opBinary"></a><u>opBinary</u>(string op)(in Date <i>rhs</i>);
</div></dt>
<dd>Gives the difference between two <span class="d_inlinecode">Date</span>s.
<p></p>
The legal types of arithmetic for Date using this operator are
<p></p>


        <table cellspacing=0 cellpadding=5><caption>       <tr><td valign=top>Date</td> <td valign=top>-</td> <td valign=top>Date</td> <td valign=top>--&gt;</td> <td valign=top>duration</td></tr>
        </caption>       <tr><td valign=top>Date</td> <td valign=top>-</td> <td valign=top>Date</td> <td valign=top>--&gt;</td> <td valign=top>duration</td></tr>
        </table><p></p>

</dd>
<dt><div class="d_decl">const pure nothrow int <a name="diffMonths"></a><u>diffMonths</u>(in Date <i>rhs</i>);
</div></dt>
<dd>Returns the difference between the two <span class="d_inlinecode">Date</span>s in months.
<p></p>
You can get the difference in years by subtracting the year property
        of two <span class="d_inlinecode">Date</span>s, and you can get the difference in days or weeks by
        subtracting the <span class="d_inlinecode">Date</span>s themselves and using the <span class="d_inlinecode">Duration</span> that
        results, but because you cannot convert between months and smaller units
        without a specific date (which <span class="d_inlinecode">Duration</span>s don't have), you cannot
        get the difference in months without doing some math using both the year
        and month properties, so this is a convenience function for getting the
        difference in months.
<p></p>


        Note that the number of days in the months or how far into the month
        either <span class="d_inlinecode">Date</span> is is irrelevant. It is the difference in the month
        property combined with the difference in years * 12. So, for instance,
        December 31st and January 1st are one month apart just as December 1st
        and January 31st are one month apart.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Date <i>rhs</i></td>
<td valign=top>The <span class="d_inlinecode">Date</span> to subtract from this one.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(Date(1999, 2, 1).<span class="d_psymbol">diffMonths</span>(Date(1999, 1, 31)) == 1);
<span class="d_keyword">assert</span>(Date(1999, 1, 31).<span class="d_psymbol">diffMonths</span>(Date(1999, 2, 1)) == -1);
<span class="d_keyword">assert</span>(Date(1999, 3, 1).<span class="d_psymbol">diffMonths</span>(Date(1999, 1, 1)) == 2);
<span class="d_keyword">assert</span>(Date(1999, 1, 1).<span class="d_psymbol">diffMonths</span>(Date(1999, 3, 31)) == -2);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property bool <a name="isLeapYear"></a><u>isLeapYear</u>();
</div></dt>
<dd>Whether this <span class="d_inlinecode">Date</span> is in a leap year.<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property DayOfWeek <a name="dayOfWeek"></a><u>dayOfWeek</u>();
</div></dt>
<dd>Day of the week this <span class="d_inlinecode">Date</span> is on.<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property ushort <a name="dayOfYear"></a><u>dayOfYear</u>();
</div></dt>
<dd>Day of the year this <span class="d_inlinecode">Date</span> is on.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(Date(1999, 1, 1).<span class="d_psymbol">dayOfYear</span> == 1);
<span class="d_keyword">assert</span>(Date(1999, 12, 31).<span class="d_psymbol">dayOfYear</span> == 365);
<span class="d_keyword">assert</span>(Date(2000, 12, 31).<span class="d_psymbol">dayOfYear</span> == 366);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">pure @property void <a name="dayOfYear"></a><u>dayOfYear</u>(int <i>day</i>);
</div></dt>
<dd>Day of the year.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>int <i>day</i></td>
<td valign=top>The <i>day</i> of the year to set which <i>day</i> of the year this
                  <span class="d_inlinecode">Date</span> is on.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given <i>day</i> is an invalid <i>day</i> of the
            year.<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property int <a name="dayOfGregorianCal"></a><u>dayOfGregorianCal</u>();
</div></dt>
<dd>The Xth day of the Gregorian Calendar that this <span class="d_inlinecode">Date</span> is on.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(Date(1, 1, 1).<span class="d_psymbol">dayOfGregorianCal</span> == 1);
<span class="d_keyword">assert</span>(Date(1, 12, 31).<span class="d_psymbol">dayOfGregorianCal</span> == 365);
<span class="d_keyword">assert</span>(Date(2, 1, 1).<span class="d_psymbol">dayOfGregorianCal</span> == 366);

<span class="d_keyword">assert</span>(Date(0, 12, 31).<span class="d_psymbol">dayOfGregorianCal</span> == 0);
<span class="d_keyword">assert</span>(Date(0, 1, 1).<span class="d_psymbol">dayOfGregorianCal</span> == -365);
<span class="d_keyword">assert</span>(Date(-1, 12, 31).<span class="d_psymbol">dayOfGregorianCal</span> == -366);

<span class="d_keyword">assert</span>(Date(2000, 1, 1).<span class="d_psymbol">dayOfGregorianCal</span> == 730_120);
<span class="d_keyword">assert</span>(Date(2010, 12, 31).<span class="d_psymbol">dayOfGregorianCal</span> == 734_137);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">pure nothrow @property void <a name="dayOfGregorianCal"></a><u>dayOfGregorianCal</u>(int <i>day</i>);
</div></dt>
<dd>The Xth <i>day</i> of the Gregorian Calendar that this <span class="d_inlinecode">Date</span> is on.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>int <i>day</i></td>
<td valign=top>The <i>day</i> of the Gregorian Calendar to set this <span class="d_inlinecode">Date</span> to.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> date = Date.init;
date.<span class="d_psymbol">dayOfGregorianCal</span> = 1;
<span class="d_keyword">assert</span>(date == Date(1, 1, 1));

date.<span class="d_psymbol">dayOfGregorianCal</span> = 365;
<span class="d_keyword">assert</span>(date == Date(1, 12, 31));

date.<span class="d_psymbol">dayOfGregorianCal</span> = 366;
<span class="d_keyword">assert</span>(date == Date(2, 1, 1));

date.<span class="d_psymbol">dayOfGregorianCal</span> = 0;
<span class="d_keyword">assert</span>(date == Date(0, 12, 31));

date.<span class="d_psymbol">dayOfGregorianCal</span> = -365;
<span class="d_keyword">assert</span>(date == Date(-0, 1, 1));

date.<span class="d_psymbol">dayOfGregorianCal</span> = -366;
<span class="d_keyword">assert</span>(date == Date(-1, 12, 31));

date.<span class="d_psymbol">dayOfGregorianCal</span> = 730_120;
<span class="d_keyword">assert</span>(date == Date(2000, 1, 1));

date.<span class="d_psymbol">dayOfGregorianCal</span> = 734_137;
<span class="d_keyword">assert</span>(date == Date(2010, 12, 31));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property ubyte <a name="isoWeek"></a><u>isoWeek</u>();
</div></dt>
<dd>The ISO 8601 week of the year that this <span class="d_inlinecode">Date</span> is in.
<p></p>
<b>See Also:</b><br><a href="http://en.wikipedia.org/wiki/ISO_week_date">ISO Week Date</a><p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property Date <a name="endOfMonth"></a><u>endOfMonth</u>();
</div></dt>
<dd><span class="d_inlinecode">Date</span> for the last day in the month that this <span class="d_inlinecode">Date</span> is in.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(Date(1999, 1, 6).<span class="d_psymbol">endOfMonth</span> == Date(1999, 1, 31));
<span class="d_keyword">assert</span>(Date(1999, 2, 7).<span class="d_psymbol">endOfMonth</span> == Date(1999, 2, 28));
<span class="d_keyword">assert</span>(Date(2000, 2, 7).<span class="d_psymbol">endOfMonth</span> == Date(1999, 2, 29));
<span class="d_keyword">assert</span>(Date(2000, 6, 4).<span class="d_psymbol">endOfMonth</span> == Date(1999, 6, 30));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property ubyte <a name="daysInMonth"></a><u>daysInMonth</u>();
</div></dt>
<dd>The last day in the month that this <span class="d_inlinecode">Date</span> is in.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(Date(1999, 1, 6).<span class="d_psymbol">daysInMonth</span> == 31);
<span class="d_keyword">assert</span>(Date(1999, 2, 7).<span class="d_psymbol">daysInMonth</span> == 28);
<span class="d_keyword">assert</span>(Date(2000, 2, 7).<span class="d_psymbol">daysInMonth</span> == 29);
<span class="d_keyword">assert</span>(Date(2000, 6, 4).<span class="d_psymbol">daysInMonth</span> == 30);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">alias <a name="endofMonthDay"></a><u>endofMonthDay</u>;
</div></dt>
<dd><span style="color:red">Scheduled for deprecation in January 2012.
              Please use daysInMonth instead.</span><p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property bool <a name="isAD"></a><u>isAD</u>();
</div></dt>
<dd>Whether the current year is a date in A.D.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(Date(1, 1, 1).<span class="d_psymbol">isAD</span>);
<span class="d_keyword">assert</span>(Date(2010, 12, 31).<span class="d_psymbol">isAD</span>);
<span class="d_keyword">assert</span>(!Date(0, 12, 31).<span class="d_psymbol">isAD</span>);
<span class="d_keyword">assert</span>(!Date(-2010, 1, 1).<span class="d_psymbol">isAD</span>);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property long <a name="julianDay"></a><u>julianDay</u>();
</div></dt>
<dd>The julian day for this <span class="d_inlinecode">Date</span> at noon (since the julian day changes
        at noon).<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property long <a name="modJulianDay"></a><u>modJulianDay</u>();
</div></dt>
<dd>The modified julian day for any time on this date (since, the modified
        julian day changes at midnight).<p></p>

</dd>
<dt><div class="d_decl">const nothrow string <a name="toISOString"></a><u>toISOString</u>();
</div></dt>
<dd>Converts this <span class="d_inlinecode">Date</span> to a string with the format YYYYMMDD.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(Date(2010, 7, 4).<span class="d_psymbol">toISOString</span>() == <span class="d_string">"20100704"</span>);
<span class="d_keyword">assert</span>(Date(1998, 12, 25).<span class="d_psymbol">toISOString</span>() == <span class="d_string">"19981225"</span>);
<span class="d_keyword">assert</span>(Date(0, 1, 5).<span class="d_psymbol">toISOString</span>() == <span class="d_string">"00000105"</span>);
<span class="d_keyword">assert</span>(Date(-4, 1, 5).<span class="d_psymbol">toISOString</span>() == <span class="d_string">"-00040105"</span>);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const nothrow string <a name="toISOExtString"></a><u>toISOExtString</u>();
</div></dt>
<dd>Converts this <span class="d_inlinecode">Date</span> to a string with the format YYYY-MM-DD.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(Date(2010, 7, 4).<span class="d_psymbol">toISOExtString</span>() == <span class="d_string">"2010-07-04"</span>);
<span class="d_keyword">assert</span>(Date(1998, 12, 25).<span class="d_psymbol">toISOExtString</span>() == <span class="d_string">"1998-12-25"</span>);
<span class="d_keyword">assert</span>(Date(0, 1, 5).<span class="d_psymbol">toISOExtString</span>() == <span class="d_string">"0000-01-05"</span>);
<span class="d_keyword">assert</span>(Date(-4, 1, 5).<span class="d_psymbol">toISOExtString</span>() == <span class="d_string">"-0004-01-05"</span>);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">alias <a name="toISOExtendedString"></a><u>toISOExtendedString</u>;
</div></dt>
<dd><span style="color:red">Scheduled for deprecation in November 2011.
              Please use toISOExtString instead.</span><p></p>

</dd>
<dt><div class="d_decl">const nothrow string <a name="toSimpleString"></a><u>toSimpleString</u>();
</div></dt>
<dd>Converts this <span class="d_inlinecode">Date</span> to a string with the format YYYY-Mon-DD.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(Date(2010, 7, 4).<span class="d_psymbol">toSimpleString</span>() == <span class="d_string">"2010-Jul-04"</span>);
<span class="d_keyword">assert</span>(Date(1998, 12, 25).<span class="d_psymbol">toSimpleString</span>() == <span class="d_string">"1998-Dec-25"</span>);
<span class="d_keyword">assert</span>(Date(0, 1, 5).<span class="d_psymbol">toSimpleString</span>() == <span class="d_string">"0000-Jan-05"</span>);
<span class="d_keyword">assert</span>(Date(-4, 1, 5).<span class="d_psymbol">toSimpleString</span>() == <span class="d_string">"-0004-Jan-05"</span>);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const nothrow string <a name="toString"></a><u>toString</u>();
</div></dt>
<dd>Converts this <span class="d_inlinecode">Date</span> to a string.<p></p>

</dd>
<dt><div class="d_decl">Date <a name="fromISOString"></a><u>fromISOString</u>(S)(in S <i>isoString</i>);
</div></dt>
<dd>Creates a <span class="d_inlinecode">Date</span> from a string with the format YYYYMMDD. Whitespace
        is stripped from the given string.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>isoString</td>
<td valign=top>A string formatted in the ISO format for dates.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given string is not in the ISO format
            or if the resulting <span class="d_inlinecode">Date</span> would not be valid.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(Date.<span class="d_psymbol">fromISOString</span>(<span class="d_string">"20100704"</span>) == Date(2010, 7, 4));
<span class="d_keyword">assert</span>(Date.<span class="d_psymbol">fromISOString</span>(<span class="d_string">"19981225"</span>) == Date(1998, 12, 25));
<span class="d_keyword">assert</span>(Date.<span class="d_psymbol">fromISOString</span>(<span class="d_string">"00000105"</span>) == Date(0, 1, 5));
<span class="d_keyword">assert</span>(Date.<span class="d_psymbol">fromISOString</span>(<span class="d_string">"-00040105"</span>) == Date(-4, 1, 5));
<span class="d_keyword">assert</span>(Date.<span class="d_psymbol">fromISOString</span>(<span class="d_string">" 20100704 "</span>) == Date(2010, 7, 4));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">Date <a name="fromISOExtString"></a><u>fromISOExtString</u>(S)(in S <i>isoExtString</i>);
</div></dt>
<dd>Creates a <span class="d_inlinecode">Date</span> from a string with the format YYYY-MM-DD. Whitespace
        is stripped from the given string.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>isoExtString</td>
<td valign=top>A string formatted in the ISO Extended format for
                           dates.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given string is not in the ISO
            Extended format or if the resulting <span class="d_inlinecode">Date</span> would not be valid.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(Date.<span class="d_psymbol">fromISOExtString</span>(<span class="d_string">"2010-07-04"</span>) == Date(2010, 7, 4));
<span class="d_keyword">assert</span>(Date.<span class="d_psymbol">fromISOExtString</span>(<span class="d_string">"1998-12-25"</span>) == Date(1998, 12, 25));
<span class="d_keyword">assert</span>(Date.<span class="d_psymbol">fromISOExtString</span>(<span class="d_string">"0000-01-05"</span>) == Date(0, 1, 5));
<span class="d_keyword">assert</span>(Date.<span class="d_psymbol">fromISOExtString</span>(<span class="d_string">"-0004-01-05"</span>) == Date(-4, 1, 5));
<span class="d_keyword">assert</span>(Date.<span class="d_psymbol">fromISOExtString</span>(<span class="d_string">" 2010-07-04 "</span>) == Date(2010, 7, 4));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">Date <a name="fromISOExtendedString"></a><u>fromISOExtendedString</u>(S)(in S <i>isoExtString</i>);
</div></dt>
<dd><span style="color:red">Scheduled for deprecation in November 2011.
              Please use fromISOExtString instead.</span><p></p>

</dd>
<dt><div class="d_decl">Date <a name="fromSimpleString"></a><u>fromSimpleString</u>(S)(in S <i>simpleString</i>);
</div></dt>
<dd>Creates a <span class="d_inlinecode">Date</span> from a string with the format YYYY-Mon-DD.
        Whitespace is stripped from the given string.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>simpleString</td>
<td valign=top>A string formatted in the way that toSimpleString
                           formats dates.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given string is not in the correct
            format or if the resulting <span class="d_inlinecode">Date</span> would not be valid.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(Date.<span class="d_psymbol">fromSimpleString</span>(<span class="d_string">"2010-Jul-04"</span>) == Date(2010, 7, 4));
<span class="d_keyword">assert</span>(Date.<span class="d_psymbol">fromSimpleString</span>(<span class="d_string">"1998-Dec-25"</span>) == Date(1998, 12, 25));
<span class="d_keyword">assert</span>(Date.<span class="d_psymbol">fromSimpleString</span>(<span class="d_string">"0000-Jan-05"</span>) == Date(0, 1, 5));
<span class="d_keyword">assert</span>(Date.<span class="d_psymbol">fromSimpleString</span>(<span class="d_string">"-0004-Jan-05"</span>) == Date(-4, 1, 5));
<span class="d_keyword">assert</span>(Date.<span class="d_psymbol">fromSimpleString</span>(<span class="d_string">" 2010-Jul-04 "</span>) == Date(2010, 7, 4));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">static pure nothrow @property Date <a name="min"></a><u>min</u>();
</div></dt>
<dd>Returns the <span class="d_inlinecode">Date</span> farthest in the past which is representable by
        <span class="d_inlinecode">Date</span>.<p></p>

</dd>
<dt><div class="d_decl">static pure nothrow @property Date <a name="max"></a><u>max</u>();
</div></dt>
<dd>Returns the <span class="d_inlinecode">Date</span> farthest in the future which is representable by
        <span class="d_inlinecode">Date</span>.<p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">struct <a name="TimeOfDay"></a><u>TimeOfDay</u>;
</div></dt>
<dd>Represents a time of day with hours, minutes, and seconds. It uses 24 hour
    time.<p></p>

<dl><dt><div class="d_decl">pure  this(int <i>hour</i>, int <i>minute</i>, int <i>second</i> = 0);
</div></dt>
<dd><b>Parameters:</b><table class=parms><tr><td valign=top>int <i>hour</i></td>
<td valign=top>Hour of the day [0 - 24).</td></tr>
<tr><td valign=top>int <i>minute</i></td>
<td valign=top>Minute of the <i>hour</i> [0 - 60).</td></tr>
<tr><td valign=top>int <i>second</i></td>
<td valign=top>Second of the <i>minute</i> [0 - 60).</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the resulting <span class="d_inlinecode">TimeOfDay</span> would be not
            be valid.<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow int <a name="opCmp"></a><u>opCmp</u>(in TimeOfDay <i>rhs</i>);
</div></dt>
<dd>Compares this <span class="d_inlinecode">TimeOfDay</span> with the given <span class="d_inlinecode">TimeOfDay</span>.
<p></p>
<b>Returns:</b><br><table cellspacing=0 cellpadding=5><caption>           <tr><td valign=top>this &lt; <i>rhs</i></td> <td valign=top>&lt; 0</td></tr>
            <tr><td valign=top>this == <i>rhs</i></td> <td valign=top>0</td></tr>
            <tr><td valign=top>this &gt; <i>rhs</i></td> <td valign=top>&gt; 0</td></tr>
            </caption>           <tr><td valign=top>this &lt; <i>rhs</i></td> <td valign=top>&lt; 0</td></tr>
            <tr><td valign=top>this == <i>rhs</i></td> <td valign=top>0</td></tr>
            <tr><td valign=top>this &gt; <i>rhs</i></td> <td valign=top>&gt; 0</td></tr>
            </table><p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property ubyte <a name="hour"></a><u>hour</u>();
</div></dt>
<dd>Hours passed midnight.<p></p>

</dd>
<dt><div class="d_decl">pure @property void <a name="hour"></a><u>hour</u>(int <a name="hour"></a><u>hour</u>);
</div></dt>
<dd>Hours passed midnight.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>int <a name="hour"></a><u>hour</u></td>
<td valign=top>The <a name="hour"></a><u>hour</u> of the day to set this <span class="d_inlinecode">TimeOfDay</span>'s <a name="hour"></a><u>hour</u> to.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given <a name="hour"></a><u>hour</u> would result in an invalid
            <span class="d_inlinecode">TimeOfDay</span>.<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property ubyte <a name="minute"></a><u>minute</u>();
</div></dt>
<dd>Minutes passed the hour.<p></p>

</dd>
<dt><div class="d_decl">pure @property void <a name="minute"></a><u>minute</u>(int <a name="minute"></a><u>minute</u>);
</div></dt>
<dd>Minutes passed the hour.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>int <a name="minute"></a><u>minute</u></td>
<td valign=top>The <a name="minute"></a><u>minute</u> to set this <span class="d_inlinecode">TimeOfDay</span>'s <a name="minute"></a><u>minute</u> to.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given <a name="minute"></a><u>minute</u> would result in an
            invalid <span class="d_inlinecode">TimeOfDay</span>.<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property ubyte <a name="second"></a><u>second</u>();
</div></dt>
<dd>Seconds passed the minute.<p></p>

</dd>
<dt><div class="d_decl">pure @property void <a name="second"></a><u>second</u>(int <a name="second"></a><u>second</u>);
</div></dt>
<dd>Seconds passed the minute.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>int <a name="second"></a><u>second</u></td>
<td valign=top>The <a name="second"></a><u>second</u> to set this <span class="d_inlinecode">TimeOfDay</span>'s <a name="second"></a><u>second</u> to.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given <a name="second"></a><u>second</u> would result in an
            invalid <span class="d_inlinecode">TimeOfDay</span>.<p></p>

</dd>
<dt><div class="d_decl">pure nothrow void <a name="roll"></a><u>roll</u>(string units)(long <i>value</i>);
</div></dt>
<dd>Adds the given number of units to this <span class="d_inlinecode">TimeOfDay</span>. A negative number
        will subtract.
<p></p>
The difference between rolling and adding is that rolling does not
        affect larger units. So, for instance, if you <a name="roll"></a><u>roll</u> a <span class="d_inlinecode">TimeOfDay</span>
        one hours's worth of minutes, then you get the exact same
        <span class="d_inlinecode">TimeOfDay</span>.
<p></p>


        Accepted units are <span class="d_inlinecode">"hours"</span>, <span class="d_inlinecode">"minutes"</span>, and <span class="d_inlinecode">"seconds"</span>.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>units</td>
<td valign=top>The units to add.</td></tr>
<tr><td valign=top>value</td>
<td valign=top>The number of <span class="d_param">units</span> to add to this
                    <span class="d_inlinecode">TimeOfDay</span>.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> tod1 = TimeOfDay(7, 12, 0);
tod1.<span class="d_psymbol">roll</span>!<span class="d_string">"hours"</span>(1);
<span class="d_keyword">assert</span>(tod1 == TimeOfDay(8, 12, 0));

<span class="d_keyword">auto</span> tod2 = TimeOfDay(7, 12, 0);
tod2.<span class="d_psymbol">roll</span>!<span class="d_string">"hours"</span>(-1);
<span class="d_keyword">assert</span>(tod2 == TimeOfDay(6, 12, 0));

<span class="d_keyword">auto</span> tod3 = TimeOfDay(23, 59, 0);
tod3.<span class="d_psymbol">roll</span>!<span class="d_string">"minutes"</span>(1);
<span class="d_keyword">assert</span>(tod3 == TimeOfDay(23, 0, 0));

<span class="d_keyword">auto</span> tod4 = TimeOfDay(0, 0, 0);
tod4.<span class="d_psymbol">roll</span>!<span class="d_string">"minutes"</span>(-1);
<span class="d_keyword">assert</span>(tod4 == TimeOfDay(0, 59, 0));

<span class="d_keyword">auto</span> tod5 = TimeOfDay(23, 59, 59);
tod5.<span class="d_psymbol">roll</span>!<span class="d_string">"seconds"</span>(1);
<span class="d_keyword">assert</span>(tod5 == TimeOfDay(23, 59, 0));

<span class="d_keyword">auto</span> tod6 = TimeOfDay(0, 0, 0);
tod6.<span class="d_psymbol">roll</span>!<span class="d_string">"seconds"</span>(-1);
<span class="d_keyword">assert</span>(tod6 == TimeOfDay(0, 0, 59));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow TimeOfDay <a name="opBinary"></a><u>opBinary</u>(string op, D)(in D <i>duration</i>);
</div></dt>
<dd>Gives the result of adding or subtracting a duration from this
        <span class="d_inlinecode">TimeOfDay</span>.
<p></p>
The legal types of arithmetic for <span class="d_inlinecode">TimeOfDay</span> using this operator are
<p></p>


        <table cellspacing=0 cellpadding=5><caption>       <tr><td valign=top>TimeOfDay</td> <td valign=top>+</td> <td valign=top>duration</td> <td valign=top>--&gt;</td> <td valign=top>TimeOfDay</td></tr>
        <tr><td valign=top>TimeOfDay</td> <td valign=top>-</td> <td valign=top>duration</td> <td valign=top>--&gt;</td> <td valign=top>TimeOfDay</td></tr>
        </caption>       <tr><td valign=top>TimeOfDay</td> <td valign=top>+</td> <td valign=top>duration</td> <td valign=top>--&gt;</td> <td valign=top>TimeOfDay</td></tr>
        <tr><td valign=top>TimeOfDay</td> <td valign=top>-</td> <td valign=top>duration</td> <td valign=top>--&gt;</td> <td valign=top>TimeOfDay</td></tr>
        </table>

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>duration</td>
<td valign=top>The duration to add to or subtract from this
                       <span class="d_inlinecode">TimeOfDay</span>.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">pure nothrow TimeOfDay <a name="opOpAssign"></a><u>opOpAssign</u>(string op, D)(in D <i>duration</i>);
</div></dt>
<dd>Gives the result of adding or subtracting a duration from this
        <span class="d_inlinecode">TimeOfDay</span>, as well as assigning the result to this
        <span class="d_inlinecode">TimeOfDay</span>.
<p></p>
The legal types of arithmetic for <span class="d_inlinecode">TimeOfDay</span> using this operator are
<p></p>


        <table cellspacing=0 cellpadding=5><caption>       <tr><td valign=top>TimeOfDay</td> <td valign=top>+</td> <td valign=top>duration</td> <td valign=top>--&gt;</td> <td valign=top>TimeOfDay</td></tr>
        <tr><td valign=top>TimeOfDay</td> <td valign=top>-</td> <td valign=top>duration</td> <td valign=top>--&gt;</td> <td valign=top>TimeOfDay</td></tr>
        </caption>       <tr><td valign=top>TimeOfDay</td> <td valign=top>+</td> <td valign=top>duration</td> <td valign=top>--&gt;</td> <td valign=top>TimeOfDay</td></tr>
        <tr><td valign=top>TimeOfDay</td> <td valign=top>-</td> <td valign=top>duration</td> <td valign=top>--&gt;</td> <td valign=top>TimeOfDay</td></tr>
        </table>

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>duration</td>
<td valign=top>The duration to add to or subtract from this
                       <span class="d_inlinecode">TimeOfDay</span>.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">const pure nothrow Duration <a name="opBinary"></a><u>opBinary</u>(string op)(in TimeOfDay <i>rhs</i>);
</div></dt>
<dd>Gives the difference between two <span class="d_inlinecode">TimeOfDay</span>s.
<p></p>
The legal types of arithmetic for <span class="d_inlinecode">TimeOfDay</span> using this operator are
<p></p>


        <table cellspacing=0 cellpadding=5><caption>       <tr><td valign=top>TimeOfDay</td> <td valign=top>-</td> <td valign=top>TimeOfDay</td> <td valign=top>--&gt;</td> <td valign=top>duration</td></tr>
        </caption>       <tr><td valign=top>TimeOfDay</td> <td valign=top>-</td> <td valign=top>TimeOfDay</td> <td valign=top>--&gt;</td> <td valign=top>duration</td></tr>
        </table>

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>rhs</td>
<td valign=top>The <span class="d_inlinecode">TimeOfDay</span> to subtract from this one.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">const nothrow string <a name="toISOString"></a><u>toISOString</u>();
</div></dt>
<dd>Converts this <span class="d_inlinecode">TimeOfDay</span> to a string with the format HHMMSS.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(TimeOfDay(0, 0, 0).<span class="d_psymbol">toISOString</span>() == <span class="d_string">"000000"</span>);
<span class="d_keyword">assert</span>(TimeOfDay(12, 30, 33).<span class="d_psymbol">toISOString</span>() == <span class="d_string">"123033"</span>);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const nothrow string <a name="toISOExtString"></a><u>toISOExtString</u>();
</div></dt>
<dd>Converts this <span class="d_inlinecode">TimeOfDay</span> to a string with the format HH:MM:SS.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(TimeOfDay(0, 0, 0).<span class="d_psymbol">toISOExtString</span>() == <span class="d_string">"000000"</span>);
<span class="d_keyword">assert</span>(TimeOfDay(12, 30, 33).<span class="d_psymbol">toISOExtString</span>() == <span class="d_string">"123033"</span>);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">alias <a name="toISOExtendedString"></a><u>toISOExtendedString</u>;
</div></dt>
<dd><span style="color:red">Scheduled for deprecation in November 2011.
              Please use toISOExtString instead.</span><p></p>

</dd>
<dt><div class="d_decl">const nothrow string <a name="toString"></a><u>toString</u>();
</div></dt>
<dd>Converts this TimeOfDay to a string.<p></p>

</dd>
<dt><div class="d_decl">TimeOfDay <a name="fromISOString"></a><u>fromISOString</u>(S)(in S <i>isoString</i>);
</div></dt>
<dd>Creates a <span class="d_inlinecode">TimeOfDay</span> from a string with the format HHMMSS.
        Whitespace is stripped from the given string.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>isoString</td>
<td valign=top>A string formatted in the ISO format for times.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given string is not in the ISO format
            or if the resulting <span class="d_inlinecode">TimeOfDay</span> would not be valid.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(TimeOfDay.<span class="d_psymbol">fromISOString</span>(<span class="d_string">"000000"</span>) == TimeOfDay(0, 0, 0));
<span class="d_keyword">assert</span>(TimeOfDay.<span class="d_psymbol">fromISOString</span>(<span class="d_string">"123033"</span>) == TimeOfDay(12, 30, 33));
<span class="d_keyword">assert</span>(TimeOfDay.<span class="d_psymbol">fromISOString</span>(<span class="d_string">" 123033 "</span>) == TimeOfDay(12, 30, 33));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">TimeOfDay <a name="fromISOExtString"></a><u>fromISOExtString</u>(S)(in S <i>isoExtString</i>);
</div></dt>
<dd>Creates a <span class="d_inlinecode">TimeOfDay</span> from a string with the format HH:MM:SS.
        Whitespace is stripped from the given string.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>isoString</td>
<td valign=top>A string formatted in the ISO Extended format for times.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given string is not in the ISO
            Extended format or if the resulting <span class="d_inlinecode">TimeOfDay</span> would not be
            valid.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(TimeOfDay.<span class="d_psymbol">fromISOExtString</span>(<span class="d_string">"00:00:00"</span>) == TimeOfDay(0, 0, 0));
<span class="d_keyword">assert</span>(TimeOfDay.<span class="d_psymbol">fromISOExtString</span>(<span class="d_string">"12:30:33"</span>) == TimeOfDay(12, 30, 33));
<span class="d_keyword">assert</span>(TimeOfDay.<span class="d_psymbol">fromISOExtString</span>(<span class="d_string">" 12:30:33 "</span>) == TimeOfDay(12, 30, 33));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">TimeOfDay <a name="fromISOExtendedString"></a><u>fromISOExtendedString</u>(S)(in S <i>isoExtString</i>);
</div></dt>
<dd><span style="color:red">Scheduled for deprecation in November 2011.
              Please use fromISOExtString instead.</span><p></p>

</dd>
<dt><div class="d_decl">static pure nothrow @property TimeOfDay <a name="min"></a><u>min</u>();
</div></dt>
<dd>Returns midnight.<p></p>

</dd>
<dt><div class="d_decl">static pure nothrow @property TimeOfDay <a name="max"></a><u>max</u>();
</div></dt>
<dd>Returns one second short of midnight.<p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">struct <a name="DateTime"></a><u>DateTime</u>;
</div></dt>
<dd>Combines the <span class="d_inlinecode">Date</span> and <span class="d_inlinecode">TimeOfDay</span> structs to give you an object
   which holds both the date and the time. It is optimized for calendar-based
   operations and has no concept of time zone. If you want an object which is
   optimized for time operations based on the system time, then use
   <span class="d_inlinecode">SysTime</span>. <span class="d_inlinecode">SysTime</span> has a concept of time zone and has much higher
   precision (hnsecs). <span class="d_inlinecode"><a name="DateTime"></a><u>DateTime</u></span> is intended primarily for calendar-based
   uses rather than precise time operations.<p></p>

<dl><dt><div class="d_decl">pure nothrow  this(in Date <i>date</i>, in TimeOfDay <i>tod</i> = (TimeOfDay).init);
</div></dt>
<dd><b>Parameters:</b><table class=parms><tr><td valign=top>Date <i>date</i></td>
<td valign=top>The <i>date</i> portion of <span class="d_inlinecode">DateTime</span>.</td></tr>
<tr><td valign=top>TimeOfDay <i>tod</i></td>
<td valign=top>The time portion of <span class="d_inlinecode">DateTime</span>.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">pure  this(int <i>year</i>, int <i>month</i>, int <i>day</i>, int <i>hour</i> = 0, int <i>minute</i> = 0, int <i>second</i> = 0);
</div></dt>
<dd><b>Parameters:</b><table class=parms><tr><td valign=top>int <i>year</i></td>
<td valign=top>The <i>year</i> portion of the date.</td></tr>
<tr><td valign=top>int <i>month</i></td>
<td valign=top>The <i>month</i> portion of the date.</td></tr>
<tr><td valign=top>int <i>day</i></td>
<td valign=top>The <i>day</i> portion of the date.</td></tr>
<tr><td valign=top>int <i>hour</i></td>
<td valign=top>The <i>hour</i> portion of the time;</td></tr>
<tr><td valign=top>int <i>minute</i></td>
<td valign=top>The <i>minute</i> portion of the time;</td></tr>
<tr><td valign=top>int <i>second</i></td>
<td valign=top>The <i>second</i> portion of the time;</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">const pure nothrow int <a name="opCmp"></a><u>opCmp</u>(in DateTime <i>rhs</i>);
</div></dt>
<dd>Compares this <span class="d_inlinecode">DateTime</span> with the given <span class="d_inlinecode">DateTime.</span>.
<p></p>
<b>Returns:</b><br><table cellspacing=0 cellpadding=5><caption>           <tr><td valign=top>this &lt; <i>rhs</i></td> <td valign=top>&lt; 0</td></tr>
            <tr><td valign=top>this == <i>rhs</i></td> <td valign=top>0</td></tr>
            <tr><td valign=top>this &gt; <i>rhs</i></td> <td valign=top>&gt; 0</td></tr>
            </caption>           <tr><td valign=top>this &lt; <i>rhs</i></td> <td valign=top>&lt; 0</td></tr>
            <tr><td valign=top>this == <i>rhs</i></td> <td valign=top>0</td></tr>
            <tr><td valign=top>this &gt; <i>rhs</i></td> <td valign=top>&gt; 0</td></tr>
            </table><p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property Date <a name="date"></a><u>date</u>();
</div></dt>
<dd>The <a name="date"></a><u>date</u> portion of <span class="d_inlinecode">DateTime</span>.<p></p>

</dd>
<dt><div class="d_decl">pure nothrow @property void <a name="date"></a><u>date</u>(in Date <a name="date"></a><u>date</u>);
</div></dt>
<dd>The <a name="date"></a><u>date</u> portion of <span class="d_inlinecode">DateTime</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Date <a name="date"></a><u>date</u></td>
<td valign=top>The Date to set this <span class="d_inlinecode">DateTime</span>'s <a name="date"></a><u>date</u> portion to.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property TimeOfDay <a name="timeOfDay"></a><u>timeOfDay</u>();
</div></dt>
<dd>The time portion of <span class="d_inlinecode">DateTime</span>.<p></p>

</dd>
<dt><div class="d_decl">pure nothrow @property void <a name="timeOfDay"></a><u>timeOfDay</u>(in TimeOfDay <i>tod</i>);
</div></dt>
<dd>The time portion of <span class="d_inlinecode">DateTime</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>TimeOfDay <i>tod</i></td>
<td valign=top>The <span class="d_inlinecode">TimeOfDay</span> to set this <span class="d_inlinecode">DateTime</span>'s time portion
                  to.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property short <a name="year"></a><u>year</u>();
</div></dt>
<dd>Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive
        are B.C.<p></p>

</dd>
<dt><div class="d_decl">pure @property void <a name="year"></a><u>year</u>(int <a name="year"></a><u>year</u>);
</div></dt>
<dd>Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive
        are B.C.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>int <a name="year"></a><u>year</u></td>
<td valign=top>The <a name="year"></a><u>year</u> to set this <span class="d_inlinecode">DateTime</span>'s <a name="year"></a><u>year</u> to.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the new <a name="year"></a><u>year</u> is not a leap <a name="year"></a><u>year</u> and if the
            resulting date would be on February 29th.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(DateTime(Date(1999, 7, 6), TimeOfDay(9, 7, 5)).<span class="d_psymbol">year</span> == 1999);
<span class="d_keyword">assert</span>(DateTime(Date(2010, 10, 4), TimeOfDay(0, 0, 30)).<span class="d_psymbol">year</span> == 2010);
<span class="d_keyword">assert</span>(DateTime(Date(-7, 4, 5), TimeOfDay(7, 45, 2)).<span class="d_psymbol">year</span> == -7);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure @property short <a name="yearBC"></a><u>yearBC</u>();
</div></dt>
<dd>Year B.C. of the Gregorian Calendar counting year 0 as 1 B.C.
<p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if <span class="d_inlinecode">isAD</span> is <b>true</b>.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(DateTime(Date(0, 1, 1), TimeOfDay(12, 30, 33)).<span class="d_psymbol">yearBC</span> == 1);
<span class="d_keyword">assert</span>(DateTime(Date(-1, 1, 1), TimeOfDay(10, 7, 2)).<span class="d_psymbol">yearBC</span> == 2);
<span class="d_keyword">assert</span>(DateTime(Date(-100, 1, 1), TimeOfDay(4, 59, 0)).<span class="d_psymbol">yearBC</span> == 101);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">pure @property void <a name="yearBC"></a><u>yearBC</u>(int <i>year</i>);
</div></dt>
<dd>Year B.C. of the Gregorian Calendar counting <i>year</i> 0 as 1 B.C.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>int <i>year</i></td>
<td valign=top>The <i>year</i> B.C. to set this <span class="d_inlinecode">DateTime</span>'s <i>year</i> to.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if a non-positive value is given.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> dt = DateTime(Date(2010, 1, 1), TimeOfDay(7, 30, 0));
dt.<span class="d_psymbol">yearBC</span> = 1;
<span class="d_keyword">assert</span>(dt == DateTime(Date(0, 1, 1), TimeOfDay(7, 30, 0)));

dt.<span class="d_psymbol">yearBC</span> = 10;
<span class="d_keyword">assert</span>(dt == DateTime(Date(-9, 1, 1), TimeOfDay(7, 30, 0)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property Month <a name="month"></a><u>month</u>();
</div></dt>
<dd>Month of a Gregorian Year.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(DateTime(Date(1999, 7, 6), TimeOfDay(9, 7, 5)).<span class="d_psymbol">month</span> == 7);
<span class="d_keyword">assert</span>(DateTime(Date(2010, 10, 4), TimeOfDay(0, 0, 30)).<span class="d_psymbol">month</span> == 10);
<span class="d_keyword">assert</span>(DateTime(Date(-7, 4, 5), TimeOfDay(7, 45, 2)).<span class="d_psymbol">month</span> == 4);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">pure @property void <a name="month"></a><u>month</u>(Month <a name="month"></a><u>month</u>);
</div></dt>
<dd>Month of a Gregorian Year.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Month <a name="month"></a><u>month</u></td>
<td valign=top>The <a name="month"></a><u>month</u> to set this <span class="d_inlinecode">DateTime</span>'s <a name="month"></a><u>month</u> to.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given <a name="month"></a><u>month</u> is not a valid <a name="month"></a><u>month</u>.<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property ubyte <a name="day"></a><u>day</u>();
</div></dt>
<dd>Day of a Gregorian Month.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(DateTime(Date(1999, 7, 6), TimeOfDay(9, 7, 5)).<span class="d_psymbol">day</span> == 6);
<span class="d_keyword">assert</span>(DateTime(Date(2010, 10, 4), TimeOfDay(0, 0, 30)).<span class="d_psymbol">day</span> == 4);
<span class="d_keyword">assert</span>(DateTime(Date(-7, 4, 5), TimeOfDay(7, 45, 2)).<span class="d_psymbol">day</span> == 5);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">pure @property void <a name="day"></a><u>day</u>(int <a name="day"></a><u>day</u>);
</div></dt>
<dd>Day of a Gregorian Month.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>int <a name="day"></a><u>day</u></td>
<td valign=top>The <a name="day"></a><u>day</u> of the month to set this <span class="d_inlinecode">DateTime</span>'s <a name="day"></a><u>day</u> to.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given <a name="day"></a><u>day</u> is not a valid <a name="day"></a><u>day</u> of the
            current month.<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property ubyte <a name="hour"></a><u>hour</u>();
</div></dt>
<dd>Hours passed midnight.<p></p>

</dd>
<dt><div class="d_decl">pure @property void <a name="hour"></a><u>hour</u>(int <a name="hour"></a><u>hour</u>);
</div></dt>
<dd>Hours passed midnight.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>int <a name="hour"></a><u>hour</u></td>
<td valign=top>The <a name="hour"></a><u>hour</u> of the day to set this <span class="d_inlinecode">DateTime</span>'s <a name="hour"></a><u>hour</u> to.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given <a name="hour"></a><u>hour</u> would result in an invalid
            <span class="d_inlinecode">DateTime</span>.<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property ubyte <a name="minute"></a><u>minute</u>();
</div></dt>
<dd>Minutes passed the hour.<p></p>

</dd>
<dt><div class="d_decl">pure @property void <a name="minute"></a><u>minute</u>(int <a name="minute"></a><u>minute</u>);
</div></dt>
<dd>Minutes passed the hour.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>int <a name="minute"></a><u>minute</u></td>
<td valign=top>The <a name="minute"></a><u>minute</u> to set this <span class="d_inlinecode">DateTime</span>'s <a name="minute"></a><u>minute</u> to.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given <a name="minute"></a><u>minute</u> would result in an
            invalid <span class="d_inlinecode">DateTime</span>.<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property ubyte <a name="second"></a><u>second</u>();
</div></dt>
<dd>Seconds passed the minute.<p></p>

</dd>
<dt><div class="d_decl">pure @property void <a name="second"></a><u>second</u>(int <a name="second"></a><u>second</u>);
</div></dt>
<dd>Seconds passed the minute.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>int <a name="second"></a><u>second</u></td>
<td valign=top>The <a name="second"></a><u>second</u> to set this <span class="d_inlinecode">DateTime</span>'s <a name="second"></a><u>second</u> to.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given seconds would result in an
            invalid <span class="d_inlinecode">DateTime</span>.<p></p>

</dd>
<dt><div class="d_decl">pure nothrow void <a name="add"></a><u>add</u>(string units)(long <i>value</i>, AllowDayOverflow <i>allowOverflow</i> = AllowDayOverflow.yes);
</div></dt>
<dd>Adds the given number of years or months to this <span class="d_inlinecode">DateTime</span>. A
        negative number will subtract.
<p></p>
Note that if day overflow is allowed, and the date with the adjusted
        year/month overflows the number of days in the new month, then the month
        will be incremented by one, and the day set to the number of days
        overflowed. (e.g. if the day were 31 and the new month were June, then
        the month would be incremented to July, and the new day would be 1). If
        day overflow is not allowed, then the day will be set to the last valid
        day in the month (e.g. June 31st would become June 30th).

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>units</td>
<td valign=top>The type of units to <a name="add"></a><u>add</u> ("years" or "months").</td></tr>
<tr><td valign=top>value</td>
<td valign=top>The number of months or years to <a name="add"></a><u>add</u> to this
                            <span class="d_inlinecode">DateTime</span>.</td></tr>
<tr><td valign=top>allowOverflow</td>
<td valign=top>Whether the days should be allowed to overflow,
                            causing the month to increment.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> dt1 = DateTime(2010, 1, 1, 12, 30, 33);
dt1.<span class="d_psymbol">add</span>!<span class="d_string">"months"</span>(11);
<span class="d_keyword">assert</span>(dt1 == DateTime(2010, 12, 1, 12, 30, 33));

<span class="d_keyword">auto</span> dt2 = DateTime(2010, 1, 1, 12, 30, 33);
dt2.<span class="d_psymbol">add</span>!<span class="d_string">"months"</span>(-11);
<span class="d_keyword">assert</span>(dt2 == DateTime(2009, 2, 1, 12, 30, 33));

<span class="d_keyword">auto</span> dt3 = DateTime(2000, 2, 29, 12, 30, 33);
dt3.<span class="d_psymbol">add</span>!<span class="d_string">"years"</span>(1);
<span class="d_keyword">assert</span>(dt3 == DateTime(2001, 3, 1, 12, 30, 33));

<span class="d_keyword">auto</span> dt4 = DateTime(2000, 2, 29, 12, 30, 33);
dt4.<span class="d_psymbol">add</span>!<span class="d_string">"years"</span>(1, AllowDayOverflow.no);
<span class="d_keyword">assert</span>(dt4 == DateTime(2001, 2, 28, 12, 30, 33));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">pure nothrow void <a name="roll"></a><u>roll</u>(string units)(long <i>value</i>, AllowDayOverflow <i>allowOverflow</i> = AllowDayOverflow.yes);
</div></dt>
<dd>Adds the given number of years or months to this <span class="d_inlinecode">DateTime</span>. A
        negative number will subtract.
<p></p>
The difference between rolling and adding is that rolling does not
        affect larger units. So, if you <a name="roll"></a><u>roll</u> a <span class="d_inlinecode">DateTime</span> 12 months, you
        get the exact same <span class="d_inlinecode">DateTime</span>. However, the days can still be
        affected due to the differing number of days in each month.
<p></p>


        Because there are no units larger than years, there is no difference
        between adding and rolling years.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>units</td>
<td valign=top>The type of units to add ("years" or "months").</td></tr>
<tr><td valign=top>value</td>
<td valign=top>The number of months or years to add to this
                            <span class="d_inlinecode">DateTime</span>.</td></tr>
<tr><td valign=top>allowOverflow</td>
<td valign=top>Whether the days should be allowed to overflow,
                            causing the month to increment.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> dt1 = DateTime(2010, 1, 1, 12, 33, 33);
dt1.<span class="d_psymbol">roll</span>!<span class="d_string">"months"</span>(1);
<span class="d_keyword">assert</span>(dt1 == DateTime(2010, 2, 1, 12, 33, 33));

<span class="d_keyword">auto</span> dt2 = DateTime(2010, 1, 1, 12, 33, 33);
dt2.<span class="d_psymbol">roll</span>!<span class="d_string">"months"</span>(-1);
<span class="d_keyword">assert</span>(dt2 == DateTime(2010, 12, 1, 12, 33, 33));

<span class="d_keyword">auto</span> dt3 = DateTime(1999, 1, 29, 12, 33, 33);
dt3.<span class="d_psymbol">roll</span>!<span class="d_string">"months"</span>(1);
<span class="d_keyword">assert</span>(dt3 == DateTime(1999, 3, 1, 12, 33, 33));

<span class="d_keyword">auto</span> dt4 = DateTime(1999, 1, 29, 12, 33, 33);
dt4.<span class="d_psymbol">roll</span>!<span class="d_string">"months"</span>(1, AllowDayOverflow.no);
<span class="d_keyword">assert</span>(dt4 == DateTime(1999, 2, 28, 12, 33, 33));

<span class="d_keyword">auto</span> dt5 = DateTime(2000, 2, 29, 12, 30, 33);
dt5.<span class="d_psymbol">roll</span>!<span class="d_string">"years"</span>(1);
<span class="d_keyword">assert</span>(dt5 == DateTime(2001, 3, 1, 12, 30, 33));

<span class="d_keyword">auto</span> dt6 = DateTime(2000, 2, 29, 12, 30, 33);
dt6.<span class="d_psymbol">roll</span>!<span class="d_string">"years"</span>(1, AllowDayOverflow.no);
<span class="d_keyword">assert</span>(dt6 == DateTime(2001, 2, 28, 12, 30, 33));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">pure nothrow void <a name="roll"></a><u>roll</u>(string units)(long <i>days</i>);
</div></dt>
<dd>Adds the given number of units to this <span class="d_inlinecode">DateTime</span>. A negative number
        will subtract.
<p></p>
The difference between rolling and adding is that rolling does not
        affect larger units. So, for instance, if you <a name="roll"></a><u>roll</u> a <span class="d_inlinecode">DateTime</span> one
        year's worth of days, then you get the exact same <span class="d_inlinecode">DateTime</span>.
<p></p>


        Accepted units are <span class="d_inlinecode">"days"</span>, <span class="d_inlinecode">"minutes"</span>, <span class="d_inlinecode">"hours"</span>,
        <span class="d_inlinecode">"minutes"</span>, and <span class="d_inlinecode">"seconds"</span>.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>units</td>
<td valign=top>The units to add.</td></tr>
<tr><td valign=top>value</td>
<td valign=top>The number of <span class="d_param">units</span> to add to this <span class="d_inlinecode">DateTime</span>.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> dt1 = DateTime(2010, 1, 1, 11, 23, 12);
dt1.<span class="d_psymbol">roll</span>!<span class="d_string">"days"</span>(1);
<span class="d_keyword">assert</span>(dt1 == DateTime(2010, 1, 2, 11, 23, 12));
dt1.<span class="d_psymbol">roll</span>!<span class="d_string">"days"</span>(365);
<span class="d_keyword">assert</span>(dt1 == DateTime(2010, 1, 26, 11, 23, 12));
dt1.<span class="d_psymbol">roll</span>!<span class="d_string">"days"</span>(-32);
<span class="d_keyword">assert</span>(dt1 == DateTime(2010, 1, 25, 11, 23, 12));

<span class="d_keyword">auto</span> dt2 = DateTime(2010, 7, 4, 12, 0, 0);
dt2.<span class="d_psymbol">roll</span>!<span class="d_string">"hours"</span>(1);
<span class="d_keyword">assert</span>(dt2 == DateTime(2010, 7, 4, 13, 0, 0));

<span class="d_keyword">auto</span> dt3 = DateTime(2010, 1, 1, 0, 0, 0);
dt3.<span class="d_psymbol">roll</span>!<span class="d_string">"seconds"</span>(-1);
<span class="d_keyword">assert</span>(dt3 == DateTime(2010, 1, 1, 0, 0, 59));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow DateTime <a name="opBinary"></a><u>opBinary</u>(string op, D)(in D <i>duration</i>);
</div></dt>
<dd>Gives the result of adding or subtracting a duration from this
        <span class="d_inlinecode">DateTime</span>.
<p></p>
The legal types of arithmetic for <span class="d_inlinecode">DateTime</span> using this operator are
<p></p>


        <table cellspacing=0 cellpadding=5><caption>       <tr><td valign=top>DateTime</td> <td valign=top>+</td> <td valign=top>duration</td> <td valign=top>--&gt;</td> <td valign=top>DateTime</td></tr>
        <tr><td valign=top>DateTime</td> <td valign=top>-</td> <td valign=top>duration</td> <td valign=top>--&gt;</td> <td valign=top>DateTime</td></tr>
        </caption>       <tr><td valign=top>DateTime</td> <td valign=top>+</td> <td valign=top>duration</td> <td valign=top>--&gt;</td> <td valign=top>DateTime</td></tr>
        <tr><td valign=top>DateTime</td> <td valign=top>-</td> <td valign=top>duration</td> <td valign=top>--&gt;</td> <td valign=top>DateTime</td></tr>
        </table>

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>duration</td>
<td valign=top>The duration to add to or subtract from this
                       <span class="d_inlinecode">DateTime</span>.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">pure nothrow DateTime <a name="opOpAssign"></a><u>opOpAssign</u>(string op, D)(in D <i>duration</i>);
</div></dt>
<dd>Gives the result of adding or subtracting a duration from this
        <span class="d_inlinecode">DateTime</span>, as well as assigning the result to this <span class="d_inlinecode">DateTime</span>.
<p></p>
The legal types of arithmetic for <span class="d_inlinecode">DateTime</span> using this operator are
<p></p>


        <table cellspacing=0 cellpadding=5><caption>       <tr><td valign=top>DateTime</td> <td valign=top>+</td> <td valign=top>duration</td> <td valign=top>--&gt;</td> <td valign=top>DateTime</td></tr>
        <tr><td valign=top>DateTime</td> <td valign=top>-</td> <td valign=top>duration</td> <td valign=top>--&gt;</td> <td valign=top>DateTime</td></tr>
        </caption>       <tr><td valign=top>DateTime</td> <td valign=top>+</td> <td valign=top>duration</td> <td valign=top>--&gt;</td> <td valign=top>DateTime</td></tr>
        <tr><td valign=top>DateTime</td> <td valign=top>-</td> <td valign=top>duration</td> <td valign=top>--&gt;</td> <td valign=top>DateTime</td></tr>
        </table>

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>duration</td>
<td valign=top>The duration to add to or subtract from this
                       <span class="d_inlinecode">DateTime</span>.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">const pure nothrow Duration <a name="opBinary"></a><u>opBinary</u>(string op)(in DateTime <i>rhs</i>);
</div></dt>
<dd>Gives the difference between two <span class="d_inlinecode">DateTime</span>s.
<p></p>
The legal types of arithmetic for <span class="d_inlinecode">DateTime</span> using this operator are
<p></p>


        <table cellspacing=0 cellpadding=5><caption>       <tr><td valign=top>DateTime</td> <td valign=top>-</td> <td valign=top>DateTime</td> <td valign=top>--&gt;</td> <td valign=top>duration</td></tr>
        </caption>       <tr><td valign=top>DateTime</td> <td valign=top>-</td> <td valign=top>DateTime</td> <td valign=top>--&gt;</td> <td valign=top>duration</td></tr>
        </table><p></p>

</dd>
<dt><div class="d_decl">const pure nothrow int <a name="diffMonths"></a><u>diffMonths</u>(in DateTime <i>rhs</i>);
</div></dt>
<dd>Returns the difference between the two <span class="d_inlinecode">DateTime</span>s in months.
<p></p>
You can get the difference in years by subtracting the year property
        of two <span class="d_inlinecode">DateTime</span>s, and you can get the difference in days or weeks
        by subtracting the <span class="d_inlinecode">DateTime</span>s themselves and using the Duration that
        results, but because you cannot convert between months and smaller units
        without a specific date (which <span class="d_inlinecode">Duration</span>s don't have), you cannot
        get the difference in months without doing some math using both the year
        and month properties, so this is a convenience function for getting the
        difference in months.
<p></p>


        Note that the number of days in the months or how far into the month
        either date is is irrelevant. It is the difference in the month property
        combined with the difference in years * 12. So, for instance,
        December 31st and January 1st are one month apart just as December 1st
        and January 31st are one month apart.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>DateTime <i>rhs</i></td>
<td valign=top>The <span class="d_inlinecode">DateTime</span> to subtract from this one.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(DateTime(1999, 2, 1, 12, 2, 3).<span class="d_psymbol">diffMonths</span>(
            DateTime(1999, 1, 31, 23, 59, 59)) == 1);

<span class="d_keyword">assert</span>(DateTime(1999, 1, 31, 0, 0, 0).<span class="d_psymbol">diffMonths</span>(
            DateTime(1999, 2, 1, 12, 3, 42)) == -1);

<span class="d_keyword">assert</span>(DateTime(1999, 3, 1, 5, 30, 0).<span class="d_psymbol">diffMonths</span>(
            DateTime(1999, 1, 1, 2, 4, 7)) == 2);

<span class="d_keyword">assert</span>(DateTime(1999, 1, 1, 7, 2, 4).<span class="d_psymbol">diffMonths</span>(
            DateTime(1999, 3, 31, 0, 30, 58)) == -2);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property bool <a name="isLeapYear"></a><u>isLeapYear</u>();
</div></dt>
<dd>Whether this <span class="d_inlinecode">DateTime</span> is in a leap year.<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property DayOfWeek <a name="dayOfWeek"></a><u>dayOfWeek</u>();
</div></dt>
<dd>Day of the week this <span class="d_inlinecode">DateTime</span> is on.<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property ushort <a name="dayOfYear"></a><u>dayOfYear</u>();
</div></dt>
<dd>Day of the year this <span class="d_inlinecode">DateTime</span> is on.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(DateTime(Date(1999, 1, 1), TimeOfDay(12, 22, 7)).<span class="d_psymbol">dayOfYear</span> == 1);
<span class="d_keyword">assert</span>(DateTime(Date(1999, 12, 31), TimeOfDay(7, 2, 59)).<span class="d_psymbol">dayOfYear</span> == 365);
<span class="d_keyword">assert</span>(DateTime(Date(2000, 12, 31), TimeOfDay(21, 20, 0)).<span class="d_psymbol">dayOfYear</span> == 366);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">pure @property void <a name="dayOfYear"></a><u>dayOfYear</u>(int <i>day</i>);
</div></dt>
<dd>Day of the year.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>int <i>day</i></td>
<td valign=top>The <i>day</i> of the year to set which <i>day</i> of the year this
                  <span class="d_inlinecode">DateTime</span> is on.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property int <a name="dayOfGregorianCal"></a><u>dayOfGregorianCal</u>();
</div></dt>
<dd>The Xth day of the Gregorian Calendar that this <span class="d_inlinecode">DateTime</span> is on.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(DateTime(Date(1, 1, 1), TimeOfDay(0, 0, 0)).<span class="d_psymbol">dayOfGregorianCal</span> ==
       1);
<span class="d_keyword">assert</span>(DateTime(Date(1, 12, 31), TimeOfDay(23, 59, 59)).<span class="d_psymbol">dayOfGregorianCal</span> ==
       365);
<span class="d_keyword">assert</span>(DateTime(Date(2, 1, 1), TimeOfDay(2, 2, 2)).<span class="d_psymbol">dayOfGregorianCal</span> ==
       366);

<span class="d_keyword">assert</span>(DateTime(Date(0, 12, 31), TimeOfDay(7, 7, 7)).<span class="d_psymbol">dayOfGregorianCal</span> ==
       0);
<span class="d_keyword">assert</span>(DateTime(Date(0, 1, 1), TimeOfDay(19, 30, 0)).<span class="d_psymbol">dayOfGregorianCal</span> ==
       -365);
<span class="d_keyword">assert</span>(DateTime(Date(-1, 12, 31), TimeOfDay(4, 7, 0)).<span class="d_psymbol">dayOfGregorianCal</span> ==
       -366);

<span class="d_keyword">assert</span>(DateTime(Date(2000, 1, 1), TimeOfDay(9, 30, 20)).<span class="d_psymbol">dayOfGregorianCal</span> ==
       730_120);
<span class="d_keyword">assert</span>(DateTime(Date(2010, 12, 31), TimeOfDay(15, 45, 50)).<span class="d_psymbol">dayOfGregorianCal</span> ==
       734_137);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">pure nothrow @property void <a name="dayOfGregorianCal"></a><u>dayOfGregorianCal</u>(int <i>days</i>);
</div></dt>
<dd>The Xth day of the Gregorian Calendar that this <span class="d_inlinecode">DateTime</span> is on.
        Setting this property does not affect the time portion of
        <span class="d_inlinecode">DateTime</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>int <i>days</i></td>
<td valign=top>The day of the Gregorian Calendar to set this <span class="d_inlinecode">DateTime</span>
                   to.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> dt = DateTime(Date.init, TimeOfDay(12, 0, 0));
dt.<span class="d_psymbol">dayOfGregorianCal</span> = 1;
<span class="d_keyword">assert</span>(dt == DateTime(Date(1, 1, 1), TimeOfDay(12, 0, 0)));

dt.<span class="d_psymbol">dayOfGregorianCal</span> = 365;
<span class="d_keyword">assert</span>(dt == DateTime(Date(1, 12, 31), TimeOfDay(12, 0, 0)));

dt.<span class="d_psymbol">dayOfGregorianCal</span> = 366;
<span class="d_keyword">assert</span>(dt == DateTime(Date(2, 1, 1), TimeOfDay(12, 0, 0)));

dt.<span class="d_psymbol">dayOfGregorianCal</span> = 0;
<span class="d_keyword">assert</span>(dt == DateTime(Date(0, 12, 31), TimeOfDay(12, 0, 0)));

dt.<span class="d_psymbol">dayOfGregorianCal</span> = -365;
<span class="d_keyword">assert</span>(dt == DateTime(Date(-0, 1, 1), TimeOfDay(12, 0, 0)));

dt.<span class="d_psymbol">dayOfGregorianCal</span> = -366;
<span class="d_keyword">assert</span>(dt == DateTime(Date(-1, 12, 31), TimeOfDay(12, 0, 0)));

dt.<span class="d_psymbol">dayOfGregorianCal</span> = 730_120;
<span class="d_keyword">assert</span>(dt == DateTime(Date(2000, 1, 1), TimeOfDay(12, 0, 0)));

dt.<span class="d_psymbol">dayOfGregorianCal</span> = 734_137;
<span class="d_keyword">assert</span>(dt == DateTime(Date(2010, 12, 31), TimeOfDay(12, 0, 0)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property ubyte <a name="isoWeek"></a><u>isoWeek</u>();
</div></dt>
<dd>The ISO 8601 week of the year that this <span class="d_inlinecode">DateTime</span> is in.
<p></p>
<b>See Also:</b><br><a href="http://en.wikipedia.org/wiki/ISO_week_date">ISO Week Date</a><p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property DateTime <a name="endOfMonth"></a><u>endOfMonth</u>();
</div></dt>
<dd><span class="d_inlinecode">DateTime</span> for the last day in the month that this <span class="d_inlinecode">DateTime</span> is
        in. The time portion of <a name="endOfMonth"></a><u>endOfMonth</u> is always 23:59:59.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(DateTime(Date(1999, 1, 6), TimeOfDay(0, 0, 0)).<span class="d_psymbol">endOfMonth</span> ==
       DateTime(Date(1999, 1, 31), TimeOfDay(23, 59, 59)));

<span class="d_keyword">assert</span>(DateTime(Date(1999, 2, 7), TimeOfDay(19, 30, 0)).<span class="d_psymbol">endOfMonth</span> ==
       DateTime(Date(1999, 2, 28), TimeOfDay(23, 59, 59)));

<span class="d_keyword">assert</span>(DateTime(Date(2000, 2, 7), TimeOfDay(5, 12, 27)).<span class="d_psymbol">endOfMonth</span> ==
       DateTime(Date(2000, 2, 29), TimeOfDay(23, 59, 59)));

<span class="d_keyword">assert</span>(DateTime(Date(2000, 6, 4), TimeOfDay(12, 22, 9)).<span class="d_psymbol">endOfMonth</span> ==
       DateTime(Date(2000, 6, 30), TimeOfDay(23, 59, 59)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property ubyte <a name="daysInMonth"></a><u>daysInMonth</u>();
</div></dt>
<dd>The last day in the month that this <span class="d_inlinecode">DateTime</span> is in.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(DateTime(Date(1999, 1, 6), TimeOfDay(0, 0, 0)).<span class="d_psymbol">daysInMonth</span> == 31);
<span class="d_keyword">assert</span>(DateTime(Date(1999, 2, 7), TimeOfDay(19, 30, 0)).<span class="d_psymbol">daysInMonth</span> == 28);
<span class="d_keyword">assert</span>(DateTime(Date(2000, 2, 7), TimeOfDay(5, 12, 27)).<span class="d_psymbol">daysInMonth</span> == 29);
<span class="d_keyword">assert</span>(DateTime(Date(2000, 6, 4), TimeOfDay(12, 22, 9)).<span class="d_psymbol">daysInMonth</span> == 30);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">alias <a name="endofMonthDay"></a><u>endofMonthDay</u>;
</div></dt>
<dd><span style="color:red">Scheduled for deprecation in January 2012.
              Please use daysInMonth instead.</span><p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property bool <a name="isAD"></a><u>isAD</u>();
</div></dt>
<dd>Whether the current year is a date in A.D.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(DateTime(Date(1, 1, 1), TimeOfDay(12, 7, 0)).<span class="d_psymbol">isAD</span>);
<span class="d_keyword">assert</span>(DateTime(Date(2010, 12, 31), TimeOfDay(0, 0, 0)).<span class="d_psymbol">isAD</span>);
<span class="d_keyword">assert</span>(!DateTime(Date(0, 12, 31), TimeOfDay(23, 59, 59)).<span class="d_psymbol">isAD</span>);
<span class="d_keyword">assert</span>(!DateTime(Date(-2010, 1, 1), TimeOfDay(2, 2, 2)).<span class="d_psymbol">isAD</span>);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property long <a name="julianDay"></a><u>julianDay</u>();
</div></dt>
<dd>The julian day for this <span class="d_inlinecode">DateTime</span> at the given time. For example,
        prior to noon, 1996-03-31 would be the julian day number 2450_173, so
        this function returns 2450_173, while from noon onward, the julian
        day number would be 2450_174, so this function returns 2450_174.<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property long <a name="modJulianDay"></a><u>modJulianDay</u>();
</div></dt>
<dd>The modified julian day for any time on this date (since, the modified
        julian day changes at midnight).<p></p>

</dd>
<dt><div class="d_decl">const nothrow string <a name="toISOString"></a><u>toISOString</u>();
</div></dt>
<dd>Converts this <span class="d_inlinecode">DateTime</span> to a string with the format YYYYMMDDTHHMMSS.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)).<span class="d_psymbol">toISOString</span>() ==
       <span class="d_string">"20100704T070612"</span>);

<span class="d_keyword">assert</span>(DateTime(Date(1998, 12, 25), TimeOfDay(2, 15, 0)).<span class="d_psymbol">toISOString</span>() ==
       <span class="d_string">"19981225T021500"</span>);

<span class="d_keyword">assert</span>(DateTime(Date(0, 1, 5), TimeOfDay(23, 9, 59)).<span class="d_psymbol">toISOString</span>() ==
       <span class="d_string">"00000105T230959"</span>);

<span class="d_keyword">assert</span>(DateTime(Date(-4, 1, 5), TimeOfDay(0, 0, 2)).<span class="d_psymbol">toISOString</span>() ==
       <span class="d_string">"-00040105T000002"</span>);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const nothrow string <a name="toISOExtString"></a><u>toISOExtString</u>();
</div></dt>
<dd>Converts this <span class="d_inlinecode">DateTime</span> to a string with the format
        YYYY-MM-DDTHH:MM:SS.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)).<span class="d_psymbol">toISOExtString</span>() ==
       <span class="d_string">"2010-07-04T07:06:12"</span>);

<span class="d_keyword">assert</span>(DateTime(Date(1998, 12, 25), TimeOfDay(2, 15, 0)).<span class="d_psymbol">toISOExtString</span>() ==
       <span class="d_string">"1998-12-25T02:15:00"</span>);

<span class="d_keyword">assert</span>(DateTime(Date(0, 1, 5), TimeOfDay(23, 9, 59)).<span class="d_psymbol">toISOExtString</span>() ==
       <span class="d_string">"0000-01-05T23:09:59"</span>);

<span class="d_keyword">assert</span>(DateTime(Date(-4, 1, 5), TimeOfDay(0, 0, 2)).<span class="d_psymbol">toISOExtString</span>() ==
       <span class="d_string">"-0004-01-05T00:00:02"</span>);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">alias <a name="toISOExtendedString"></a><u>toISOExtendedString</u>;
</div></dt>
<dd><span style="color:red">Scheduled for deprecation in November 2011.
              Please use toISOExtString instead.</span><p></p>

</dd>
<dt><div class="d_decl">const nothrow string <a name="toSimpleString"></a><u>toSimpleString</u>();
</div></dt>
<dd>Converts this <span class="d_inlinecode">DateTime</span> to a string with the format
        YYYY-Mon-DD HH:MM:SS.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)).<span class="d_psymbol">toSimpleString</span>() ==
       <span class="d_string">"2010-Jul-04 07:06:12"</span>);

<span class="d_keyword">assert</span>(DateTime(Date(1998, 12, 25), TimeOfDay(2, 15, 0)).<span class="d_psymbol">toSimpleString</span>() ==
       <span class="d_string">"1998-Dec-25 02:15:00"</span>);

<span class="d_keyword">assert</span>(DateTime(Date(0, 1, 5), TimeOfDay(23, 9, 59)).<span class="d_psymbol">toSimpleString</span>() ==
       <span class="d_string">"0000-Jan-05 23:09:59"</span>);

<span class="d_keyword">assert</span>(DateTime(Dte(-4, 1, 5), TimeOfDay(0, 0, 2)).<span class="d_psymbol">toSimpleString</span>() ==
       <span class="d_string">"-0004-Jan-05 00:00:02"</span>);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const nothrow string <a name="toString"></a><u>toString</u>();
</div></dt>
<dd>Converts this <span class="d_inlinecode">DateTime</span> to a string.<p></p>

</dd>
<dt><div class="d_decl">DateTime <a name="fromISOString"></a><u>fromISOString</u>(S)(in S <i>isoString</i>);
</div></dt>
<dd>Creates a <span class="d_inlinecode">DateTime</span> from a string with the format YYYYMMDDTHHMMSS.
        Whitespace is stripped from the given string.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>isoString</td>
<td valign=top>A string formatted in the ISO format for dates and times.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given string is not in the ISO format
            or if the resulting <span class="d_inlinecode">DateTime</span> would not be valid.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(DateTime.<span class="d_psymbol">fromISOString</span>(<span class="d_string">"20100704T070612"</span>) ==
       DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)));

<span class="d_keyword">assert</span>(DateTime.<span class="d_psymbol">fromISOString</span>(<span class="d_string">"19981225T021500"</span>) ==
       DateTime(Date(1998, 12, 25), TimeOfDay(2, 15, 0)));

<span class="d_keyword">assert</span>(DateTime.<span class="d_psymbol">fromISOString</span>(<span class="d_string">"00000105T230959"</span>) ==
       DateTime(Date(0, 1, 5), TimeOfDay(23, 9, 59)));

<span class="d_keyword">assert</span>(DateTime.<span class="d_psymbol">fromISOString</span>(<span class="d_string">"-00040105T000002"</span>) ==
       DateTime(Date(-4, 1, 5), TimeOfDay(0, 0, 2)));

<span class="d_keyword">assert</span>(DateTime.<span class="d_psymbol">fromISOString</span>(<span class="d_string">" 20100704T070612 "</span>) ==
       DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">DateTime <a name="fromISOExtString"></a><u>fromISOExtString</u>(S)(in S <i>isoExtString</i>);
</div></dt>
<dd>Creates a <span class="d_inlinecode">DateTime</span> from a string with the format
        YYYY-MM-DDTHH:MM:SS. Whitespace is stripped from the given string.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>isoString</td>
<td valign=top>A string formatted in the ISO Extended format for dates
                        and times.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given string is not in the ISO
            Extended format or if the resulting <span class="d_inlinecode">DateTime</span> would not be
            valid.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(DateTime.<span class="d_psymbol">fromISOExtString</span>(<span class="d_string">"2010-07-04T07:06:12"</span>) ==
       DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)));

<span class="d_keyword">assert</span>(DateTime.<span class="d_psymbol">fromISOExtString</span>(<span class="d_string">"1998-12-25T02:15:00"</span>) ==
       DateTime(Date(1998, 12, 25), TimeOfDay(2, 15, 0)));

<span class="d_keyword">assert</span>(DateTime.<span class="d_psymbol">fromISOExtString</span>(<span class="d_string">"0000-01-05T23:09:59"</span>) ==
       DateTime(Date(0, 1, 5), TimeOfDay(23, 9, 59)));

<span class="d_keyword">assert</span>(DateTime.<span class="d_psymbol">fromISOExtString</span>(<span class="d_string">"-0004-01-05T00:00:02"</span>) ==
       DateTime(Date(-4, 1, 5), TimeOfDay(0, 0, 2)));

<span class="d_keyword">assert</span>(DateTime.<span class="d_psymbol">fromISOExtString</span>(<span class="d_string">" 2010-07-04T07:06:12 "</span>) ==
       DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">DateTime <a name="fromISOExtendedString"></a><u>fromISOExtendedString</u>(S)(in S <i>isoExtString</i>);
</div></dt>
<dd><span style="color:red">Scheduled for deprecation in November 2011.
              Please use fromISOExtString instead.</span><p></p>

</dd>
<dt><div class="d_decl">DateTime <a name="fromSimpleString"></a><u>fromSimpleString</u>(S)(in S <i>simpleString</i>);
</div></dt>
<dd>Creates a <span class="d_inlinecode">DateTime</span> from a string with the format
        YYYY-Mon-DD HH:MM:SS. Whitespace is stripped from the given string.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>simpleString</td>
<td valign=top>A string formatted in the way that toSimpleString
                           formats dates and times.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given string is not in the correct
            format or if the resulting <span class="d_inlinecode">DateTime</span> would not be valid.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(DateTime.<span class="d_psymbol">fromSimpleString</span>(<span class="d_string">"2010-Jul-04 07:06:12"</span>) ==
       DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)));
<span class="d_keyword">assert</span>(DateTime.<span class="d_psymbol">fromSimpleString</span>(<span class="d_string">"1998-Dec-25 02:15:00"</span>) ==
       DateTime(Date(1998, 12, 25), TimeOfDay(2, 15, 0)));
<span class="d_keyword">assert</span>(DateTime.<span class="d_psymbol">fromSimpleString</span>(<span class="d_string">"0000-Jan-05 23:09:59"</span>) ==
       DateTime(Date(0, 1, 5), TimeOfDay(23, 9, 59)));
<span class="d_keyword">assert</span>(DateTime.<span class="d_psymbol">fromSimpleString</span>(<span class="d_string">"-0004-Jan-05 00:00:02"</span>) ==
       DateTime(Date(-4, 1, 5), TimeOfDay(0, 0, 2)));
<span class="d_keyword">assert</span>(DateTime.<span class="d_psymbol">fromSimpleString</span>(<span class="d_string">" 2010-Jul-04 07:06:12 "</span>) ==
       DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">static pure nothrow @property DateTime <a name="min"></a><u>min</u>();
</div></dt>
<dd>Returns the <span class="d_inlinecode">DateTime</span> farthest in the past which is representable by
        <span class="d_inlinecode">DateTime</span>.<p></p>

</dd>
<dt><div class="d_decl">static pure nothrow @property DateTime <a name="max"></a><u>max</u>();
</div></dt>
<dd>Returns the <span class="d_inlinecode">DateTime</span> farthest in the future which is representable
        by <span class="d_inlinecode">DateTime</span>.<p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">struct <a name="Interval"></a><u>Interval</u>(TP);
</div></dt>
<dd>Represents an interval of time.
<p></p>
An <span class="d_inlinecode"><a name="Interval"></a><u>Interval</u></span> has a starting point and an end point. The interval of time
    is therefore the time starting at the starting point up to, but not
    including, the end point. e.g.
<p></p>


    <table cellspacing=0 cellpadding=5><caption>   <tr><td valign=top>[January 5th, 2010 - March 10th, 2010)</td></tr>
    <tr><td valign=top>[05:00:30 - 12:00:00)</td></tr>
    <tr><td valign=top>[1982-01-04T08:59:00 - 2010-07-04T12:00:00)</td></tr>
    </caption>   <tr><td valign=top>[January 5th, 2010 - March 10th, 2010)</td></tr>
    <tr><td valign=top>[05:00:30 - 12:00:00)</td></tr>
    <tr><td valign=top>[1982-01-04T08:59:00 - 2010-07-04T12:00:00)</td></tr>
    </table>
<p></p>


    A range can be obtained from an <span class="d_inlinecode"><a name="Interval"></a><u>Interval</u></span>, allowing you to iterate over
    that interval, with the exact time points which are iterated over depending
    on the function which generates the range.<p></p>

<dl><dt><div class="d_decl">pure auto this(U)(in TP <i>begin</i>, in U <i>end</i>);
</div></dt>
<dd><b>Parameters:</b><table class=parms><tr><td valign=top>begin</td>
<td valign=top>The time point which begins the interval.</td></tr>
<tr><td valign=top>end</td>
<td valign=top>The time point which ends (but is not included in) the
                    interval.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if <span class="d_param">end</span> is before <span class="d_param">begin</span>.

<p></p>
<b>Examples:</b><br><pre class="d_code">Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">pure auto this(D)(in TP <i>begin</i>, in D <i>duration</i>);
</div></dt>
<dd><b>Parameters:</b><table class=parms><tr><td valign=top>begin</td>
<td valign=top>The time point which begins the interval.</td></tr>
<tr><td valign=top>duration</td>
<td valign=top>The duration from the starting point to the end point.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the resulting <span class="d_inlinecode">end</span> is before
            <span class="d_inlinecode">begin</span>.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Dur.years(3)) ==
       Interval!Date(Date(1996, 1, 2), Date(1999, 1, 2)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">pure nothrow Interval <a name="opAssign"></a><u>opAssign</u>(ref const Interval <i>rhs</i>);
</div></dt>
<dd><b>Parameters:</b><table class=parms><tr><td valign=top>Interval <i>rhs</i></td>
<td valign=top>The <span class="d_inlinecode">Interval</span> to assign to this one.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">pure nothrow Interval <a name="opAssign"></a><u>opAssign</u>(Interval <i>rhs</i>);
</div></dt>
<dd><b>Parameters:</b><table class=parms><tr><td valign=top>Interval <i>rhs</i></td>
<td valign=top>The <span class="d_inlinecode">Interval</span> to assign to this one.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">const pure nothrow TP <a name="begin"></a><u>begin</u>();
</div></dt>
<dd>The starting point of the interval. It is included in the interval.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">begin</span> ==
       Date(1996, 1, 2));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">pure void <a name="begin"></a><u>begin</u>(TP <i>timePoint</i>);
</div></dt>
<dd>The starting point of the interval. It is included in the interval.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>TP <i>timePoint</i></td>
<td valign=top>The time point to set <span class="d_inlinecode"><a name="begin"></a><u>begin</u></span> to.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the resulting interval would be invalid.<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow TP <a name="end"></a><u>end</u>();
</div></dt>
<dd>The <a name="end"></a><u>end</u> point of the interval. It is excluded from the interval.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">end</span> ==
       Date(2012, 3, 1));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">pure void <a name="end"></a><u>end</u>(TP <i>timePoint</i>);
</div></dt>
<dd>The <a name="end"></a><u>end</u> point of the interval. It is excluded from the interval.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>TP <i>timePoint</i></td>
<td valign=top>The time point to set <a name="end"></a><u>end</u> to.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the resulting interval would be invalid.<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow typeof(end - begin) <a name="length"></a><u>length</u>();
</div></dt>
<dd>Returns the duration between <span class="d_inlinecode">begin</span> and <span class="d_inlinecode">end</span>.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">length</span> ==
       dur!<span class="d_string">"days"</span>(5903));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow bool <a name="empty"></a><u>empty</u>();
</div></dt>
<dd>Whether the interval's length is 0, that is, whether <span class="d_inlinecode">begin == end</span>.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(1996, 1, 2)).<span class="d_psymbol">empty</span>);
<span class="d_keyword">assert</span>(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">empty</span>);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure bool <a name="contains"></a><u>contains</u>(in TP <i>timePoint</i>);
</div></dt>
<dd>Whether the given time point is within this interval.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>TP <i>timePoint</i></td>
<td valign=top>The time point to check for inclusion in this interval.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if this interval is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">contains</span>(
            Date(1994, 12, 24)));

<span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">contains</span>(
            Date(2000, 1, 5)));
<span class="d_keyword">assert</span>(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">contains</span>(
            Date(2012, 3, 1)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure bool <a name="contains"></a><u>contains</u>(in Interval <i>interval</i>);
</div></dt>
<dd>Whether the given <i>interval</i> is completely within this <i>interval</i>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Interval <i>interval</i></td>
<td valign=top>The <i>interval</i> to check for inclusion in this <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if either <i>interval</i> is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">contains</span>(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

<span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">contains</span>(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));

<span class="d_keyword">assert</span>(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">contains</span>(
            Interval!Date(Date(1998, 2, 28), Date(2013, 5, 1))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure bool <a name="contains"></a><u>contains</u>(in PosInfInterval!(TP) <i>interval</i>);
</div></dt>
<dd>Whether the given <i>interval</i> is completely within this <i>interval</i>.
<p></p>
Always returns <b>false</b> (unless this <i>interval</i> is empty), because an
        <i>interval</i> going to positive infinity can never be contained in a finite
        <i>interval</i>.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>PosInfInterval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to check for inclusion in this <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if this <i>interval</i> is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">contains</span>(
            PosInfInterval!Date(Date(1999, 5, 4))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure bool <a name="contains"></a><u>contains</u>(in NegInfInterval!(TP) <i>interval</i>);
</div></dt>
<dd>Whether the given <i>interval</i> is completely within this <i>interval</i>.
<p></p>
Always returns <b>false</b> (unless this <i>interval</i> is empty), because an
        <i>interval</i> beginning at negative infinity can never be contained in a
        finite <i>interval</i>.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>NegInfInterval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to check for inclusion in this <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if this <i>interval</i> is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">contains</span>(
            NegInfInterval!Date(Date(1996, 5, 4))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure bool <a name="isBefore"></a><u>isBefore</u>(in TP <i>timePoint</i>);
</div></dt>
<dd>Whether this interval is before the given time point.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>TP <i>timePoint</i></td>
<td valign=top>The time point to check whether this interval is before
                        it.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if this interval is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">isBefore</span>(
            Date(1994, 12, 24)));

<span class="d_keyword">assert</span>(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">isBefore</span>(
            Date(2000, 1, 5)));

<span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">isBefore</span>(
            Date(2012, 3, 1)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure bool <a name="isBefore"></a><u>isBefore</u>(in Interval <i>interval</i>);
</div></dt>
<dd>Whether this <i>interval</i> is before the given <i>interval</i> and does not
        intersect with it.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Interval <i>interval</i></td>
<td valign=top>The <i>interval</i> to check for against this <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if either <i>interval</i> is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">isBefore</span>(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

<span class="d_keyword">assert</span>(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">isBefore</span>(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));

<span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">isBefore</span>(
            Interval!Date(Date(2012, 3, 1), Date(2013, 5, 1))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure bool <a name="isBefore"></a><u>isBefore</u>(in PosInfInterval!(TP) <i>interval</i>);
</div></dt>
<dd>Whether this <i>interval</i> is before the given <i>interval</i> and does not
        intersect with it.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>PosInfInterval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to check for against this <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if this <i>interval</i> is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">isBefore</span>(
            PosInfInterval!Date(Date(1999, 5, 4))));

<span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">isBefore</span>(
            PosInfInterval!Date(Date(2013, 3, 7))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure bool <a name="isBefore"></a><u>isBefore</u>(in NegInfInterval!(TP) <i>interval</i>);
</div></dt>
<dd>Whether this <i>interval</i> is before the given <i>interval</i> and does not
        intersect with it.
<p></p>
Always returns <b>false</b> (unless this <i>interval</i> is empty) because a finite
        <i>interval</i> can never be before an <i>interval</i> beginning at negative infinity.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>NegInfInterval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to check for against this <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if this <i>interval</i> is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">isBefore</span>(
            NegInfInterval!Date(Date(1996, 5, 4))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure bool <a name="isAfter"></a><u>isAfter</u>(in TP <i>timePoint</i>);
</div></dt>
<dd>Whether this interval is after the given time point.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>TP <i>timePoint</i></td>
<td valign=top>The time point to check whether this interval is after
                        it.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if this interval is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">isAfter</span>(
            Date(1994, 12, 24)));

<span class="d_keyword">assert</span>(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">isAfter</span>(
            Date(2000, 1, 5)));

<span class="d_keyword">assert</span>(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">isAfter</span>(
            Date(2012, 3, 1)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure bool <a name="isAfter"></a><u>isAfter</u>(in Interval <i>interval</i>);
</div></dt>
<dd>Whether this <i>interval</i> is after the given <i>interval</i> and does not intersect
        it.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Interval <i>interval</i></td>
<td valign=top>The <i>interval</i> to check against this <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if either <i>interval</i> is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">isAfter</span>(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

<span class="d_keyword">assert</span>(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">isAfter</span>(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));

<span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">isAfter</span>(
            Interval!Date(Date(1989, 3, 1), Date(1996, 1, 2))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure bool <a name="isAfter"></a><u>isAfter</u>(in PosInfInterval!(TP) <i>interval</i>);
</div></dt>
<dd>Whether this <i>interval</i> is after the given <i>interval</i> and does not intersect
        it.
<p></p>
Always returns <b>false</b> (unless this <i>interval</i> is empty) because a finite
        <i>interval</i> can never be after an <i>interval</i> going to positive infinity.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>PosInfInterval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to check against this <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if this <i>interval</i> is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">isAfter</span>(
            PosInfInterval!Date(Date(1999, 5, 4))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure bool <a name="isAfter"></a><u>isAfter</u>(in NegInfInterval!(TP) <i>interval</i>);
</div></dt>
<dd>Whether this <i>interval</i> is after the given <i>interval</i> and does not intersect
        it.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>NegInfInterval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to check against this <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if this <i>interval</i> is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">isAfter</span>(
            NegInfInterval!Date(Date(1996, 1, 2))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure bool <a name="intersects"></a><u>intersects</u>(in Interval <i>interval</i>);
</div></dt>
<dd>Whether the given <i>interval</i> overlaps this <i>interval</i>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Interval <i>interval</i></td>
<td valign=top>The <i>interval</i> to check for intersection with this <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if either <i>interval</i> is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">intersects</span>(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

<span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">intersects</span>(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));

<span class="d_keyword">assert</span>(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">intersects</span>(
            Interval!Date(Date(1989, 3, 1), Date(1996, 1, 2))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure bool <a name="intersects"></a><u>intersects</u>(in PosInfInterval!(TP) <i>interval</i>);
</div></dt>
<dd>Whether the given <i>interval</i> overlaps this <i>interval</i>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>PosInfInterval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to check for intersection with this <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if this <i>interval</i> is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">intersects</span>(
            PosInfInterval!Date(Date(1999, 5, 4))));

<span class="d_keyword">assert</span>(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">intersects</span>(
            PosInfInterval!Date(Date(2012, 3, 1))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure bool <a name="intersects"></a><u>intersects</u>(in NegInfInterval!(TP) <i>interval</i>);
</div></dt>
<dd>Whether the given <i>interval</i> overlaps this <i>interval</i>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>NegInfInterval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to check for intersection with this <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if this <i>interval</i> is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">intersects</span>(
            NegInfInterval!Date(Date(1996, 1, 2))));

<span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">intersects</span>(
            NegInfInterval!Date(Date(2000, 1, 2))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const Interval <a name="intersection"></a><u>intersection</u>(in Interval <i>interval</i>);
</div></dt>
<dd>Returns the <a name="intersection"></a><u>intersection</u> of two intervals
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Interval <i>interval</i></td>
<td valign=top>The <i>interval</i> to intersect with this <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the two intervals do not intersect or if
            either <i>interval</i> is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">intersection</span>(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==
       Interval!Date(Date(1996, 1 , 2), Date(2000, 8, 2)));

<span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">intersection</span>(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))) ==
       Interval!Date(Date(1999, 1 , 12), Date(2011, 9, 17)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const Interval <a name="intersection"></a><u>intersection</u>(in PosInfInterval!(TP) <i>interval</i>);
</div></dt>
<dd>Returns the <a name="intersection"></a><u>intersection</u> of two intervals
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>PosInfInterval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to intersect with this <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the two intervals do not intersect or if
            this <i>interval</i> is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">intersection</span>(
            PosInfInterval!Date(Date(1990, 7, 6))) ==
       Interval!Date(Date(1996, 1 , 2), Date(2012, 3, 1)));

<span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">intersection</span>(
            PosInfInterval!Date(Date(1999, 1, 12))) ==
       Interval!Date(Date(1999, 1 , 12), Date(2012, 3, 1)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const Interval <a name="intersection"></a><u>intersection</u>(in NegInfInterval!(TP) <i>interval</i>);
</div></dt>
<dd>Returns the <a name="intersection"></a><u>intersection</u> of two intervals
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>NegInfInterval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to intersect with this <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the two intervals do not intersect or if
            this <i>interval</i> is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">intersection</span>(
            NegInfInterval!Date(Date(1999, 7, 6))) ==
       Interval!Date(Date(1996, 1 , 2), Date(1999, 7, 6)));

<span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">intersection</span>(
            NegInfInterval!Date(Date(2013, 1, 12))) ==
       Interval!Date(Date(1996, 1 , 2), Date(2012, 3, 1)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure bool <a name="isAdjacent"></a><u>isAdjacent</u>(in Interval <i>interval</i>);
</div></dt>
<dd>Whether the given <i>interval</i> is adjacent to this <i>interval</i>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Interval <i>interval</i></td>
<td valign=top>The <i>interval</i> to check whether its adjecent to this
                       <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if either <i>interval</i> is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">isAdjacent</span>(
            Interval!Date(Date(1990, 7, 6), Date(1996, 1, 2))));

<span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">isAdjacent</span>(
            Interval!Date(Date(2012, 3, 1), Date(2013, 9, 17))));

<span class="d_keyword">assert</span>(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">isAdjacent</span>(
            Interval!Date(Date(1989, 3, 1), Date(2012, 3, 1))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure bool <a name="isAdjacent"></a><u>isAdjacent</u>(in PosInfInterval!(TP) <i>interval</i>);
</div></dt>
<dd>Whether the given <i>interval</i> is adjacent to this <i>interval</i>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>PosInfInterval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to check whether its adjecent to this
                       <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if this <i>interval</i> is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">isAdjacent</span>(
            PosInfInterval!Date(Date(1999, 5, 4))));

<span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">isAdjacent</span>(
            PosInfInterval!Date(Date(2012, 3, 1))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure bool <a name="isAdjacent"></a><u>isAdjacent</u>(in NegInfInterval!(TP) <i>interval</i>);
</div></dt>
<dd>Whether the given <i>interval</i> is adjacent to this <i>interval</i>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>NegInfInterval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to check whether its adjecent to this
                       <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if this <i>interval</i> is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">isAdjacent</span>(
            NegInfInterval!Date(Date(1996, 1, 2))));

<span class="d_keyword">assert</span>(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">isAdjacent</span>(
            NegInfInterval!Date(Date(2000, 1, 2))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const Interval <a name="merge"></a><u>merge</u>(in Interval <i>interval</i>);
</div></dt>
<dd>Returns the union of two intervals
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Interval <i>interval</i></td>
<td valign=top>The <i>interval</i> to <a name="merge"></a><u>merge</u> with this <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the two intervals do not intersect and are
            not adjacent or if either <i>interval</i> is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">merge</span>(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==
       Interval!Date(Date(1990, 7 , 6), Date(2012, 3, 1)));

<span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">merge</span>(
            Interval!Date(Date(2012, 3, 1), Date(2013, 5, 7))) ==
       Interval!Date(Date(1996, 1 , 2), Date(2013, 5, 7)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const PosInfInterval!(TP) <a name="merge"></a><u>merge</u>(in PosInfInterval!(TP) <i>interval</i>);
</div></dt>
<dd>Returns the union of two intervals
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>PosInfInterval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to <a name="merge"></a><u>merge</u> with this <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the two intervals do not intersect and are
            not adjacent or if this <i>interval</i> is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">merge</span>(
            PosInfInterval!Date(Date(1990, 7, 6))) ==
       PosInfInterval!Date(Date(1990, 7 , 6)));

<span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">merge</span>(
            PosInfInterval!Date(Date(2012, 3, 1))) ==
       PosInfInterval!Date(Date(1996, 1 , 2)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const NegInfInterval!(TP) <a name="merge"></a><u>merge</u>(in NegInfInterval!(TP) <i>interval</i>);
</div></dt>
<dd>Returns the union of two intervals
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>NegInfInterval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to <a name="merge"></a><u>merge</u> with this <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the two intervals do not intersect and are not
            adjacent or if this <i>interval</i> is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">merge</span>(
            NegInfInterval!Date(Date(1996, 1, 2))) ==
       NegInfInterval!Date(Date(2012, 3 , 1)));

<span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">merge</span>(
            NegInfInterval!Date(Date(2013, 1, 12))) ==
       NegInfInterval!Date(Date(2013, 1 , 12)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure Interval <a name="span"></a><u>span</u>(in Interval <i>interval</i>);
</div></dt>
<dd>Returns an <i>interval</i> that covers from the earliest time point of two
        intervals up to (but not including) the latest time point of two
        intervals.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Interval <i>interval</i></td>
<td valign=top>The <i>interval</i> to create a <a name="span"></a><u>span</u> together with this <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if either <i>interval</i> is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">span</span>(
            Interval!Date(Date(1990, 7, 6), Date(1991, 1, 8))) ==
       Interval!Date(Date(1990, 7 , 6), Date(2012, 3, 1)));

<span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">span</span>(
            Interval!Date(Date(2012, 3, 1), Date(2013, 5, 7))) ==
       Interval!Date(Date(1996, 1 , 2), Date(2013, 5, 7)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure PosInfInterval!(TP) <a name="span"></a><u>span</u>(in PosInfInterval!(TP) <i>interval</i>);
</div></dt>
<dd>Returns an <i>interval</i> that covers from the earliest time point of two
        intervals up to (but not including) the latest time point of two
        intervals.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>PosInfInterval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to create a <a name="span"></a><u>span</u> together with this <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if this <i>interval</i> is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">span</span>(
            PosInfInterval!Date(Date(1990, 7, 6))) ==
       PosInfInterval!Date(Date(1990, 7 , 6)));

<span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">span</span>(
            PosInfInterval!Date(Date(2050, 1, 1))) ==
       PosInfInterval!Date(Date(1996, 1 , 2)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure NegInfInterval!(TP) <a name="span"></a><u>span</u>(in NegInfInterval!(TP) <i>interval</i>);
</div></dt>
<dd>Returns an <i>interval</i> that covers from the earliest time point of two
        intervals up to (but not including) the latest time point of two
        intervals.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>NegInfInterval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to create a <a name="span"></a><u>span</u> together with this <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if this <i>interval</i> is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">span</span>(
            NegInfInterval!Date(Date(1602, 5, 21))) ==
       NegInfInterval!Date(Date(2012, 3 , 1)));

<span class="d_keyword">assert</span>(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).<span class="d_psymbol">span</span>(
            NegInfInterval!Date(Date(2013, 1, 12))) ==
       NegInfInterval!Date(Date(2013, 1 , 12)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">pure void <a name="shift"></a><u>shift</u>(D)(D <i>duration</i>);
</div></dt>
<dd>Shifts the interval forward or backwards in time by the given duration
        (a positive duration shifts the interval forward; a negative duration
        shifts it backward). Effectively, it does <span class="d_inlinecode">begin += duration</span> and
        <span class="d_inlinecode">end += duration</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>duration</td>
<td valign=top>The duration to <a name="shift"></a><u>shift</u> the interval by.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> this interval is empty or if the resulting
            interval would be invalid.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> interval1 = Interval!Date(Date(1996, 1, 2), Date(2012, 4, 5));
<span class="d_keyword">auto</span> interval2 = Interval!Date(Date(1996, 1, 2), Date(2012, 4, 5));

interval1.<span class="d_psymbol">shift</span>(dur!<span class="d_string">"days"</span>(50));
<span class="d_keyword">assert</span>(interval1 == Interval!Date(Date(1996, 2, 21), Date(2012, 5, 25)));

interval2.<span class="d_psymbol">shift</span>(dur!<span class="d_string">"days"</span>(-50));
<span class="d_keyword">assert</span>(interval2 == Interval!Date(Date(1995, 11, 13), Date(2012, 2, 15)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">void <a name="shift"></a><u>shift</u>(T)(T <i>years</i>, T <i>months</i> = 0, AllowDayOverflow <i>allowOverflow</i> = AllowDayOverflow.yes);
</div></dt>
<dd>Shifts the interval forward or backwards in time by the given number
            of years and/or months (a positive number of years and months shifts
            the interval forward; a negative number shifts it backward).
            It adds the years the given years and months to both begin and end.
            It effectively calls <span class="d_inlinecode">add!"years"()</span> and then <span class="d_inlinecode">add!"months"()</span>
            on begin and end with the given number of years and months.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>years</td>
<td valign=top>The number of years to <a name="shift"></a><u>shift</u> the interval by.</td></tr>
<tr><td valign=top>months</td>
<td valign=top>The number of months to <a name="shift"></a><u>shift</u> the interval by.</td></tr>
<tr><td valign=top>allowOverflow</td>
<td valign=top>Whether the days should be allowed to overflow
                                on <span class="d_inlinecode">begin</span> and <span class="d_inlinecode">end</span>, causing their month
                                to increment.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if this interval is empty or if the
                resulting interval would be invalid.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> interval1 = Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1));
<span class="d_keyword">auto</span> interval2 = Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1));

interval1.<span class="d_psymbol">shift</span>(2);
<span class="d_keyword">assert</span>(interval1 == Interval!Date(Date(1998, 1, 2), Date(2014, 3, 1)));

interval2.<span class="d_psymbol">shift</span>(-2);
<span class="d_keyword">assert</span>(interval2 == Interval!Date(Date(1994, 1, 2), Date(2010, 3, 1)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">pure void <a name="expand"></a><u>expand</u>(D)(D <i>duration</i>, Direction <i>dir</i> = Direction.both);
</div></dt>
<dd>Expands the interval forwards and/or backwards in time. Effectively,
        it does <span class="d_inlinecode">begin -= duration</span> and/or <span class="d_inlinecode">end += duration</span>. Whether
        it expands forwards and/or backwards in time is determined by
        <span class="d_param">dir</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>duration</td>
<td valign=top>The duration to <a name="expand"></a><u>expand</u> the interval by.</td></tr>
<tr><td valign=top>dir</td>
<td valign=top>The direction in time to <a name="expand"></a><u>expand</u> the interval.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> this interval is empty or if the resulting
            interval would be invalid.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> interval1 = Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1));
<span class="d_keyword">auto</span> interval2 = Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1));

interval1.<span class="d_psymbol">expand</span>(2);
<span class="d_keyword">assert</span>(interval1 == Interval!Date(Date(1994, 1, 2), Date(2014, 3, 1)));

interval2.<span class="d_psymbol">expand</span>(-2);
<span class="d_keyword">assert</span>(interval2 == Interval!Date(Date(1998, 1, 2), Date(2010, 3, 1)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">void <a name="expand"></a><u>expand</u>(T)(T <i>years</i>, T <i>months</i> = 0, AllowDayOverflow <i>allowOverflow</i> = AllowDayOverflow.yes, Direction <i>dir</i> = Direction.both);
</div></dt>
<dd>Expands the interval forwards and/or backwards in time. Effectively,
            it subtracts the given number of months/years from <span class="d_inlinecode">begin</span> and
            adds them to <span class="d_inlinecode">end</span>. Whether it expands forwards and/or backwards
            in time is determined by <span class="d_param">dir</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>years</td>
<td valign=top>The number of years to <a name="expand"></a><u>expand</u> the interval by.</td></tr>
<tr><td valign=top>months</td>
<td valign=top>The number of months to <a name="expand"></a><u>expand</u> the interval by.</td></tr>
<tr><td valign=top>allowOverflow</td>
<td valign=top>Whether the days should be allowed to overflow
                                on <span class="d_inlinecode">begin</span> and <span class="d_inlinecode">end</span>, causing their month
                                to increment.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if this interval is empty or if the
                resulting interval would be invalid.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> interval1 = Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1));
<span class="d_keyword">auto</span> interval2 = Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1));

interval1.<span class="d_psymbol">expand</span>(2);
<span class="d_keyword">assert</span>(interval1 == Interval!Date(Date(1994, 1, 2), Date(2014, 3, 1)));

interval2.<span class="d_psymbol">expand</span>(-2);
<span class="d_keyword">assert</span>(interval2 == Interval!Date(Date(1998, 1, 2), Date(2010, 3, 1)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const IntervalRange!(TP,Direction.fwd) <a name="fwdRange"></a><u>fwdRange</u>(TP delegate(in TP) <i>func</i>, PopFirst <i>popFirst</i> = PopFirst.no);
</div></dt>
<dd>Returns a range which iterates forward over the interval, starting
        at <span class="d_inlinecode">begin</span>, using <span class="d_param"><i>func</i></span> to generate each successive time
        point.
<p></p>
The range's <span class="d_inlinecode">front</span> is the interval's <span class="d_inlinecode">begin</span>. <span class="d_param"><i>func</i></span> is
        used to generate the next <span class="d_inlinecode">front</span> when <span class="d_inlinecode">popFront</span> is called. If
        <span class="d_param"><i>popFirst</i></span> is <span class="d_inlinecode">PopFirst.yes</span>, then <span class="d_inlinecode">popFront</span> is called
        before the range is returned (so that <span class="d_inlinecode">front</span> is a time point which
        <span class="d_param"><i>func</i></span> would generate).
<p></p>


        If <span class="d_param"><i>func</i></span> ever generates a time point less than or equal to the
        current <span class="d_inlinecode">front</span> of the range, then a <span class="d_inlinecode">DateTimeException</span> will be
        thrown. The range will be empty and iteration complete when
        <span class="d_param"><i>func</i></span> generates a time point equal to or beyond the <span class="d_inlinecode">end</span>
        of the interval.
<p></p>


        There are helper functions in this module which generate common
        delegates to pass to <span class="d_inlinecode"><a name="fwdRange"></a><u>fwdRange</u></span>. Their documentation starts with
        "Range-generating function," so you can easily search for them.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>TP delegate(in TP) <i>func</i></td>
<td valign=top>The function used to generate the time points of the
                       range over the interval.</td></tr>
<tr><td valign=top>PopFirst <i>popFirst</i></td>
<td valign=top>Whether <span class="d_inlinecode">popFront</span> should be called on the range
                       before returning it.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if this interval is empty.

<p></p>
<b>Warning:</b><br>
<span class="d_param"><i>func</i></span> must be logically pure. Ideally, <span class="d_param"><i>func</i></span>
            would be a function pointer to a pure function, but forcing
            <span class="d_param"><i>func</i></span> to be pure is far too restrictive to be useful, and
            in order to have the ease of use of having functions which generate
            functions to pass to <span class="d_inlinecode"><a name="fwdRange"></a><u>fwdRange</u></span>, <span class="d_param"><i>func</i></span> must be a
            delegate.
<p></p>


            If <span class="d_param"><i>func</i></span> retains state which changes as it is called, then
            some algorithms will not work correctly, because the range's
            <span class="d_inlinecode">save</span> will have failed to have really saved the range's state.
            So, if you want to avoid such bugs, don't pass a delegate which is
            not logically pure to <span class="d_inlinecode"><a name="fwdRange"></a><u>fwdRange</u></span>. If <span class="d_param"><i>func</i></span> is given the
            same time point with two different calls, it must return the same
            result both times.
<p></p>


            Of course, none of the functions in this module have this problem,
            so it's only relevant if you're creating your own delegate.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> interval = Interval!Date(Date(2010, 9, 1), Date(2010, 9, 9));
<span class="d_keyword">auto</span> <span class="d_param">func</span> = (<span class="d_keyword">in</span> Date date) <span class="d_comment">//For iterating over even-numbered days.
</span>            {
                <span class="d_keyword">if</span>((date.day &amp; 1) == 0)
                    <span class="d_keyword">return</span> date + dur!<span class="d_string">"days"</span>(2);

                <span class="d_keyword">return</span> date + dur!<span class="d_string">"days"</span>(1);
            };
<span class="d_keyword">auto</span> range = interval.<span class="d_psymbol">fwdRange</span>(<span class="d_param">func</span>);

 <span class="d_comment">//An odd day. Using PopFirst.yes would have made this Date(2010, 9, 2).
</span><span class="d_keyword">assert</span>(range.front == Date(2010, 9, 1));

range.popFront();
<span class="d_keyword">assert</span>(range.front == Date(2010, 9, 2));

range.popFront();
<span class="d_keyword">assert</span>(range.front == Date(2010, 9, 4));

range.popFront();
<span class="d_keyword">assert</span>(range.front == Date(2010, 9, 6));

range.popFront();
<span class="d_keyword">assert</span>(range.front == Date(2010, 9, 8));

range.popFront();
<span class="d_keyword">assert</span>(range.empty);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const IntervalRange!(TP,Direction.bwd) <a name="bwdRange"></a><u>bwdRange</u>(TP delegate(in TP) <i>func</i>, PopFirst <i>popFirst</i> = PopFirst.no);
</div></dt>
<dd>Returns a range which iterates backwards over the interval, starting
        at <span class="d_inlinecode">end</span>, using <span class="d_param"><i>func</i></span> to generate each successive time
        point.
<p></p>
The range's <span class="d_inlinecode">front</span> is the interval's <span class="d_inlinecode">end</span>. <span class="d_param"><i>func</i></span> is
        used to generate the next <span class="d_inlinecode">front</span> when <span class="d_inlinecode">popFront</span> is called. If
        <span class="d_param"><i>popFirst</i></span> is <span class="d_inlinecode">PopFirst.yes</span>, then <span class="d_inlinecode">popFront</span> is called
        before the range is returned (so that <span class="d_inlinecode">front</span> is a time point which
        <span class="d_param"><i>func</i></span> would generate).
<p></p>


        If <span class="d_param"><i>func</i></span> ever generates a time point greater than or equal to
        the current <span class="d_inlinecode">front</span> of the range, then a <span class="d_inlinecode">DateTimeException</span> will
        be thrown. The range will be empty and iteration complete when
        <span class="d_param"><i>func</i></span> generates a time point equal to or less than the
        <span class="d_inlinecode">begin</span> of the interval.
<p></p>


        There are helper functions in this module which generate common
        delegates to pass to <span class="d_inlinecode"><a name="bwdRange"></a><u>bwdRange</u></span>. Their documentation starts with
        "Range-generating function," so you can easily search for them.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>TP delegate(in TP) <i>func</i></td>
<td valign=top>The function used to generate the time points of the
                       range over the interval.</td></tr>
<tr><td valign=top>PopFirst <i>popFirst</i></td>
<td valign=top>Whether <span class="d_inlinecode">popFront</span> should be called on the range
                       before returning it.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if this interval is empty.

<p></p>
<b>Warning:</b><br>
<span class="d_param"><i>func</i></span> must be logically pure. Ideally, <span class="d_param"><i>func</i></span>
            would be a function pointer to a pure function, but forcing
            <span class="d_param"><i>func</i></span> to be pure is far too restrictive to be useful, and
            in order to have the ease of use of having functions which generate
            functions to pass to <span class="d_inlinecode">fwdRange</span>, <span class="d_param"><i>func</i></span> must be a
            delegate.
<p></p>


            If <span class="d_param"><i>func</i></span> retains state which changes as it is called, then
            some algorithms will not work correctly, because the range's
            <span class="d_inlinecode">save</span> will have failed to have really saved the range's state.
            So, if you want to avoid such bugs, don't pass a delegate which is
            not logically pure to <span class="d_inlinecode">fwdRange</span>. If <span class="d_param"><i>func</i></span> is given the
            same time point with two different calls, it must return the same
            result both times.
<p></p>


            Of course, none of the functions in this module have this problem,
            so it's only relevant if you're creating your own delegate.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> interval = Interval!Date(Date(2010, 9, 1), Date(2010, 9, 9));
<span class="d_keyword">auto</span> <span class="d_param">func</span> = (<span class="d_keyword">in</span> Date date) <span class="d_comment">//For iterating over even-numbered days.
</span>            {
                <span class="d_keyword">if</span>((date.day &amp; 1) == 0)
                    <span class="d_keyword">return</span> date - dur!<span class="d_string">"days"</span>(2);

                <span class="d_keyword">return</span> date - dur!<span class="d_string">"days"</span>(1);
            };
<span class="d_keyword">auto</span> range = interval.<span class="d_psymbol">bwdRange</span>(<span class="d_param">func</span>);

<span class="d_comment">//An odd day. Using PopFirst.yes would have made this Date(2010, 9, 8).
</span><span class="d_keyword">assert</span>(range.front == Date(2010, 9, 9));

range.popFront();
<span class="d_keyword">assert</span>(range.front == Date(2010, 9, 8));

range.popFront();
<span class="d_keyword">assert</span>(range.front == Date(2010, 9, 6));

range.popFront();
<span class="d_keyword">assert</span>(range.front == Date(2010, 9, 4));

range.popFront();
<span class="d_keyword">assert</span>(range.front == Date(2010, 9, 2));

range.popFront();
<span class="d_keyword">assert</span>(range.empty);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const nothrow string <a name="toString"></a><u>toString</u>();
</div></dt>
<dd>Converts this interval to a string.<p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">struct <a name="PosInfInterval"></a><u>PosInfInterval</u>(TP);
</div></dt>
<dd>Represents an interval of time which has positive infinity as its end point.
<p></p>
Any ranges which iterate over a <span class="d_inlinecode"><a name="PosInfInterval"></a><u>PosInfInterval</u></span> are infinite. So, the
    main purpose of using <span class="d_inlinecode"><a name="PosInfInterval"></a><u>PosInfInterval</u></span> is to create an infinite range
    which starts at a fixed point in time and goes to positive infinity.<p></p>

<dl><dt><div class="d_decl">pure nothrow auto this(in TP <i>begin</i>);
</div></dt>
<dd><b>Parameters:</b><table class=parms><tr><td valign=top>TP <i>begin</i></td>
<td valign=top>The time point which begins the interval.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> interval = PosInfInterval!Date(Date(1996, 1, 2));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">pure nothrow PosInfInterval <a name="opAssign"></a><u>opAssign</u>(ref const PosInfInterval <i>rhs</i>);
</div></dt>
<dd><b>Parameters:</b><table class=parms><tr><td valign=top>PosInfInterval <i>rhs</i></td>
<td valign=top>The <span class="d_inlinecode">PosInfInterval</span> to assign to this one.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">pure nothrow PosInfInterval <a name="opAssign"></a><u>opAssign</u>(PosInfInterval <i>rhs</i>);
</div></dt>
<dd><b>Parameters:</b><table class=parms><tr><td valign=top>PosInfInterval <i>rhs</i></td>
<td valign=top>The <span class="d_inlinecode">PosInfInterval</span> to assign to this one.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">const pure nothrow TP <a name="begin"></a><u>begin</u>();
</div></dt>
<dd>The starting point of the interval. It is included in the interval.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">begin</span> == Date(1996, 1, 2));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">pure nothrow void <a name="begin"></a><u>begin</u>(TP <i>timePoint</i>);
</div></dt>
<dd>The starting point of the interval. It is included in the interval.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>TP <i>timePoint</i></td>
<td valign=top>The time point to set <span class="d_inlinecode"><a name="begin"></a><u>begin</u></span> to.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">const pure nothrow bool <a name="empty"></a><u>empty</u>();
</div></dt>
<dd>Whether the interval's length is 0. Always returns <b>false</b>.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">empty</span>);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow bool <a name="contains"></a><u>contains</u>(TP <i>timePoint</i>);
</div></dt>
<dd>Whether the given time point is within this interval.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>TP <i>timePoint</i></td>
<td valign=top>The time point to check for inclusion in this interval.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">contains</span>(Date(1994, 12, 24)));
<span class="d_keyword">assert</span>(PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">contains</span>(Date(2000, 1, 5)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure bool <a name="contains"></a><u>contains</u>(in Interval!(TP) <i>interval</i>);
</div></dt>
<dd>Whether the given <i>interval</i> is completely within this <i>interval</i>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Interval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to check for inclusion in this <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given <i>interval</i> is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">contains</span>(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

<span class="d_keyword">assert</span>(PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">contains</span>(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));

<span class="d_keyword">assert</span>(PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">contains</span>(
            Interval!Date(Date(1998, 2, 28), Date(2013, 5, 1))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow bool <a name="contains"></a><u>contains</u>(in PosInfInterval <i>interval</i>);
</div></dt>
<dd>Whether the given <i>interval</i> is completely within this <i>interval</i>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>PosInfInterval <i>interval</i></td>
<td valign=top>The <i>interval</i> to check for inclusion in this <i>interval</i>.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">contains</span>(
            PosInfInterval!Date(Date(1999, 5, 4))));

<span class="d_keyword">assert</span>(!PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">contains</span>(
            PosInfInterval!Date(Date(1995, 7, 2))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow bool <a name="contains"></a><u>contains</u>(in NegInfInterval!(TP) <i>interval</i>);
</div></dt>
<dd>Whether the given <i>interval</i> is completely within this <i>interval</i>.
<p></p>
Always returns <b>false</b> because an <i>interval</i> going to positive infinity
        can never contain an <i>interval</i> beginning at negative infinity.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>NegInfInterval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to check for inclusion in this <i>interval</i>.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">contains</span>(
            NegInfInterval!Date(Date(1996, 5, 4))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow bool <a name="isBefore"></a><u>isBefore</u>(in TP <i>timePoint</i>);
</div></dt>
<dd>Whether this interval is before the given time point.
<p></p>
Always returns <b>false</b> because an interval going to positive infinity
        can never be before any time point.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>TP <i>timePoint</i></td>
<td valign=top>The time point to check whether this interval is before
                        it.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">isBefore</span>(Date(1994, 12, 24)));
<span class="d_keyword">assert</span>(!PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">isBefore</span>(Date(2000, 1, 5)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure bool <a name="isBefore"></a><u>isBefore</u>(in Interval!(TP) <i>interval</i>);
</div></dt>
<dd>Whether this <i>interval</i> is before the given <i>interval</i> and does not
        intersect it.
<p></p>
Always returns <b>false</b> (unless the given <i>interval</i> is empty) because an
        <i>interval</i> going to positive infinity can never be before any other
        <i>interval</i>.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Interval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to check for against this <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given <i>interval</i> is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">isBefore</span>(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

<span class="d_keyword">assert</span>(!PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">isBefore</span>(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow bool <a name="isBefore"></a><u>isBefore</u>(in PosInfInterval <i>interval</i>);
</div></dt>
<dd>Whether this <i>interval</i> is before the given <i>interval</i> and does not
        intersect it.
<p></p>
Always returns <b>false</b> because an <i>interval</i> going to positive infinity can
        never be before any other <i>interval</i>.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>PosInfInterval <i>interval</i></td>
<td valign=top>The <i>interval</i> to check for against this <i>interval</i>.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">isBefore</span>(
            PosInfInterval!Date(Date(1992, 5, 4))));

<span class="d_keyword">assert</span>(!PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">isBefore</span>(
            PosInfInterval!Date(Date(2013, 3, 7))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow bool <a name="isBefore"></a><u>isBefore</u>(in NegInfInterval!(TP) <i>interval</i>);
</div></dt>
<dd>Whether this <i>interval</i> is before the given <i>interval</i> and does not
        intersect it.
<p></p>
Always returns <b>false</b> because an <i>interval</i> going to positive infinity can
        never be before any other <i>interval</i>.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>NegInfInterval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to check for against this <i>interval</i>.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">isBefore</span>(
            NegInfInterval!Date(Date(1996, 5, 4))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow bool <a name="isAfter"></a><u>isAfter</u>(in TP <i>timePoint</i>);
</div></dt>
<dd>Whether this interval is after the given time point.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>TP <i>timePoint</i></td>
<td valign=top>The time point to check whether this interval is after
                        it.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">isAfter</span>(Date(1994, 12, 24)));
<span class="d_keyword">assert</span>(!PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">isAfter</span>(Date(2000, 1, 5)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure bool <a name="isAfter"></a><u>isAfter</u>(in Interval!(TP) <i>interval</i>);
</div></dt>
<dd>Whether this <i>interval</i> is after the given <i>interval</i> and does not intersect
        it.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Interval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to check against this <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given <i>interval</i> is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">isAfter</span>(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

<span class="d_keyword">assert</span>(!PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">isAfter</span>(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));

<span class="d_keyword">assert</span>(PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">isAfter</span>(
            Interval!Date(Date(1989, 3, 1), Date(1996, 1, 2))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow bool <a name="isAfter"></a><u>isAfter</u>(in PosInfInterval <i>interval</i>);
</div></dt>
<dd>Whether this <i>interval</i> is after the given <i>interval</i> and does not intersect
        it.
<p></p>
Always returns <b>false</b> because an <i>interval</i> going to positive infinity can
        never be after another <i>interval</i> going to positive infinity.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>PosInfInterval <i>interval</i></td>
<td valign=top>The <i>interval</i> to check against this <i>interval</i>.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">isAfter</span>(
            PosInfInterval!Date(Date(1990, 1, 7))));

<span class="d_keyword">assert</span>(!PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">isAfter</span>(
            PosInfInterval!Date(Date(1999, 5, 4))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow bool <a name="isAfter"></a><u>isAfter</u>(in NegInfInterval!(TP) <i>interval</i>);
</div></dt>
<dd>Whether this <i>interval</i> is after the given <i>interval</i> and does not intersect
        it.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>NegInfInterval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to check against this <i>interval</i>.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">isAfter</span>(
            NegInfInterval!Date(Date(1996, 1, 2))));

<span class="d_keyword">assert</span>(!PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">isAfter</span>(
            NegInfInterval!Date(Date(2000, 7, 1))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure bool <a name="intersects"></a><u>intersects</u>(in Interval!(TP) <i>interval</i>);
</div></dt>
<dd>Whether the given <i>interval</i> overlaps this <i>interval</i>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Interval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to check for intersection with this <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given <i>interval</i> is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">intersects</span>(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

<span class="d_keyword">assert</span>(PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">intersects</span>(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));

<span class="d_keyword">assert</span>(!PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">intersects</span>(
            Interval!Date(Date(1989, 3, 1), Date(1996, 1, 2))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow bool <a name="intersects"></a><u>intersects</u>(in PosInfInterval <i>interval</i>);
</div></dt>
<dd>Whether the given <i>interval</i> overlaps this <i>interval</i>.
<p></p>
Always returns <b>true</b> because two intervals going to positive infinity
        always overlap.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>PosInfInterval <i>interval</i></td>
<td valign=top>The <i>interval</i> to check for intersection with this
                       <i>interval</i>.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">intersects</span>(
            PosInfInterval!Date(Date(1990, 1, 7))));

<span class="d_keyword">assert</span>(PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">intersects</span>(
            PosInfInterval!Date(Date(1999, 5, 4))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow bool <a name="intersects"></a><u>intersects</u>(in NegInfInterval!(TP) <i>interval</i>);
</div></dt>
<dd>Whether the given <i>interval</i> overlaps this <i>interval</i>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>NegInfInterval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to check for intersection with this
                       <i>interval</i>.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">intersects</span>(
            NegInfInterval!Date(Date(1996, 1, 2))));

<span class="d_keyword">assert</span>(PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">intersects</span>(
            NegInfInterval!Date(Date(2000, 7, 1))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const Interval!(TP) <a name="intersection"></a><u>intersection</u>(in Interval!(TP) <i>interval</i>);
</div></dt>
<dd>Returns the <a name="intersection"></a><u>intersection</u> of two intervals
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Interval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to intersect with this <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the two intervals do not intersect or if
            the given <i>interval</i> is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">intersection</span>(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==
       Interval!Date(Date(1996, 1 , 2), Date(2000, 8, 2)));

<span class="d_keyword">assert</span>(PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">intersection</span>(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))) ==
       Interval!Date(Date(1999, 1 , 12), Date(2011, 9, 17)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow PosInfInterval <a name="intersection"></a><u>intersection</u>(in PosInfInterval <i>interval</i>);
</div></dt>
<dd>Returns the <a name="intersection"></a><u>intersection</u> of two intervals
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>PosInfInterval <i>interval</i></td>
<td valign=top>The <i>interval</i> to intersect with this <i>interval</i>.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">intersection</span>(
            PosInfInterval!Date(Date(1990, 7, 6))) ==
       PosInfInterval!Date(Date(1996, 1 , 2)));

<span class="d_keyword">assert</span>(PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">intersection</span>(
            PosInfInterval!Date(Date(1999, 1, 12))) ==
       PosInfInterval!Date(Date(1999, 1 , 12)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const Interval!(TP) <a name="intersection"></a><u>intersection</u>(in NegInfInterval!(TP) <i>interval</i>);
</div></dt>
<dd>Returns the <a name="intersection"></a><u>intersection</u> of two intervals
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>NegInfInterval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to intersect with this <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the two intervals do not intersect.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">intersection</span>(
            NegInfInterval!Date(Date(1999, 7, 6))) ==
       Interval!Date(Date(1996, 1 , 2), Date(1999, 7, 6)));

<span class="d_keyword">assert</span>(PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">intersection</span>(
            NegInfInterval!Date(Date(2013, 1, 12))) ==
       Interval!Date(Date(1996, 1 , 2), Date(2013, 1, 12)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure bool <a name="isAdjacent"></a><u>isAdjacent</u>(in Interval!(TP) <i>interval</i>);
</div></dt>
<dd>Whether the given <i>interval</i> is adjacent to this <i>interval</i>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Interval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to check whether its adjecent to this
                       <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given <i>interval</i> is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">isAdjacent</span>(
            Interval!Date(Date(1989, 3, 1), Date(1996, 1, 2))));

<span class="d_keyword">assert</span>(!PosInfInterval!Date(Date(1999, 1, 12)).<span class="d_psymbol">isAdjacent</span>(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow bool <a name="isAdjacent"></a><u>isAdjacent</u>(in PosInfInterval <i>interval</i>);
</div></dt>
<dd>Whether the given <i>interval</i> is adjacent to this <i>interval</i>.
<p></p>
Always returns <b>false</b> because two intervals going to positive infinity
        can never be adjacent to one another.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>PosInfInterval <i>interval</i></td>
<td valign=top>The <i>interval</i> to check whether its adjecent to this
                       <i>interval</i>.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">isAdjacent</span>(
            PosInfInterval!Date(Date(1990, 1, 7))));

<span class="d_keyword">assert</span>(!PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">isAdjacent</span>(
            PosInfInterval!Date(Date(1996, 1, 2))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow bool <a name="isAdjacent"></a><u>isAdjacent</u>(in NegInfInterval!(TP) <i>interval</i>);
</div></dt>
<dd>Whether the given <i>interval</i> is adjacent to this <i>interval</i>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>NegInfInterval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to check whether its adjecent to this
                       <i>interval</i>.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">isAdjacent</span>(
            NegInfInterval!Date(Date(1996, 1, 2))));

<span class="d_keyword">assert</span>(!PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">isAdjacent</span>(
            NegInfInterval!Date(Date(2000, 7, 1))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const PosInfInterval <a name="merge"></a><u>merge</u>(in Interval!(TP) <i>interval</i>);
</div></dt>
<dd>Returns the union of two intervals
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Interval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to <a name="merge"></a><u>merge</u> with this <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the two intervals do not intersect and are
            not adjacent or if the given <i>interval</i> is empty.

<p></p>
<b>Note:</b><br>
There is no overload for <span class="d_inlinecode"><a name="merge"></a><u>merge</u></span> which takes a
            <span class="d_inlinecode">NegInfInterval</span>. This is because you can't have an <i>interval</i>
            which goes from negative infinity to positive infinity.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">merge</span>(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==
       PosInfInterval!Date(Date(1990, 7 , 6)));

<span class="d_keyword">assert</span>(PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">merge</span>(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))) ==
       PosInfInterval!Date(Date(1996, 1 , 2)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow PosInfInterval <a name="merge"></a><u>merge</u>(in PosInfInterval <i>interval</i>);
</div></dt>
<dd>Returns the union of two intervals
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>PosInfInterval <i>interval</i></td>
<td valign=top>The <i>interval</i> to <a name="merge"></a><u>merge</u> with this <i>interval</i>.</td></tr>
</table><p></p>
<b>Note:</b><br>
There is no overload for <span class="d_inlinecode"><a name="merge"></a><u>merge</u></span> which takes a
            <span class="d_inlinecode">NegInfInterval</span>. This is because you can't have an <i>interval</i>
            which goes from negative infinity to positive infinity.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">merge</span>(
            PosInfInterval!Date(Date(1990, 7, 6))) ==
       PosInfInterval!Date(Date(1990, 7 , 6)));

<span class="d_keyword">assert</span>(PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">merge</span>(
            PosInfInterval!Date(Date(1999, 1, 12))) ==
       PosInfInterval!Date(Date(1996, 1 , 2)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure PosInfInterval <a name="span"></a><u>span</u>(in Interval!(TP) <i>interval</i>);
</div></dt>
<dd>Returns an <i>interval</i> that covers from the earliest time point of two
        intervals up to (but not including) the latest time point of two
        intervals.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Interval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to create a <a name="span"></a><u>span</u> together with this
                       <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given <i>interval</i> is empty.

<p></p>
<b>Note:</b><br>
There is no overload for <span class="d_inlinecode"><a name="span"></a><u>span</u></span> which takes a
            <span class="d_inlinecode">NegInfInterval</span>. This is because you can't have an <i>interval</i>
            which goes from negative infinity to positive infinity.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">span</span>(
            Interval!Date(Date(500, 8, 9), Date(1602, 1, 31))) ==
       PosInfInterval!Date(Date(500, 8, 9)));

<span class="d_keyword">assert</span>(PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">span</span>(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==
       PosInfInterval!Date(Date(1990, 7 , 6)));

<span class="d_keyword">assert</span>(PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">span</span>(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))) ==
       PosInfInterval!Date(Date(1996, 1 , 2)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow PosInfInterval <a name="span"></a><u>span</u>(in PosInfInterval <i>interval</i>);
</div></dt>
<dd>Returns an <i>interval</i> that covers from the earliest time point of two
        intervals up to (but not including) the latest time point of two
        intervals.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>PosInfInterval <i>interval</i></td>
<td valign=top>The <i>interval</i> to create a <a name="span"></a><u>span</u> together with this
                       <i>interval</i>.</td></tr>
</table><p></p>
<b>Note:</b><br>
There is no overload for <span class="d_inlinecode"><a name="span"></a><u>span</u></span> which takes a
            <span class="d_inlinecode">NegInfInterval</span>. This is because you can't have an <i>interval</i>
            which goes from negative infinity to positive infinity.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">span</span>(
            PosInfInterval!Date(Date(1990, 7, 6))) ==
       PosInfInterval!Date(Date(1990, 7 , 6)));

<span class="d_keyword">assert</span>(PosInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">span</span>(
            PosInfInterval!Date(Date(1999, 1, 12))) ==
       PosInfInterval!Date(Date(1996, 1 , 2)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">pure nothrow void <a name="shift"></a><u>shift</u>(D)(D <i>duration</i>);
</div></dt>
<dd>Shifts the <span class="d_inlinecode">begin</span> of this interval forward or backwards in time by
        the given duration (a positive duration shifts the interval forward; a
        negative duration shifts it backward). Effectively, it does
        <span class="d_inlinecode">begin += duration</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>duration</td>
<td valign=top>The duration to <a name="shift"></a><u>shift</u> the interval by.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> interval1 = PosInfInterval!Date(Date(1996, 1, 2));
<span class="d_keyword">auto</span> interval2 = PosInfInterval!Date(Date(1996, 1, 2));

interval1.<span class="d_psymbol">shift</span>(dur!<span class="d_string">"days"</span>(50));
<span class="d_keyword">assert</span>(interval1 == PosInfInterval!Date(Date(1996, 2, 21)));

interval2.<span class="d_psymbol">shift</span>(dur!<span class="d_string">"days"</span>(-50));
<span class="d_keyword">assert</span>(interval2 == PosInfInterval!Date(Date(1995, 11, 13)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">void <a name="shift"></a><u>shift</u>(T)(T <i>years</i>, T <i>months</i> = 0, AllowDayOverflow <i>allowOverflow</i> = AllowDayOverflow.yes);
</div></dt>
<dd>Shifts the <span class="d_inlinecode">begin</span> of this interval forward or backwards in time
            by the given number of years and/or months (a positive number of years
            and months shifts the interval forward; a negative number shifts it
            backward). It adds the years the given years and months to
            <span class="d_inlinecode">begin</span>. It effectively calls <span class="d_inlinecode">add!"years"()</span> and then
            <span class="d_inlinecode">add!"months"()</span> on <span class="d_inlinecode">begin</span> with the given number of years and
            months.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>years</td>
<td valign=top>The number of years to <a name="shift"></a><u>shift</u> the interval by.</td></tr>
<tr><td valign=top>months</td>
<td valign=top>The number of months to <a name="shift"></a><u>shift</u> the interval by.</td></tr>
<tr><td valign=top>allowOverflow</td>
<td valign=top>Whether the days should be allowed to overflow
                                on <span class="d_inlinecode">begin</span>, causing its month to increment.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if this interval is empty or if the
                resulting interval would be invalid.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> interval1 = PosInfInterval!Date(Date(1996, 1, 2));
<span class="d_keyword">auto</span> interval2 = PosInfInterval!Date(Date(1996, 1, 2));

interval1.<span class="d_psymbol">shift</span>(dur!<span class="d_string">"days"</span>(50));
<span class="d_keyword">assert</span>(interval1 == PosInfInterval!Date(Date(1996, 2, 21)));

interval2.<span class="d_psymbol">shift</span>(dur!<span class="d_string">"days"</span>(-50));
<span class="d_keyword">assert</span>(interval2 == PosInfInterval!Date(Date(1995, 11, 13)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">pure nothrow void <a name="expand"></a><u>expand</u>(D)(D <i>duration</i>);
</div></dt>
<dd>Expands the interval backwards in time. Effectively, it does
        <span class="d_inlinecode">begin -= duration</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>duration</td>
<td valign=top>The duration to <a name="expand"></a><u>expand</u> the interval by.</td></tr>
<tr><td valign=top>dir</td>
<td valign=top>The direction in time to <a name="expand"></a><u>expand</u> the interval.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> interval1 = PosInfInterval!Date(Date(1996, 1, 2));
<span class="d_keyword">auto</span> interval2 = PosInfInterval!Date(Date(1996, 1, 2));

interval1.<span class="d_psymbol">expand</span>(dur!<span class="d_string">"days"</span>(2));
<span class="d_keyword">assert</span>(interval1 == PosInfInterval!Date(Date(1995, 12, 31)));

interval2.<span class="d_psymbol">expand</span>(dur!<span class="d_string">"days"</span>(-2));
<span class="d_keyword">assert</span>(interval2 == PosInfInterval!Date(Date(1996, 1, 4)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">void <a name="expand"></a><u>expand</u>(T)(T <i>years</i>, T <i>months</i> = 0, AllowDayOverflow <i>allowOverflow</i> = AllowDayOverflow.yes);
</div></dt>
<dd>Expands the interval forwards and/or backwards in time. Effectively,
            it subtracts the given number of months/years from <span class="d_inlinecode">begin</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>years</td>
<td valign=top>The number of years to <a name="expand"></a><u>expand</u> the interval by.</td></tr>
<tr><td valign=top>months</td>
<td valign=top>The number of months to <a name="expand"></a><u>expand</u> the interval by.</td></tr>
<tr><td valign=top>allowOverflow</td>
<td valign=top>Whether the days should be allowed to overflow
                                on <span class="d_inlinecode">begin</span>, causing its month to increment.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if this interval is empty or if the
                resulting interval would be invalid.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> interval1 = PosInfInterval!Date(Date(1996, 1, 2));
<span class="d_keyword">auto</span> interval2 = PosInfInterval!Date(Date(1996, 1, 2));

interval1.<span class="d_psymbol">expand</span>(2);
<span class="d_keyword">assert</span>(interval1 == PosInfInterval!Date(Date(1994, 1, 2)));

interval2.<span class="d_psymbol">expand</span>(-2);
<span class="d_keyword">assert</span>(interval2 == PosInfInterval!Date(Date(1998, 1, 2)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const PosInfIntervalRange!(TP) <a name="fwdRange"></a><u>fwdRange</u>(TP delegate(in TP) <i>func</i>, PopFirst <i>popFirst</i> = PopFirst.no);
</div></dt>
<dd>Returns a range which iterates forward over the interval, starting
        at <span class="d_inlinecode">begin</span>, using <span class="d_param"><i>func</i></span> to generate each successive time
        point.
<p></p>
The range's <span class="d_inlinecode">front</span> is the interval's <span class="d_inlinecode">begin</span>. <span class="d_param"><i>func</i></span> is
        used to generate the next <span class="d_inlinecode">front</span> when <span class="d_inlinecode">popFront</span> is called. If
        <span class="d_param"><i>popFirst</i></span> is <span class="d_inlinecode">PopFirst.yes</span>, then <span class="d_inlinecode">popFront</span> is called
        before the range is returned (so that <span class="d_inlinecode">front</span> is a time point which
        <span class="d_param"><i>func</i></span> would generate).
<p></p>


        If <span class="d_param"><i>func</i></span> ever generates a time point less than or equal to the
        current <span class="d_inlinecode">front</span> of the range, then a <span class="d_inlinecode">DateTimeException</span> will be
        thrown.
<p></p>


        There are helper functions in this module which generate common
        delegates to pass to <span class="d_inlinecode"><a name="fwdRange"></a><u>fwdRange</u></span>. Their documentation starts with
        "Range-generating function," so you can easily search for them.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>TP delegate(in TP) <i>func</i></td>
<td valign=top>The function used to generate the time points of the
                       range over the interval.</td></tr>
<tr><td valign=top>PopFirst <i>popFirst</i></td>
<td valign=top>Whether <span class="d_inlinecode">popFront</span> should be called on the range
                       before returning it.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if this interval is empty.

<p></p>
<b>Warning:</b><br>
<span class="d_param"><i>func</i></span> must be logically pure. Ideally, <span class="d_param"><i>func</i></span>
            would be a function pointer to a pure function, but forcing
            <span class="d_param"><i>func</i></span> to be pure is far too restrictive to be useful, and
            in order to have the ease of use of having functions which generate
            functions to pass to <span class="d_inlinecode"><a name="fwdRange"></a><u>fwdRange</u></span>, <span class="d_param"><i>func</i></span> must be a
            delegate.
<p></p>


            If <span class="d_param"><i>func</i></span> retains state which changes as it is called, then
            some algorithms will not work correctly, because the range's
            <span class="d_inlinecode">save</span> will have failed to have really saved the range's state.
            So, if you want to avoid such bugs, don't pass a delegate which is
            not logically pure to <span class="d_inlinecode"><a name="fwdRange"></a><u>fwdRange</u></span>. If <span class="d_param"><i>func</i></span> is given the
            same time point with two different calls, it must return the same
            result both times.
<p></p>


            Of course, none of the functions in this module have this problem,
            so it's only relevant if you're creating your own delegate.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> interval = PosInfInterval!Date(Date(2010, 9, 1));
<span class="d_keyword">auto</span> <span class="d_param">func</span> = (<span class="d_keyword">in</span> Date date) <span class="d_comment">//For iterating over even-numbered days.
</span>            {
                <span class="d_keyword">if</span>((date.day &amp; 1) == 0)
                    <span class="d_keyword">return</span> date + dur!<span class="d_string">"days"</span>(2);

                <span class="d_keyword">return</span> date + dur!<span class="d_string">"days"</span>(1);
            };
<span class="d_keyword">auto</span> range = interval.<span class="d_psymbol">fwdRange</span>(<span class="d_param">func</span>);

<span class="d_comment">//An odd day. Using PopFirst.yes would have made this Date(2010, 9, 2).
</span><span class="d_keyword">assert</span>(range.front == Date(2010, 9, 1));

range.popFront();
<span class="d_keyword">assert</span>(range.front == Date(2010, 9, 2));

range.popFront();
<span class="d_keyword">assert</span>(range.front == Date(2010, 9, 4));

range.popFront();
<span class="d_keyword">assert</span>(range.front == Date(2010, 9, 6));

range.popFront();
<span class="d_keyword">assert</span>(range.front == Date(2010, 9, 8));

range.popFront();
<span class="d_keyword">assert</span>(!range.empty);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const nothrow string <a name="toString"></a><u>toString</u>();
</div></dt>
<dd>Converts this interval to a string.<p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">struct <a name="NegInfInterval"></a><u>NegInfInterval</u>(TP);
</div></dt>
<dd>Represents an interval of time which has negative infinity as its starting
    point.
<p></p>
Any ranges which iterate over a <span class="d_inlinecode"><a name="NegInfInterval"></a><u>NegInfInterval</u></span> are infinite. So, the
    main purpose of using <span class="d_inlinecode"><a name="NegInfInterval"></a><u>NegInfInterval</u></span> is to create an infinite range
    which starts at negative infinity and goes to a fixed end point. You would
    then iterate over it in reverse.<p></p>

<dl><dt><div class="d_decl">pure nothrow auto this(in TP <i>end</i>);
</div></dt>
<dd><b>Parameters:</b><table class=parms><tr><td valign=top>begin</td>
<td valign=top>The time point which begins the interval.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> interval = PosInfInterval!Date(Date(1996, 1, 2));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">pure nothrow NegInfInterval <a name="opAssign"></a><u>opAssign</u>(ref const NegInfInterval <i>rhs</i>);
</div></dt>
<dd><b>Parameters:</b><table class=parms><tr><td valign=top>NegInfInterval <i>rhs</i></td>
<td valign=top>The <span class="d_inlinecode">NegInfInterval</span> to assign to this one.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">pure nothrow NegInfInterval <a name="opAssign"></a><u>opAssign</u>(NegInfInterval <i>rhs</i>);
</div></dt>
<dd><b>Parameters:</b><table class=parms><tr><td valign=top>NegInfInterval <i>rhs</i></td>
<td valign=top>The <span class="d_inlinecode">NegInfInterval</span> to assign to this one.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">const pure nothrow TP <a name="end"></a><u>end</u>();
</div></dt>
<dd>The <a name="end"></a><u>end</u> point of the interval. It is excluded from the interval.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">end</span> == Date(2012, 3, 1));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">pure nothrow void <a name="end"></a><u>end</u>(TP <i>timePoint</i>);
</div></dt>
<dd>The <a name="end"></a><u>end</u> point of the interval. It is excluded from the interval.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>TP <i>timePoint</i></td>
<td valign=top>The time point to set <a name="end"></a><u>end</u> to.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">const pure nothrow bool <a name="empty"></a><u>empty</u>();
</div></dt>
<dd>Whether the interval's length is 0. Always returns <b>false</b>.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!NegInfInterval!Date(Date(1996, 1, 2)).<span class="d_psymbol">empty</span>);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow bool <a name="contains"></a><u>contains</u>(TP <i>timePoint</i>);
</div></dt>
<dd>Whether the given time point is within this interval.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>TP <i>timePoint</i></td>
<td valign=top>The time point to check for inclusion in this interval.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">contains</span>(Date(1994, 12, 24)));
<span class="d_keyword">assert</span>(NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">contains</span>(Date(2000, 1, 5)));
<span class="d_keyword">assert</span>(!NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">contains</span>(Date(2012, 3, 1)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure bool <a name="contains"></a><u>contains</u>(in Interval!(TP) <i>interval</i>);
</div></dt>
<dd>Whether the given <i>interval</i> is completely within this <i>interval</i>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Interval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to check for inclusion in this <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given <i>interval</i> is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">contains</span>(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

<span class="d_keyword">assert</span>(NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">contains</span>(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));

<span class="d_keyword">assert</span>(!NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">contains</span>(
            Interval!Date(Date(1998, 2, 28), Date(2013, 5, 1))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow bool <a name="contains"></a><u>contains</u>(in PosInfInterval!(TP) <i>interval</i>);
</div></dt>
<dd>Whether the given <i>interval</i> is completely within this <i>interval</i>.
<p></p>
Always returns <b>false</b> because an <i>interval</i> beginning at negative
        infinity can never contain an <i>interval</i> going to positive infinity.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>PosInfInterval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to check for inclusion in this <i>interval</i>.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">contains</span>(
            PosInfInterval!Date(Date(1999, 5, 4))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow bool <a name="contains"></a><u>contains</u>(in NegInfInterval <i>interval</i>);
</div></dt>
<dd>Whether the given <i>interval</i> is completely within this <i>interval</i>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>NegInfInterval <i>interval</i></td>
<td valign=top>The <i>interval</i> to check for inclusion in this <i>interval</i>.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">contains</span>(
            NegInfInterval!Date(Date(1996, 5, 4))));

<span class="d_keyword">assert</span>(!NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">contains</span>(
            NegInfInterval!Date(Date(2013, 7, 9))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow bool <a name="isBefore"></a><u>isBefore</u>(in TP <i>timePoint</i>);
</div></dt>
<dd>Whether this interval is before the given time point.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>TP <i>timePoint</i></td>
<td valign=top>The time point to check whether this interval is
                        before it.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">isBefore</span>(Date(1994, 12, 24)));
<span class="d_keyword">assert</span>(!NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">isBefore</span>(Date(2000, 1, 5)));
<span class="d_keyword">assert</span>(NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">isBefore</span>(Date(2012, 3, 1)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure bool <a name="isBefore"></a><u>isBefore</u>(in Interval!(TP) <i>interval</i>);
</div></dt>
<dd>Whether this <i>interval</i> is before the given <i>interval</i> and does not
        intersect it.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Interval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to check for against this <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given <i>interval</i> is empty

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">isBefore</span>(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

<span class="d_keyword">assert</span>(!NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">isBefore</span>(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));

<span class="d_keyword">assert</span>(NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">isBefore</span>(
            Interval!Date(Date(2022, 10, 19), Date(2027, 6, 3))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow bool <a name="isBefore"></a><u>isBefore</u>(in PosInfInterval!(TP) <i>interval</i>);
</div></dt>
<dd>Whether this <i>interval</i> is before the given <i>interval</i> and does not
        intersect it.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>PosInfInterval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to check for against this <i>interval</i>.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">isBefore</span>(
            PosInfInterval!Date(Date(1999, 5, 4))));

<span class="d_keyword">assert</span>(NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">isBefore</span>(
            PosInfInterval!Date(Date(2012, 3, 1))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow bool <a name="isBefore"></a><u>isBefore</u>(in NegInfInterval <i>interval</i>);
</div></dt>
<dd>Whether this <i>interval</i> is before the given <i>interval</i> and does not
        intersect it.
<p></p>
Always returns <b>false</b> because an <i>interval</i> beginning at negative
        infinity can never be before another <i>interval</i> beginning at negative
        infinity.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>NegInfInterval <i>interval</i></td>
<td valign=top>The <i>interval</i> to check for against this <i>interval</i>.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">isBefore</span>(
            NegInfInterval!Date(Date(1996, 5, 4))));

<span class="d_keyword">assert</span>(!NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">isBefore</span>(
            NegInfInterval!Date(Date(2013, 7, 9))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow bool <a name="isAfter"></a><u>isAfter</u>(in TP <i>timePoint</i>);
</div></dt>
<dd>Whether this interval is after the given time point.
<p></p>
Always returns <b>false</b> because an interval beginning at negative infinity
        can never be after any time point.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>TP <i>timePoint</i></td>
<td valign=top>The time point to check whether this interval is after
                        it.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">isAfter</span>(Date(1994, 12, 24)));
<span class="d_keyword">assert</span>(!NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">isAfter</span>(Date(2000, 1, 5)));
<span class="d_keyword">assert</span>(!NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">isAfter</span>(Date(2012, 3, 1)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure bool <a name="isAfter"></a><u>isAfter</u>(in Interval!(TP) <i>interval</i>);
</div></dt>
<dd>Whether this <i>interval</i> is after the given <i>interval</i> and does not
        intersect it.
<p></p>
Always returns <b>false</b> (unless the given <i>interval</i> is empty) because an
        <i>interval</i> beginning at negative infinity can never be after any other
        <i>interval</i>.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Interval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to check against this <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given <i>interval</i> is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">isAfter</span>(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

<span class="d_keyword">assert</span>(!NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">isAfter</span>(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));

<span class="d_keyword">assert</span>(!NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">isAfter</span>(
            Interval!Date(Date(2022, 10, 19), Date(2027, 6, 3))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow bool <a name="isAfter"></a><u>isAfter</u>(in PosInfInterval!(TP) <i>interval</i>);
</div></dt>
<dd>Whether this <i>interval</i> is after the given <i>interval</i> and does not intersect
        it.
<p></p>
Always returns <b>false</b> because an <i>interval</i> beginning at negative infinity
        can never be after any other <i>interval</i>.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>PosInfInterval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to check against this <i>interval</i>.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">isAfter</span>(
            PosInfInterval!Date(Date(1999, 5, 4))));

<span class="d_keyword">assert</span>(!NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">isAfter</span>(
            PosInfInterval!Date(Date(2012, 3, 1))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow bool <a name="isAfter"></a><u>isAfter</u>(in NegInfInterval <i>interval</i>);
</div></dt>
<dd>Whether this <i>interval</i> is after the given <i>interval</i> and does not intersect
        it.
<p></p>
Always returns <b>false</b> because an <i>interval</i> beginning at negative infinity
        can never be after any other <i>interval</i>.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>NegInfInterval <i>interval</i></td>
<td valign=top>The <i>interval</i> to check against this <i>interval</i>.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">isAfter</span>(
            NegInfInterval!Date(Date(1996, 5, 4))));

<span class="d_keyword">assert</span>(!NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">isAfter</span>(
            NegInfInterval!Date(Date(2013, 7, 9))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure bool <a name="intersects"></a><u>intersects</u>(in Interval!(TP) <i>interval</i>);
</div></dt>
<dd>Whether the given <i>interval</i> overlaps this <i>interval</i>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Interval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to check for intersection with this <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given <i>interval</i> is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">intersects</span>(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

<span class="d_keyword">assert</span>(NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">intersects</span>(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));

<span class="d_keyword">assert</span>(!NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">intersects</span>(
            Interval!Date(Date(2022, 10, 19), Date(2027, 6, 3))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow bool <a name="intersects"></a><u>intersects</u>(in PosInfInterval!(TP) <i>interval</i>);
</div></dt>
<dd>Whether the given <i>interval</i> overlaps this <i>interval</i>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>PosInfInterval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to check for intersection with this
                       <i>interval</i>.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">intersects</span>(
            PosInfInterval!Date(Date(1999, 5, 4))));

<span class="d_keyword">assert</span>(!NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">intersects</span>(
            PosInfInterval!Date(Date(2012, 3, 1))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow bool <a name="intersects"></a><u>intersects</u>(in NegInfInterval!(TP) <i>interval</i>);
</div></dt>
<dd>Whether the given <i>interval</i> overlaps this <i>interval</i>.
<p></p>
Always returns <b>true</b> because two intervals beginning at negative infinity
        always overlap.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>NegInfInterval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to check for intersection with this <i>interval</i>.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">intersects</span>(
            NegInfInterval!Date(Date(1996, 5, 4))));

<span class="d_keyword">assert</span>(NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">intersects</span>(
            NegInfInterval!Date(Date(2013, 7, 9))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const Interval!(TP) <a name="intersection"></a><u>intersection</u>(in Interval!(TP) <i>interval</i>);
</div></dt>
<dd>Returns the <a name="intersection"></a><u>intersection</u> of two intervals
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Interval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to intersect with this <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the two intervals do not intersect or if
            the given <i>interval</i> is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">intersection</span>(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==
       Interval!Date(Date(1990, 7 , 6), Date(2000, 8, 2)));

<span class="d_keyword">assert</span>(NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">intersection</span>(
            Interval!Date(Date(1999, 1, 12), Date(2015, 9, 2))) ==
       Interval!Date(Date(1999, 1 , 12), Date(2012, 3, 1)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const Interval!(TP) <a name="intersection"></a><u>intersection</u>(in PosInfInterval!(TP) <i>interval</i>);
</div></dt>
<dd>Returns the <a name="intersection"></a><u>intersection</u> of two intervals
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>PosInfInterval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to intersect with this <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the two intervals do not intersect.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">intersection</span>(
            PosInfInterval!Date(Date(1990, 7, 6))) ==
       Interval!Date(Date(1990, 7 , 6), Date(2012, 3, 1)));

<span class="d_keyword">assert</span>(NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">intersection</span>(
            PosInfInterval!Date(Date(1999, 1, 12))) ==
       Interval!Date(Date(1999, 1 , 12), Date(2012, 3, 1)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const nothrow NegInfInterval <a name="intersection"></a><u>intersection</u>(in NegInfInterval <i>interval</i>);
</div></dt>
<dd>Returns the <a name="intersection"></a><u>intersection</u> of two intervals
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>NegInfInterval <i>interval</i></td>
<td valign=top>The <i>interval</i> to intersect with this <i>interval</i>.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">intersection</span>(
            NegInfInterval!Date(Date(1999, 7, 6))) ==
       NegInfInterval!Date(Date(1999, 7 , 6)));

<span class="d_keyword">assert</span>(NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">intersection</span>(
            NegInfInterval!Date(Date(2013, 1, 12))) ==
       NegInfInterval!Date(Date(2012, 3 , 1)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure bool <a name="isAdjacent"></a><u>isAdjacent</u>(in Interval!(TP) <i>interval</i>);
</div></dt>
<dd>Whether the given <i>interval</i> is adjacent to this <i>interval</i>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Interval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to check whether its adjecent to this
                       <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given <i>interval</i> is empty.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">isAdjacent</span>(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

<span class="d_keyword">assert</span>(!NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">isAdjacent</span>(
            Interval!Date(Date(1999, 1, 12), Date(2012, 3, 1))));

<span class="d_keyword">assert</span>(NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">isAdjacent</span>(
            Interval!Date(Date(2012, 3, 1), Date(2019, 2, 2))));

<span class="d_keyword">assert</span>(!NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">isAdjacent</span>(
            Interval!Date(Date(2022, 10, 19), Date(2027, 6, 3))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow bool <a name="isAdjacent"></a><u>isAdjacent</u>(in PosInfInterval!(TP) <i>interval</i>);
</div></dt>
<dd>Whether the given <i>interval</i> is adjacent to this <i>interval</i>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>PosInfInterval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to check whether its adjecent to this
                       <i>interval</i>.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">isAdjacent</span>(
            PosInfInterval!Date(Date(1999, 5, 4))));

<span class="d_keyword">assert</span>(NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">isAdjacent</span>(
            PosInfInterval!Date(Date(2012, 3, 1))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow bool <a name="isAdjacent"></a><u>isAdjacent</u>(in NegInfInterval <i>interval</i>);
</div></dt>
<dd>Whether the given <i>interval</i> is adjacent to this <i>interval</i>.
<p></p>
Always returns <b>false</b> because two intervals beginning at negative
        infinity can never be adjacent to one another.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>NegInfInterval <i>interval</i></td>
<td valign=top>The <i>interval</i> to check whether its adjecent to this
                       <i>interval</i>.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(!NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">isAdjacent</span>(
            NegInfInterval!Date(Date(1996, 5, 4))));

<span class="d_keyword">assert</span>(!NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">isAdjacent</span>(
            NegInfInterval!Date(Date(2012, 3, 1))));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const NegInfInterval <a name="merge"></a><u>merge</u>(in Interval!(TP) <i>interval</i>);
</div></dt>
<dd>Returns the union of two intervals
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Interval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to <a name="merge"></a><u>merge</u> with this <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the two intervals do not intersect and are
            not adjacent or if the given <i>interval</i> is empty.

<p></p>
<b>Note:</b><br>
There is no overload for <span class="d_inlinecode"><a name="merge"></a><u>merge</u></span> which takes a
            <span class="d_inlinecode">PosInfInterval</span>. This is because you can't have an <i>interval</i>
            which goes from negative infinity to positive infinity.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">merge</span>(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==
       NegInfInterval!Date(Date(2012, 3 , 1)));

<span class="d_keyword">assert</span>(NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">merge</span>(
            Interval!Date(Date(1999, 1, 12), Date(2015, 9, 2))) ==
       NegInfInterval!Date(Date(2015, 9 , 2)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow NegInfInterval <a name="merge"></a><u>merge</u>(in NegInfInterval <i>interval</i>);
</div></dt>
<dd>Returns the union of two intervals
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>NegInfInterval <i>interval</i></td>
<td valign=top>The <i>interval</i> to <a name="merge"></a><u>merge</u> with this <i>interval</i>.</td></tr>
</table><p></p>
<b>Note:</b><br>
There is no overload for <span class="d_inlinecode"><a name="merge"></a><u>merge</u></span> which takes a
            <span class="d_inlinecode">PosInfInterval</span>. This is because you can't have an <i>interval</i>
            which goes from negative infinity to positive infinity.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">merge</span>(
            NegInfInterval!Date(Date(1999, 7, 6))) ==
       NegInfInterval!Date(Date(2012, 3 , 1)));

<span class="d_keyword">assert</span>(NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">merge</span>(
            NegInfInterval!Date(Date(2013, 1, 12))) ==
       NegInfInterval!Date(Date(2013, 1 , 12)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure NegInfInterval <a name="span"></a><u>span</u>(in Interval!(TP) <i>interval</i>);
</div></dt>
<dd>Returns an <i>interval</i> that covers from the earliest time point of two
        intervals up to (but not including) the latest time point of two
        intervals.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Interval!(TP) <i>interval</i></td>
<td valign=top>The <i>interval</i> to create a <a name="span"></a><u>span</u> together with this
                       <i>interval</i>.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given <i>interval</i> is empty.

<p></p>
<b>Note:</b><br>
There is no overload for <span class="d_inlinecode"><a name="span"></a><u>span</u></span> which takes a
            <span class="d_inlinecode">PosInfInterval</span>. This is because you can't have an <i>interval</i>
            which goes from negative infinity to positive infinity.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">span</span>(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==
       NegInfInterval!Date(Date(2012, 3 , 1)));

<span class="d_keyword">assert</span>(NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">span</span>(
            Interval!Date(Date(1999, 1, 12), Date(2015, 9, 2))) ==
       NegInfInterval!Date(Date(2015, 9 , 2)));

<span class="d_keyword">assert</span>(NegInfInterval!Date(Date(1600, 1, 7)).<span class="d_psymbol">span</span>(
            Interval!Date(Date(2012, 3, 11), Date(2017, 7, 1))) ==
       NegInfInterval!Date(Date(2017, 7 , 1)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow NegInfInterval <a name="span"></a><u>span</u>(in NegInfInterval <i>interval</i>);
</div></dt>
<dd>Returns an <i>interval</i> that covers from the earliest time point of two
        intervals up to (but not including) the latest time point of two
        intervals.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>NegInfInterval <i>interval</i></td>
<td valign=top>The <i>interval</i> to create a <a name="span"></a><u>span</u> together with this
                       <i>interval</i>.</td></tr>
</table><p></p>
<b>Note:</b><br>
There is no overload for <span class="d_inlinecode"><a name="span"></a><u>span</u></span> which takes a
            <span class="d_inlinecode">PosInfInterval</span>. This is because you can't have an <i>interval</i>
            which goes from negative infinity to positive infinity.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">span</span>(
            NegInfInterval!Date(Date(1999, 7, 6))) ==
       NegInfInterval!Date(Date(2012, 3 , 1)));

<span class="d_keyword">assert</span>(NegInfInterval!Date(Date(2012, 3, 1)).<span class="d_psymbol">span</span>(
            NegInfInterval!Date(Date(2013, 1, 12))) ==
       NegInfInterval!Date(Date(2013, 1 , 12)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">pure nothrow void <a name="shift"></a><u>shift</u>(D)(D <i>duration</i>);
</div></dt>
<dd>Shifts the <span class="d_inlinecode">end</span> of this interval forward or backwards in time by the
        given duration (a positive duration shifts the interval forward; a
        negative duration shifts it backward). Effectively, it does
        <span class="d_inlinecode">end += duration</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>duration</td>
<td valign=top>The duration to <a name="shift"></a><u>shift</u> the interval by.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> interval1 = NegInfInterval!Date(Date(2012, 4, 5));
<span class="d_keyword">auto</span> interval2 = NegInfInterval!Date(Date(2012, 4, 5));

interval1.<span class="d_psymbol">shift</span>(dur!<span class="d_string">"days"</span>(50));
<span class="d_keyword">assert</span>(interval1 == NegInfInterval!Date(Date(2012, 5, 25)));

interval2.<span class="d_psymbol">shift</span>(dur!<span class="d_string">"days"</span>(-50));
<span class="d_keyword">assert</span>(interval2 == NegInfInterval!Date( Date(2012, 2, 15)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">void <a name="shift"></a><u>shift</u>(T)(T <i>years</i>, T <i>months</i> = 0, AllowDayOverflow <i>allowOverflow</i> = AllowDayOverflow.yes);
</div></dt>
<dd>Shifts the <span class="d_inlinecode">end</span> of this interval forward or backwards in time by
            the given number of years and/or months (a positive number of years
            and months shifts the interval forward; a negative number shifts it
            backward). It adds the years the given years and months to end. It
            effectively calls <span class="d_inlinecode">add!"years"()</span> and then <span class="d_inlinecode">add!"months"()</span>
            on end with the given number of years and months.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>years</td>
<td valign=top>The number of years to <a name="shift"></a><u>shift</u> the interval by.</td></tr>
<tr><td valign=top>months</td>
<td valign=top>The number of months to <a name="shift"></a><u>shift</u> the interval by.</td></tr>
<tr><td valign=top>allowOverflow</td>
<td valign=top>Whether the days should be allowed to overflow
                                on <span class="d_inlinecode">end</span>, causing its month to increment.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if empty is <b>true</b> or if the resulting
                interval would be invalid.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> interval1 = NegInfInterval!Date(Date(2012, 3, 1));
<span class="d_keyword">auto</span> interval2 = NegInfInterval!Date(Date(2012, 3, 1));

interval1.<span class="d_psymbol">shift</span>(2);
<span class="d_keyword">assert</span>(interval1 == NegInfInterval!Date(Date(2014, 3, 1)));

interval2.<span class="d_psymbol">shift</span>(-2);
<span class="d_keyword">assert</span>(interval2 == NegInfInterval!Date(Date(2010, 3, 1)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">pure nothrow void <a name="expand"></a><u>expand</u>(D)(D <i>duration</i>);
</div></dt>
<dd>Expands the interval forwards in time. Effectively, it does
        <span class="d_inlinecode">end += duration</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>duration</td>
<td valign=top>The duration to <a name="expand"></a><u>expand</u> the interval by.</td></tr>
<tr><td valign=top>dir</td>
<td valign=top>The direction in time to <a name="expand"></a><u>expand</u> the interval.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> interval1 = NegInfInterval!Date(Date(2012, 3, 1));
<span class="d_keyword">auto</span> interval2 = NegInfInterval!Date(Date(2012, 3, 1));

interval1.<span class="d_psymbol">expand</span>(dur!<span class="d_string">"days"</span>(2));
<span class="d_keyword">assert</span>(interval1 == NegInfInterval!Date(Date(2012, 3, 3)));

interval2.<span class="d_psymbol">expand</span>(dur!<span class="d_string">"days"</span>(-2));
<span class="d_keyword">assert</span>(interval2 == NegInfInterval!Date(Date(2012, 2, 28)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">void <a name="expand"></a><u>expand</u>(T)(T <i>years</i>, T <i>months</i> = 0, AllowDayOverflow <i>allowOverflow</i> = AllowDayOverflow.yes);
</div></dt>
<dd>Expands the interval forwards and/or backwards in time. Effectively,
            it adds the given number of months/years to end.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>years</td>
<td valign=top>The number of years to <a name="expand"></a><u>expand</u> the interval by.</td></tr>
<tr><td valign=top>months</td>
<td valign=top>The number of months to <a name="expand"></a><u>expand</u> the interval by.</td></tr>
<tr><td valign=top>allowOverflow</td>
<td valign=top>Whether the days should be allowed to overflow
                                on <span class="d_inlinecode">end</span>, causing their month to increment.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if empty is <b>true</b> or if the resulting
                interval would be invalid.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> interval1 = NegInfInterval!Date(Date(2012, 3, 1));
<span class="d_keyword">auto</span> interval2 = NegInfInterval!Date(Date(2012, 3, 1));

interval1.<span class="d_psymbol">expand</span>(2);
<span class="d_keyword">assert</span>(interval1 == NegInfInterval!Date(Date(2014, 3, 1)));

interval2.<span class="d_psymbol">expand</span>(-2);
<span class="d_keyword">assert</span>(interval2 == NegInfInterval!Date(Date(2010, 3, 1)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const NegInfIntervalRange!(TP) <a name="bwdRange"></a><u>bwdRange</u>(TP delegate(in TP) <i>func</i>, PopFirst <i>popFirst</i> = PopFirst.no);
</div></dt>
<dd>Returns a range which iterates backwards over the interval, starting
        at <span class="d_inlinecode">end</span>, using <span class="d_param"><i>func</i></span> to generate each successive time
        point.
<p></p>
The range's <span class="d_inlinecode">front</span> is the interval's <span class="d_inlinecode">end</span>. <span class="d_param"><i>func</i></span> is
        used to generate the next <span class="d_inlinecode">front</span> when <span class="d_inlinecode">popFront</span> is called. If
        <span class="d_param"><i>popFirst</i></span> is <span class="d_inlinecode">PopFirst.yes</span>, then <span class="d_inlinecode">popFront</span> is called
        before the range is returned (so that <span class="d_inlinecode">front</span> is a time point which
        <span class="d_param"><i>func</i></span> would generate).
<p></p>


        If <span class="d_param"><i>func</i></span> ever generates a time point greater than or equal to
        the current <span class="d_inlinecode">front</span> of the range, then a <span class="d_inlinecode">DateTimeException</span> will
        be thrown.
<p></p>


        There are helper functions in this module which generate common
        delegates to pass to <span class="d_inlinecode"><a name="bwdRange"></a><u>bwdRange</u></span>. Their documentation starts with
        "Range-generating function," so you can easily search for them.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>TP delegate(in TP) <i>func</i></td>
<td valign=top>The function used to generate the time points of the
                       range over the interval.</td></tr>
<tr><td valign=top>PopFirst <i>popFirst</i></td>
<td valign=top>Whether <span class="d_inlinecode">popFront</span> should be called on the range
                       before returning it.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if this interval is empty.

<p></p>
<b>Warning:</b><br>
<span class="d_param"><i>func</i></span> must be logically pure. Ideally, <span class="d_param"><i>func</i></span>
            would be a function pointer to a pure function, but forcing
            <span class="d_param"><i>func</i></span> to be pure is far too restrictive to be useful, and
            in order to have the ease of use of having functions which generate
            functions to pass to <span class="d_inlinecode">fwdRange</span>, <span class="d_param"><i>func</i></span> must be a
            delegate.
<p></p>


            If <span class="d_param"><i>func</i></span> retains state which changes as it is called, then
            some algorithms will not work correctly, because the range's
            <span class="d_inlinecode">save</span> will have failed to have really saved the range's state.
            So, if you want to avoid such bugs, don't pass a delegate which is
            not logically pure to <span class="d_inlinecode">fwdRange</span>. If <span class="d_param"><i>func</i></span> is given the
            same time point with two different calls, it must return the same
            result both times.
<p></p>


            Of course, none of the functions in this module have this problem,
            so it's only relevant if you're creating your own delegate.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> interval = NegInfInterval!Date(Date(2010, 9, 9));
<span class="d_keyword">auto</span> <span class="d_param">func</span> = (<span class="d_keyword">in</span> Date date) <span class="d_comment">//For iterating over even-numbered days.
</span>            {
                <span class="d_keyword">if</span>((date.day &amp; 1) == 0)
                    <span class="d_keyword">return</span> date - dur!<span class="d_string">"days"</span>(2);

                <span class="d_keyword">return</span> date - dur!<span class="d_string">"days"</span>(1);
            };
<span class="d_keyword">auto</span> range = interval.<span class="d_psymbol">bwdRange</span>(<span class="d_param">func</span>);

<span class="d_keyword">assert</span>(range.front == Date(2010, 9, 9)); <span class="d_comment">//An odd day. Using PopFirst.yes would have made this Date(2010, 9, 8).
</span>
range.popFront();
<span class="d_keyword">assert</span>(range.front == Date(2010, 9, 8));

range.popFront();
<span class="d_keyword">assert</span>(range.front == Date(2010, 9, 6));

range.popFront();
<span class="d_keyword">assert</span>(range.front == Date(2010, 9, 4));

range.popFront();
<span class="d_keyword">assert</span>(range.front == Date(2010, 9, 2));

range.popFront();
<span class="d_keyword">assert</span>(!range.empty);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">const nothrow string <a name="toString"></a><u>toString</u>();
</div></dt>
<dd>Converts this interval to a string.<p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">nothrow TP delegate(in TP) <a name="everyDayOfWeek"></a><u>everyDayOfWeek</u>(TP, Direction dir = Direction.fwd)(DayOfWeek <i>dayOfWeek</i>);
</div></dt>
<dd>Range-generating function.
<p></p>
Returns a delegate which returns the next time point with the given
    <span class="d_inlinecode">DayOfWeek</span> in a range.
<p></p>


    Using this delegate allows you to iterate over successive time points which
    are all the same day of the week. e.g. passing <span class="d_inlinecode">DayOfWeek.mon</span> to
    <span class="d_inlinecode"><a name="everyDayOfWeek"></a><u>everyDayOfWeek</u></span> would result in a delegate which could be used to
    iterate over all of the Mondays in a range.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>dir</td>
<td valign=top>The direction to iterate in. If passing the return value to
                    <span class="d_inlinecode">fwdRange</span>, use <span class="d_inlinecode">Direction.fwd</span>. If passing it to
                    <span class="d_inlinecode">bwdRange</span>, use <span class="d_inlinecode">Direction.bwd</span>.</td></tr>
<tr><td valign=top>dayOfWeek</td>
<td valign=top>The week that each time point in the range will be.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> interval = Interval!Date(Date(2010, 9, 2), Date(2010, 9, 27));
<span class="d_keyword">auto</span> func = <span class="d_psymbol">everyDayOfWeek</span>!Date(DayOfWeek.mon);
<span class="d_keyword">auto</span> range = interval.fwdRange(func);

<span class="d_comment">//A Thursday. Using PopFirst.yes would have made this Date(2010, 9, 6).
</span><span class="d_keyword">assert</span>(range.front == Date(2010, 9, 2));

range.popFront();
<span class="d_keyword">assert</span>(range.front == Date(2010, 9, 6));

range.popFront();
<span class="d_keyword">assert</span>(range.front == Date(2010, 9, 13));

range.popFront();
<span class="d_keyword">assert</span>(range.front == Date(2010, 9, 20));

range.popFront();
<span class="d_keyword">assert</span>(range.empty);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">TP delegate(in TP) <a name="everyMonth"></a><u>everyMonth</u>(TP, Direction dir = Direction.fwd)(int <i>month</i>);
</div></dt>
<dd>Range-generating function.
<p></p>
Returns a delegate which returns the next time point with the given month
    which would be reached by adding months to the given time point.
<p></p>


    So, using this delegate allows you to iterate over successive time points
    which are in the same month but different years. For example, you could
    iterate over each successive December 25th in an interval by starting with a
    date which had the 25th as its day and passed <span class="d_inlinecode">Month.dec</span> to
    <span class="d_inlinecode"><a name="everyMonth"></a><u>everyMonth</u></span> to create the delegate.
<p></p>


    Since it wouldn't really make sense to be iterating over a specific month
    and end up with some of the time points in the succeeding month or two years
    after the previous time point, <span class="d_inlinecode">AllowDayOverflow.no</span> is always used when
    calculating the next time point.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>dir</td>
<td valign=top>The direction to iterate in. If passing the return value to
                <span class="d_inlinecode">fwdRange</span>, use <span class="d_inlinecode">Direction.fwd</span>. If passing it to
                <span class="d_inlinecode">bwdRange</span>, use <span class="d_inlinecode">Direction.bwd</span>.</td></tr>
<tr><td valign=top>month</td>
<td valign=top>The month that each time point in the range will be in.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> interval = Interval!Date(Date(2000, 1, 30), Date(2004, 8, 5));
<span class="d_keyword">auto</span> func = <span class="d_psymbol">everyMonth</span>!(Date)(Month.feb);
<span class="d_keyword">auto</span> range = interval.fwdRange(func);

<span class="d_comment">//Using PopFirst.yes would have made this Date(2010, 2, 29).
</span><span class="d_keyword">assert</span>(range.front == Date(2000, 1, 30));

range.popFront();
<span class="d_keyword">assert</span>(range.front == Date(2000, 2, 29));

range.popFront();
<span class="d_keyword">assert</span>(range.front == Date(2001, 2, 28));

range.popFront();
<span class="d_keyword">assert</span>(range.front == Date(2002, 2, 28));

range.popFront();
<span class="d_keyword">assert</span>(range.front == Date(2003, 2, 28));

range.popFront();
<span class="d_keyword">assert</span>(range.front == Date(2004, 2, 28));

range.popFront();
<span class="d_keyword">assert</span>(range.empty);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">nothrow TP delegate(in TP) <a name="everyDuration"></a><u>everyDuration</u>(TP, Direction dir = Direction.fwd, D)(D <i>duration</i>);
</div></dt>
<dd>Range-generating function.
<p></p>
Returns a delegate which returns the next time point which is the given
    duration later.
<p></p>


    Using this delegate allows you to iterate over successive time points which
    are apart by the given duration e.g. passing <span class="d_inlinecode">dur!"days"(3)</span> to
    <span class="d_inlinecode"><a name="everyDuration"></a><u>everyDuration</u></span> would result in a delegate which could be used to iterate
    over a range of days which are each 3 days apart.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>dir</td>
<td valign=top>The direction to iterate in. If passing the return value to
                   <span class="d_inlinecode">fwdRange</span>, use <span class="d_inlinecode">Direction.fwd</span>. If passing it to
                   <span class="d_inlinecode">bwdRange</span>, use <span class="d_inlinecode">Direction.bwd</span>.</td></tr>
<tr><td valign=top>duration</td>
<td valign=top>The duration which separates each successive time point in
                   the range.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> interval = Interval!Date(Date(2010, 9, 2), Date(2010, 9, 27));
<span class="d_keyword">auto</span> func = <span class="d_psymbol">everyDuration</span>!Date(dur!<span class="d_string">"days"</span>(8));
<span class="d_keyword">auto</span> range = interval.fwdRange(func);

<span class="d_comment">//Using PopFirst.yes would have made this Date(2010, 9, 10).
</span><span class="d_keyword">assert</span>(range.front == Date(2010, 9, 2));

range.popFront();
<span class="d_keyword">assert</span>(range.front == Date(2010, 9, 10));

range.popFront();
<span class="d_keyword">assert</span>(range.front == Date(2010, 9, 18));

range.popFront();
<span class="d_keyword">assert</span>(range.front == Date(2010, 9, 26));

range.popFront();
<span class="d_keyword">assert</span>(range.empty);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">nothrow TP delegate(in TP) <a name="everyDuration"></a><u>everyDuration</u>(TP, Direction dir = Direction.fwd, D)(int <i>years</i>, int <i>months</i> = 0, AllowDayOverflow <i>allowOverflow</i> = AllowDayOverflow.yes, D <i>duration</i> = dur!("days")(0));
</div></dt>
<dd>Range-generating function.
<p></p>
Returns a delegate which returns the next time point which is the given
    number of years, month, and duration later.
<p></p>


    The difference between this version of <span class="d_inlinecode"><a name="everyDuration"></a><u>everyDuration</u></span> and the version
    which just takes a <span class="d_inlinecode">Duration</span> is that this one also takes the number of
    years and months (along with an <span class="d_inlinecode">AllowDayOverflow</span> to indicate whether
    adding years and months should allow the days to overflow).
<p></p>


    Note that if iterating forward, <span class="d_inlinecode">add!"years"()</span> is called on the given
    time point, then <span class="d_inlinecode">add!"months"()</span>, and finally the duration is added
    to it. However, if iterating backwards, the duration is added first, then
    <span class="d_inlinecode">add!"months"()</span> is called, and finally <span class="d_inlinecode">add!"years"()</span> is called.
    That way, going backwards generates close to the same time points that
    iterating forward does, but since adding years and months is not entirely
    reversible (due to possible day overflow, regardless of whether
    <span class="d_inlinecode">AllowDayOverflow.yes</span> or <span class="d_inlinecode">AllowDayOverflow.no</span> is used), it can't be
    guaranteed that iterating backwards will give you the same time points as
    iterating forward would have (even assuming that the end of the range is a
    time point which would be returned by the delegate when iterating forward
    from <span class="d_inlinecode">begin</span>).

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>dir</td>
<td valign=top>The direction to iterate in. If passing the return
                        value to <span class="d_inlinecode">fwdRange</span>, use <span class="d_inlinecode">Direction.fwd</span>. If
                        passing it to <span class="d_inlinecode">bwdRange</span>, use <span class="d_inlinecode">Direction.bwd</span>.</td></tr>
<tr><td valign=top>years</td>
<td valign=top>The number of years to add to the time point passed to
                        the delegate.</td></tr>
<tr><td valign=top>months</td>
<td valign=top>The number of months to add to the time point passed to
                        the delegate.</td></tr>
<tr><td valign=top>allowOverflow</td>
<td valign=top>Whether the days should be allowed to overflow on
                        <span class="d_inlinecode">begin</span> and <span class="d_inlinecode">end</span>, causing their month to
                        increment.</td></tr>
<tr><td valign=top>duration</td>
<td valign=top>The duration to add to the time point passed to the
                        delegate.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> interval = Interval!Date(Date(2010, 9, 2), Date(2025, 9, 27));
<span class="d_keyword">auto</span> func = <span class="d_psymbol">everyDuration</span>!Date(4, 1, AllowDayOverflow.yes, dur!<span class="d_string">"days"</span>(2));
<span class="d_keyword">auto</span> range = interval.fwdRange(func);

<span class="d_comment">//Using PopFirst.yes would have made this Date(2014, 10, 12).
</span><span class="d_keyword">assert</span>(range.front == Date(2010, 9, 2));

range.popFront();
<span class="d_keyword">assert</span>(range.front == Date(2014, 10, 4));

range.popFront();
<span class="d_keyword">assert</span>(range.front == Date(2018, 11, 6));

range.popFront();
<span class="d_keyword">assert</span>(range.front == Date(2022, 12, 8));

range.popFront();
<span class="d_keyword">assert</span>(range.empty);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">struct <a name="IntervalRange"></a><u>IntervalRange</u>(TP,Direction dir) if (isTimePoint!(TP) &amp;&amp; dir != Direction.both);
</div></dt>
<dd>A range over an <span class="d_inlinecode">Interval</span>.
<p></p>
<span class="d_inlinecode"><a name="IntervalRange"></a><u>IntervalRange</u></span> is only ever constructed by <span class="d_inlinecode">Interval</span>. However, when
    it is constructed, it is given a function, <span class="d_inlinecode">func</span>, which is used to
    generate the time points which are iterated over. <span class="d_inlinecode">func</span> takes a time
    point and returns a time point of the same type. So, for instance, if you
    had an <span class="d_inlinecode">Interval!Date</span>, and you wanted to iterate over all of the days in
    that interval, you would pass a function to <span class="d_inlinecode">Interval</span>'s <span class="d_inlinecode">fwdRange</span>
    where that function took a <span class="d_inlinecode">Date</span> and returned a <span class="d_inlinecode">Date</span> which was one
    day later. That function would then be used by <span class="d_inlinecode"><a name="IntervalRange"></a><u>IntervalRange</u></span>'s
    <span class="d_inlinecode">popFront</span> to iterate over the <span class="d_inlinecode">Date</span>s in the interval.
<p></p>


    If <span class="d_inlinecode">dir == Direction.fwd</span>, then a range iterates forward in time, whereas
    if <span class="d_inlinecode">dir == Direction.bwd</span>, then it iterates backwards in time. So, if
    <span class="d_inlinecode">dir == Direction.fwd</span> then <span class="d_inlinecode">front == interval.begin</span>, whereas if
    <span class="d_inlinecode">dir == Direction.bwd</span> then <span class="d_inlinecode">front == interval.end</span>. <span class="d_inlinecode">func</span> must
    generate a time point going in the proper direction of iteration, or a
    <span class="d_inlinecode">DateTimeException</span> will be thrown. So, if you're iterating forward in
    time, the time point that <span class="d_inlinecode">func</span> generates must be later in time than the
    one passed to it. If it's either identical or earlier in time, then a
    <span class="d_inlinecode">DateTimeException</span> will be thrown. If you're iterating backwards, then
    the generated time point must be before the time point which was passed in.
<p></p>


    If the generated time point is ever passed the edge of the range in the
    proper direction, then the edge of that range will be used instead. So, if
    iterating forward, and the generated time point is past the interval's
    <span class="d_inlinecode">end</span>, then <span class="d_inlinecode">front</span> becomes <span class="d_inlinecode">end</span>. If iterating backwards, and the
    generated time point is before <span class="d_inlinecode">begin</span>, then <span class="d_inlinecode">front</span> becomes
    <span class="d_inlinecode">begin</span>. In either case, the range would then be empty.
<p></p>


    Also note that while normally the <span class="d_inlinecode">begin</span> of an interval is included in
    it and its <span class="d_inlinecode">end</span> is excluded from it, if <span class="d_inlinecode">dir == Direction.bwd</span>, then
    <span class="d_inlinecode">begin</span> is treated as excluded and <span class="d_inlinecode">end</span> is treated as included. This
    allows for the same behavior in both directions. This works because none of
    <span class="d_inlinecode">Interval</span>'s functions which care about whether <span class="d_inlinecode">begin</span> or <span class="d_inlinecode">end</span> is
    included or excluded are ever called by <span class="d_inlinecode"><a name="IntervalRange"></a><u>IntervalRange</u></span>. <span class="d_inlinecode">interval</span>
    returns a normal interval, regardless of whether <span class="d_inlinecode">dir == Direction.fwd</span>
    or if <span class="d_inlinecode">dir == Direction.bwd</span>, so any <span class="d_inlinecode">Interval</span> functions which are
    called on it which care about whether <span class="d_inlinecode">begin</span> or <span class="d_inlinecode">end</span> are included or
    excluded will treat <span class="d_inlinecode">begin</span> as included and <span class="d_inlinecode">end</span> as excluded.<p></p>

<dl><dt><div class="d_decl">pure nothrow IntervalRange <a name="opAssign"></a><u>opAssign</u>(ref IntervalRange <i>rhs</i>);
</div></dt>
<dd><b>Parameters:</b><table class=parms><tr><td valign=top>IntervalRange <i>rhs</i></td>
<td valign=top>The <span class="d_inlinecode">IntervalRange</span> to assign to this one.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">const pure nothrow bool <a name="empty"></a><u>empty</u>();
</div></dt>
<dd>Whether this <span class="d_inlinecode">IntervalRange</span> is <a name="empty"></a><u>empty</u>.<p></p>

</dd>
<dt><div class="d_decl">const pure TP <a name="front"></a><u>front</u>();
</div></dt>
<dd>The first time point in the range.
<p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the range is empty.<p></p>

</dd>
<dt><div class="d_decl">void <a name="popFront"></a><u>popFront</u>();
</div></dt>
<dd>Pops <span class="d_inlinecode">front</span> from the range, using <span class="d_inlinecode">func</span> to generate the next
        time point in the range. If the generated time point is beyond the edge
        of the range, then <span class="d_inlinecode">front</span> is set to that edge, and the range is then
        empty. So, if iterating forwards, and the generated time point is
        greater than the interval's <span class="d_inlinecode">end</span>, then <span class="d_inlinecode">front</span> is set to
        <span class="d_inlinecode">end</span>. If iterating backwards, and the generated time point is less
        than the interval's <span class="d_inlinecode">begin</span>, then <span class="d_inlinecode">front</span> is set to <span class="d_inlinecode">begin</span>.
<p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the range is empty or if the generated
            time point is in the wrong direction (i.e. if you're iterating
            forward and the generated time point is before <span class="d_inlinecode">front</span>, or if
            you're iterating backwards, and the generated time point is after
            <span class="d_inlinecode">front</span>).<p></p>

</dd>
<dt><div class="d_decl">pure nothrow IntervalRange <a name="save"></a><u>save</u>();
</div></dt>
<dd>Returns a copy of <span class="d_inlinecode">this</span>.<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow Interval!(TP) <a name="interval"></a><u>interval</u>();
</div></dt>
<dd>The <a name="interval"></a><u>interval</u> that this <span class="d_inlinecode">IntervalRange</span> currently covers.<p></p>

</dd>
<dt><div class="d_decl">pure nothrow @property TP delegate(in TP) <a name="func"></a><u>func</u>();
</div></dt>
<dd>The function used to generate the next time point in the range.<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow Direction <a name="direction"></a><u>direction</u>();
</div></dt>
<dd>The <span class="d_inlinecode">Direction</span> that this range iterates in.<p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">struct <a name="PosInfIntervalRange"></a><u>PosInfIntervalRange</u>(TP) if (isTimePoint!(TP));
</div></dt>
<dd>A range over a <span class="d_inlinecode">PosInfInterval</span>. It is an infinite range.
<p></p>
<span class="d_inlinecode"><a name="PosInfIntervalRange"></a><u>PosInfIntervalRange</u></span> is only ever constructed by <span class="d_inlinecode">PosInfInterval</span>.
    However, when it is constructed, it is given a function, <span class="d_inlinecode">func</span>, which
    is used to generate the time points which are iterated over. <span class="d_inlinecode">func</span>
    takes a time point and returns a time point of the same type. So, for
    instance, if you had a <span class="d_inlinecode">PosInfInterval!Date</span>, and you wanted to iterate
    over all of the days in that interval, you would pass a function to
    <span class="d_inlinecode">PosInfInterval</span>'s <span class="d_inlinecode">fwdRange</span> where that function took a <span class="d_inlinecode">Date</span> and
    returned a <span class="d_inlinecode">Date</span> which was one day later. That function would then be
    used by <span class="d_inlinecode"><a name="PosInfIntervalRange"></a><u>PosInfIntervalRange</u></span>'s <span class="d_inlinecode">popFront</span> to iterate over the
    <span class="d_inlinecode">Date</span>s in the interval - though obviously, since the range is infinite,
    you would use a function such as <span class="d_inlinecode">std.range.take</span> with it rather than
    iterating over <i>all</i> of the dates.
<p></p>


    As the interval goes to positive infinity, the range is always iterated over
    forwards, never backwards. <span class="d_inlinecode">func</span> must generate a time point going in
    the proper direction of iteration, or a <span class="d_inlinecode">DateTimeException</span> will be
    thrown. So, the time points that <span class="d_inlinecode">func</span> generates must be later in time
    than the one passed to it. If it's either identical or earlier in time, then
    a <span class="d_inlinecode">DateTimeException</span> will be thrown.<p></p>

<dl><dt><div class="d_decl">pure nothrow PosInfIntervalRange <a name="opAssign"></a><u>opAssign</u>(ref PosInfIntervalRange <i>rhs</i>);
</div></dt>
<dd><b>Parameters:</b><table class=parms><tr><td valign=top>PosInfIntervalRange <i>rhs</i></td>
<td valign=top>The <span class="d_inlinecode">PosInfIntervalRange</span> to assign to this one.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">bool <a name="empty"></a><u>empty</u>;
</div></dt>
<dd>This is an infinite range, so it is never <a name="empty"></a><u>empty</u>.<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow TP <a name="front"></a><u>front</u>();
</div></dt>
<dd>The first time point in the range.<p></p>

</dd>
<dt><div class="d_decl">void <a name="popFront"></a><u>popFront</u>();
</div></dt>
<dd>Pops <span class="d_inlinecode">front</span> from the range, using <span class="d_inlinecode">func</span> to generate the next
        time point in the range.
<p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the generated time point is less than
            <span class="d_inlinecode">front</span>.<p></p>

</dd>
<dt><div class="d_decl">pure nothrow PosInfIntervalRange <a name="save"></a><u>save</u>();
</div></dt>
<dd>Returns a copy of <span class="d_inlinecode">this</span>.<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow PosInfInterval!(TP) <a name="interval"></a><u>interval</u>();
</div></dt>
<dd>The <a name="interval"></a><u>interval</u> that this range currently covers.<p></p>

</dd>
<dt><div class="d_decl">pure nothrow @property TP delegate(in TP) <a name="func"></a><u>func</u>();
</div></dt>
<dd>The function used to generate the next time point in the range.<p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">struct <a name="NegInfIntervalRange"></a><u>NegInfIntervalRange</u>(TP) if (isTimePoint!(TP));
</div></dt>
<dd>A range over a <span class="d_inlinecode">NegInfInterval</span>. It is an infinite range.
<p></p>
<span class="d_inlinecode"><a name="NegInfIntervalRange"></a><u>NegInfIntervalRange</u></span> is only ever constructed by <span class="d_inlinecode">NegInfInterval</span>.
    However, when it is constructed, it is given a function, <span class="d_inlinecode">func</span>, which
    is used to generate the time points which are iterated over. <span class="d_inlinecode">func</span>
    takes a time point and returns a time point of the same type. So, for
    instance, if you had a <span class="d_inlinecode">NegInfInterval!Date</span>, and you wanted to iterate
    over all of the days in that interval, you would pass a function to
    <span class="d_inlinecode">NegInfInterval</span>'s <span class="d_inlinecode">bwdRange</span> where that function took a <span class="d_inlinecode">Date</span> and
    returned a <span class="d_inlinecode">Date</span> which was one day earlier. That function would then be
    used by <span class="d_inlinecode"><a name="NegInfIntervalRange"></a><u>NegInfIntervalRange</u></span>'s <span class="d_inlinecode">popFront</span> to iterate over the
    <span class="d_inlinecode">Date</span>s in the interval - though obviously, since the range is infinite,
    you would use a function such as <span class="d_inlinecode">std.range.take</span> with it rather than
    iterating over <i>all</i> of the dates.
<p></p>


    As the interval goes to negative infinity, the range is always iterated over
    backwards, never forwards. <span class="d_inlinecode">func</span> must generate a time point going in
    the proper direction of iteration, or a <span class="d_inlinecode">DateTimeException</span> will be
    thrown. So, the time points that <span class="d_inlinecode">func</span> generates must be earlier in time
    than the one passed to it. If it's either identical or later in time, then a
    <span class="d_inlinecode">DateTimeException</span> will be thrown.
<p></p>


    Also note that while normally the <span class="d_inlinecode">end</span> of an interval is excluded from
    it, <span class="d_inlinecode"><a name="NegInfIntervalRange"></a><u>NegInfIntervalRange</u></span> treats it as if it were included. This allows
    for the same behavior as you get with <span class="d_inlinecode">PosInfIntervalRange</span>. This works
    because none of <span class="d_inlinecode">NegInfInterval</span>'s functions which care about whether
    <span class="d_inlinecode">end</span> is included or excluded are ever called by
    <span class="d_inlinecode"><a name="NegInfIntervalRange"></a><u>NegInfIntervalRange</u></span>. <span class="d_inlinecode">interval</span> returns a normal interval, so any
    <span class="d_inlinecode">NegInfInterval</span> functions which are called on it which care about
    whether <span class="d_inlinecode">end</span> is included or excluded will treat <span class="d_inlinecode">end</span> as excluded.<p></p>

<dl><dt><div class="d_decl">pure nothrow NegInfIntervalRange <a name="opAssign"></a><u>opAssign</u>(ref NegInfIntervalRange <i>rhs</i>);
</div></dt>
<dd><b>Parameters:</b><table class=parms><tr><td valign=top>NegInfIntervalRange <i>rhs</i></td>
<td valign=top>The <span class="d_inlinecode">NegInfIntervalRange</span> to assign to this one.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">bool <a name="empty"></a><u>empty</u>;
</div></dt>
<dd>This is an infinite range, so it is never <a name="empty"></a><u>empty</u>.<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow TP <a name="front"></a><u>front</u>();
</div></dt>
<dd>The first time point in the range.<p></p>

</dd>
<dt><div class="d_decl">void <a name="popFront"></a><u>popFront</u>();
</div></dt>
<dd>Pops <span class="d_inlinecode">front</span> from the range, using <span class="d_inlinecode">func</span> to generate the next
        time point in the range.
<p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the generated time point is greater than
            <span class="d_inlinecode">front</span>.<p></p>

</dd>
<dt><div class="d_decl">pure nothrow NegInfIntervalRange <a name="save"></a><u>save</u>();
</div></dt>
<dd>Returns a copy of <span class="d_inlinecode">this</span>.<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow NegInfInterval!(TP) <a name="interval"></a><u>interval</u>();
</div></dt>
<dd>The <a name="interval"></a><u>interval</u> that this range currently covers.<p></p>

</dd>
<dt><div class="d_decl">pure nothrow @property TP delegate(in TP) <a name="func"></a><u>func</u>();
</div></dt>
<dd>The function used to generate the next time point in the range.<p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">abstract class <a name="TimeZone"></a><u>TimeZone</u>;
</div></dt>
<dd>Represents a time zone. It is used with <span class="d_inlinecode">SysTime</span> to indicate the time
    zone of a <span class="d_inlinecode">SysTime</span>.<p></p>

<dl><dt><div class="d_decl">const nothrow @property string <a name="name"></a><u>name</u>();
</div></dt>
<dd>The <a name="name"></a><u>name</u> of the time zone per the TZ Database. This is the <a name="name"></a><u>name</u> used to
        get a <span class="d_inlinecode">TimeZone</span> by <a name="name"></a><u>name</u> with <span class="d_inlinecode">TimeZone.getTimeZone</span>.
<p></p>
<b>See Also:</b><br><a href="http://en.wikipedia.org/wiki/Tz_database">Wikipedia entry on TZ
              Database</a>
            <a href="http://en.wikipedia.org/wiki/List_of_tz_database_time_zones">List of
              Time Zones</a><p></p>

</dd>
<dt><div class="d_decl">const nothrow @property string <a name="stdName"></a><u>stdName</u>();
</div></dt>
<dd>Typically, the abbreviation (generally 3 or 4 letters) for the time zone
        when DST is <i>not</i> in effect (e.g. PST). It is not necessarily unique.
<p></p>
However, on Windows, it may be the unabbreviated name (e.g. Pacific
        Standard Time). Regardless, it is not the same as name.<p></p>

</dd>
<dt><div class="d_decl">const nothrow @property string <a name="dstName"></a><u>dstName</u>();
</div></dt>
<dd>Typically, the abbreviation (generally 3 or 4 letters) for the time zone
        when DST <i>is</i> in effect (e.g. PDT). It is not necessarily unique.
<p></p>
However, on Windows, it may be the unabbreviated name (e.g. Pacific
        Daylight Time). Regardless, it is not the same as name.<p></p>

</dd>
<dt><div class="d_decl">abstract const nothrow @property bool <a name="hasDST"></a><u>hasDST</u>();
</div></dt>
<dd>Whether this time zone has Daylight Savings Time at any point in time.
        Note that for some time zone types it may not have DST for current dates
        but will still return <b>true</b> for <span class="d_inlinecode"><a name="hasDST"></a><u>hasDST</u></span> because the time zone did at
        some point have DST.<p></p>

</dd>
<dt><div class="d_decl">abstract const nothrow bool <a name="dstInEffect"></a><u>dstInEffect</u>(long <i>stdTime</i>);
</div></dt>
<dd>Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.
        in UTC time (i.e. std time) and returns whether DST is effect in this
        time zone at the given point in time.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>long <i>stdTime</i></td>
<td valign=top>The UTC time that needs to be checked for DST in this time
                      zone.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">abstract const nothrow long <a name="utcToTZ"></a><u>utcToTZ</u>(long <i>stdTime</i>);
</div></dt>
<dd>Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.
        in UTC time (i.e. std time) and converts it to this time zone's time.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>long <i>stdTime</i></td>
<td valign=top>The UTC time that needs to be adjusted to this time zone's
                      time.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">abstract const nothrow long <a name="tzToUTC"></a><u>tzToUTC</u>(long <i>adjTime</i>);
</div></dt>
<dd>Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.
        in this time zone's time and converts it to UTC (i.e. std time).
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>long <i>adjTime</i></td>
<td valign=top>The time in this time zone that needs to be adjusted to
                      UTC time.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">static immutable(TimeZone) <a name="getTimeZone"></a><u>getTimeZone</u>(string <i>name</i>);
</div></dt>
<dd>Returns a <span class="d_inlinecode">TimeZone</span> with the give <i>name</i> per the TZ Database.
<p></p>
This returns a <span class="d_inlinecode">PosixTimeZone</span> on Posix systems and a
        <span class="d_inlinecode">WindowsTimeZone</span> on Windows systems. If you want a
        <span class="d_inlinecode">PosixTimeZone</span> on Windows, then call <span class="d_inlinecode">PosixTimeZone.<a name="getTimeZone"></a><u>getTimeZone</u></span>
        directly and give it the location of the TZ Database time zone files on
        disk.
<p></p>


        On Windows, the given TZ Database <i>name</i> is converted to the corresponding
        time zone <i>name</i> on Windows prior to calling
        <span class="d_inlinecode">WindowsTimeZone.<a name="getTimeZone"></a><u>getTimeZone</u></span>. So, this function allows you to use
        the same time zone names on both Windows and Posix systems.

<p></p>
<b>See Also:</b><br><a href="http://en.wikipedia.org/wiki/Tz_database">Wikipedia entry on TZ
              Database</a>
            <a href="http://en.wikipedia.org/wiki/List_of_tz_database_time_zones">List of
              Time Zones</a>
            <a href="http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/zone_tzid.html">                  Windows &lt;-&gt; TZ Database Name Conversion Table</a>

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>string <i>name</i></td>
<td valign=top>The TZ Database <i>name</i> of the time zone that you're looking for.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given time zone could not be found.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> tz = TimeZone.<span class="d_psymbol">getTimeZone</span>(<span class="d_string">"America/Los_Angeles"</span>);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">static string[] <a name="getInstalledTZNames"></a><u>getInstalledTZNames</u>(string <i>subName</i> = "");
</div></dt>
<dd>Returns a list of the names of the time zones installed on the system.
<p></p>
You can provide a sub-name to narrow down the list of time zones (which
        will likely be in the thousands if you get them all). For example,
        if you pass in "America" as the sub-name, then only the time zones which
        begin with "America" will be returned.
<p></p>


        On Windows, this function will convert the Windows time zone names to
        the corresponding TZ Database names with
        <span class="d_inlinecode">windowsTZNameToTZDatabaseName</span>. If you want the actual Windows time
        zone names, use <span class="d_inlinecode">WindowsTimeZone.<a name="getInstalledTZNames"></a><u>getInstalledTZNames</u></span> directly.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>string <i>subName</i></td>
<td valign=top>The first part of the time zones that you want.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">FileException</span> on Posix systems if it fails to read from disk.
            <span class="d_inlinecode">DateTimeException</span> on Windows systems if it fails to read the
            registry.<p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">class <a name="LocalTime"></a><u>LocalTime</u>: std.datetime.TimeZone;
</div></dt>
<dd>A TimeZone which represents the current local time zone on
    the system running your program.
<p></p>
This uses the underlying C calls to adjust the time rather than using
    specific D code based off of system settings to calculate the time such as
    <span class="d_inlinecode">PosixTimeZone</span> and <span class="d_inlinecode">WindowsTimeZone</span> do. That also means that it will
    use whatever the current time zone is on the system, even if the system's
    time zone changes while the program is running.<p></p>

<dl><dt><div class="d_decl">static pure nothrow immutable(LocalTime) <a name="opCall"></a><u>opCall</u>();
</div></dt>
<dd><span class="d_inlinecode">LocalTime</span> is a singleton class. <span class="d_inlinecode">LocalTime</span> returns its only
        instance.<p></p>

</dd>
<dt><div class="d_decl">const nothrow @property string <a name="stdName"></a><u>stdName</u>();
</div></dt>
<dd>Typically, the abbreviation (generally 3 or 4 letters) for the time zone
        when DST is <i>not</i> in effect (e.g. PST). It is not necessarily unique.
<p></p>
However, on Windows, it may be the unabbreviated name (e.g. Pacific
        Standard Time). Regardless, it is not the same as name.
<p></p>


        This property is overridden because the local time of the system could
        change while the program is running and we need to determine it
        dynamically rather than it being fixed like it would be with most time
        zones.<p></p>

</dd>
<dt><div class="d_decl">const nothrow @property string <a name="dstName"></a><u>dstName</u>();
</div></dt>
<dd>Typically, the abbreviation (generally 3 or 4 letters) for the time zone
        when DST <i>is</i> in effect (e.g. PDT). It is not necessarily unique.
<p></p>
However, on Windows, it may be the unabbreviated name (e.g. Pacific
        Daylight Time). Regardless, it is not the same as name.
<p></p>


        This property is overridden because the local time of the system could
        change while the program is running and we need to determine it
        dynamically rather than it being fixed like it would be with most time
        zones.<p></p>

</dd>
<dt><div class="d_decl">const nothrow @property bool <a name="hasDST"></a><u>hasDST</u>();
</div></dt>
<dd>Whether this time zone has Daylight Savings Time at any point in time.
        Note that for some time zone types it may not have DST for current
        dates but will still return <b>true</b> for <span class="d_inlinecode"><a name="hasDST"></a><u>hasDST</u></span> because the time zone
        did at some point have DST.<p></p>

</dd>
<dt><div class="d_decl">const nothrow bool <a name="dstInEffect"></a><u>dstInEffect</u>(long <i>stdTime</i>);
</div></dt>
<dd>Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.
        in UTC time (i.e. std time) and returns whether DST is in effect in this
        time zone at the given point in time.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>long <i>stdTime</i></td>
<td valign=top>The UTC time that needs to be checked for DST in this time
                      zone.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">const nothrow long <a name="utcToTZ"></a><u>utcToTZ</u>(long <i>stdTime</i>);
</div></dt>
<dd>Returns hnsecs in the local time zone using the standard C function
        calls on Posix systems and the standard Windows system calls on Windows
        systems to adjust the time to the appropriate time zone from std time.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>long <i>stdTime</i></td>
<td valign=top>The UTC time that needs to be adjusted to this time zone's
                      time.</td></tr>
</table><p></p>
<b>See Also:</b><br><span class="d_inlinecode">TimeZone.<a name="utcToTZ"></a><u>utcToTZ</u></span><p></p>

</dd>
<dt><div class="d_decl">const nothrow long <a name="tzToUTC"></a><u>tzToUTC</u>(long <i>adjTime</i>);
</div></dt>
<dd>Returns std time using the standard C function calls on Posix systems
        and the standard Windows system calls on Windows systems to adjust the
        time to UTC from the appropriate time zone.
<p></p>
<b>See Also:</b><br><span class="d_inlinecode">TimeZone.<a name="tzToUTC"></a><u>tzToUTC</u></span>

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>long <i>adjTime</i></td>
<td valign=top>The time in this time zone that needs to be adjusted to
                      UTC time.</td></tr>
</table><p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">class <a name="UTC"></a><u>UTC</u>: std.datetime.TimeZone;
</div></dt>
<dd>A <span class="d_inlinecode">TimeZone</span> which represents <a name="UTC"></a><u>UTC</u>.<p></p>

<dl><dt><div class="d_decl">static pure nothrow immutable(UTC) <a name="opCall"></a><u>opCall</u>();
</div></dt>
<dd><span class="d_inlinecode">UTC</span> is a singleton class. <span class="d_inlinecode">UTC</span> returns its only instance.<p></p>

</dd>
<dt><div class="d_decl">const nothrow @property bool <a name="hasDST"></a><u>hasDST</u>();
</div></dt>
<dd>Always returns <b>false</b>.<p></p>

</dd>
<dt><div class="d_decl">const nothrow bool <a name="dstInEffect"></a><u>dstInEffect</u>(long <i>stdTime</i>);
</div></dt>
<dd>Always returns <b>false</b>.<p></p>

</dd>
<dt><div class="d_decl">const nothrow long <a name="utcToTZ"></a><u>utcToTZ</u>(long <i>stdTime</i>);
</div></dt>
<dd>Returns the given hnsecs without changing them at all.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>long <i>stdTime</i></td>
<td valign=top>The UTC time that needs to be adjusted to this time zone's
                      time.</td></tr>
</table><p></p>
<b>See Also:</b><br><span class="d_inlinecode">TimeZone.<a name="utcToTZ"></a><u>utcToTZ</u></span><p></p>

</dd>
<dt><div class="d_decl">const nothrow long <a name="tzToUTC"></a><u>tzToUTC</u>(long <i>adjTime</i>);
</div></dt>
<dd>Returns the given hnsecs without changing them at all.
<p></p>
<b>See Also:</b><br><span class="d_inlinecode">TimeZone.<a name="tzToUTC"></a><u>tzToUTC</u></span>

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>long <i>adjTime</i></td>
<td valign=top>The time in this time zone that needs to be adjusted to
                      UTC time.</td></tr>
</table><p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">class <a name="SimpleTimeZone"></a><u>SimpleTimeZone</u>: std.datetime.TimeZone;
</div></dt>
<dd>Represents a time zone with an offset (in minutes, west is negative) from
    UTC but no DST.
<p></p>
It's primarily used as the time zone in the result of <span class="d_inlinecode">SysTime</span>'s
    <span class="d_inlinecode">fromISOString</span>, <span class="d_inlinecode">fromISOExtString</span>, and <span class="d_inlinecode">fromSimpleString</span>.
<p></p>


    <span class="d_inlinecode">name</span> and <span class="d_inlinecode">dstName</span> are always the empty string since this time zone
    has no DST, and while it may be meant to represent a time zone which is in
    the TZ Database, obviously it's not likely to be following the exact rules
    of any of the time zones in the TZ Database, so it makes no sense to set it.<p></p>

<dl><dt><div class="d_decl">const nothrow @property bool <a name="hasDST"></a><u>hasDST</u>();
</div></dt>
<dd>Always returns <b>false</b>.<p></p>

</dd>
<dt><div class="d_decl">const nothrow bool <a name="dstInEffect"></a><u>dstInEffect</u>(long <i>stdTime</i>);
</div></dt>
<dd>Always returns <b>false</b>.<p></p>

</dd>
<dt><div class="d_decl">const nothrow long <a name="utcToTZ"></a><u>utcToTZ</u>(long <i>stdTime</i>);
</div></dt>
<dd>Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.
        in UTC time (i.e. std time) and converts it to this time zone's time.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>long <i>stdTime</i></td>
<td valign=top>The UTC time that needs to be adjusted to this time zone's
                      time.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">const nothrow long <a name="tzToUTC"></a><u>tzToUTC</u>(long <i>adjTime</i>);
</div></dt>
<dd>Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.
        in this time zone's time and converts it to UTC (i.e. std time).
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>long <i>adjTime</i></td>
<td valign=top>The time in this time zone that needs to be adjusted to
                      UTC time.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">immutable  this(int <i>utcOffset</i>, string <i>stdName</i> = "");
</div></dt>
<dd><b>Parameters:</b><table class=parms><tr><td valign=top>int <i>utcOffset</i></td>
<td valign=top>This time zone's offset from UTC in minutes with west of
                        UTC being negative (it is added to UTC to get the
                        adjusted time).</td></tr>
<tr><td valign=top>string <i>stdName</i></td>
<td valign=top>The <span class="d_inlinecode"><i>stdName</i></span> for this time zone.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">immutable int <a name="utcOffset"></a><u>utcOffset</u>;
</div></dt>
<dd>The number of minutes the offset from UTC is (negative is west of UTC,
        positive is east).<p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">class <a name="PosixTimeZone"></a><u>PosixTimeZone</u>: std.datetime.TimeZone;
</div></dt>
<dd>Represents a time zone from a TZ Database time zone file. Files from the TZ
    database are how Posix systems hold their time zone information.
    Unfortunately, Windows does not use the TZ Database. You can, however, use
    <span class="d_inlinecode"><a name="PosixTimeZone"></a><u>PosixTimeZone</u></span> (which reads its information from the TZ Database files
    on disk) on Windows if you provide the TZ Database files
    ( <a href="http://elsie.nci.nih.gov/pub/">Repository with the TZ Database files (tzdata)</a> )
    yourself and tell <span class="d_inlinecode"><a name="PosixTimeZone"></a><u>PosixTimeZone</u>.getTimeZone</span> where the directory holding
    them is.
<p></p>
To get a <span class="d_inlinecode"><a name="PosixTimeZone"></a><u>PosixTimeZone</u></span>, either call <span class="d_inlinecode"><a name="PosixTimeZone"></a><u>PosixTimeZone</u>.getTimeZone</span>
    (which will allow you to specify the location the time zone files) or call
    <span class="d_inlinecode">TimeZone.getTimeZone</span> (which will give you a <span class="d_inlinecode"><a name="PosixTimeZone"></a><u>PosixTimeZone</u></span> on Posix
    systems and a <span class="d_inlinecode">WindowsTimeZone</span> on Windows systems).

<p></p>
<b>Note:</b><br>
Unless your system's local time zone deals with leap seconds (which is
        highly unlikely), then only way that you will get a time zone which
        takes leap seconds into account is if you use <span class="d_inlinecode"><a name="PosixTimeZone"></a><u>PosixTimeZone</u></span> with a
        time zone whose name starts with "right/". Those time zone files do
        include leap seconds, and <span class="d_inlinecode"><a name="PosixTimeZone"></a><u>PosixTimeZone</u></span> will take them into account
        (though posix systems which use a "right/" time zone as their local time
        zone will <i>not</i> take leap seconds into account even though they're
        in the file).

<p></p>
<b>See Also:</b><br><a href="http://en.wikipedia.org/wiki/Tz_database">Wikipedia entry on TZ Database</a>
        <a href="http://en.wikipedia.org/wiki/List_of_tz_database_time_zones">List of Time
          Zones</a><p></p>

<dl><dt><div class="d_decl">const nothrow @property bool <a name="hasDST"></a><u>hasDST</u>();
</div></dt>
<dd>Whether this time zone has Daylight Savings Time at any point in time.
        Note that for some time zone types it may not have DST for current
        dates but will still return <b>true</b> for <span class="d_inlinecode"><a name="hasDST"></a><u>hasDST</u></span> because the time zone
        did at some point have DST.<p></p>

</dd>
<dt><div class="d_decl">const nothrow bool <a name="dstInEffect"></a><u>dstInEffect</u>(long <i>stdTime</i>);
</div></dt>
<dd>Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.
        in UTC time (i.e. std time) and returns whether DST is in effect in this
        time zone at the given point in time.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>long <i>stdTime</i></td>
<td valign=top>The UTC time that needs to be checked for DST in this time
                      zone.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">const nothrow long <a name="utcToTZ"></a><u>utcToTZ</u>(long <i>stdTime</i>);
</div></dt>
<dd>Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.
        in UTC time (i.e. std time) and converts it to this time zone's time.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>long <i>stdTime</i></td>
<td valign=top>The UTC time that needs to be adjusted to this time zone's
                      time.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">const nothrow long <a name="tzToUTC"></a><u>tzToUTC</u>(long <i>adjTime</i>);
</div></dt>
<dd>Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.
        in this time zone's time and converts it to UTC (i.e. std time).
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>long <i>adjTime</i></td>
<td valign=top>The time in this time zone that needs to be adjusted to
                      UTC time.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">string <a name="defaultTZDatabaseDir"></a><u>defaultTZDatabaseDir</u>;
</div></dt>
<dd>The default directory where the TZ Database files are. It's empty
            for Windows, since Windows doesn't have them.<p></p>

</dd>
<dt><div class="d_decl">static immutable(PosixTimeZone) <a name="getTimeZone"></a><u>getTimeZone</u>(string <i>name</i>, string <i>tzDatabaseDir</i> = defaultTZDatabaseDir);
</div></dt>
<dd>Returns a <span class="d_inlinecode">TimeZone</span> with the give <i>name</i> per the TZ Database. The time
        zone information is fetched from the TZ Database time zone files in the
        given directory.
<p></p>
<b>See Also:</b><br><a href="http://en.wikipedia.org/wiki/Tz_database">Wikipedia entry on TZ
              Database</a>
            <a href="http://en.wikipedia.org/wiki/List_of_tz_database_time_zones">List of
              Time Zones</a>

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>string <i>name</i></td>
<td valign=top>The TZ Database <i>name</i> of the time zone that you're
                            looking for.</td></tr>
<tr><td valign=top>string <i>tzDatabaseDir</i></td>
<td valign=top>The directory where the TZ Database files are
                            located. Because these files are not located on
                            Windows systems, you will need to provide them
                            yourself and give their location here if you wish to
                            use <span class="d_inlinecode">PosixTimeZone</span>s.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given time zone could not be found or
            <span class="d_inlinecode">FileException</span> if the TZ Database file could not be opened.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> tz = PosixTimeZone.<span class="d_psymbol">getTimeZone</span>(<span class="d_string">"America/Los_Angeles"</span>);

<span class="d_keyword">assert</span>(tz.<span class="d_param">name</span> == <span class="d_string">"America/Los_Angeles"</span>);
<span class="d_keyword">assert</span>(tz.stdName == <span class="d_string">"PST"</span>);
<span class="d_keyword">assert</span>(tz.dstName == <span class="d_string">"PDT"</span>);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">static string[] <a name="getInstalledTZNames"></a><u>getInstalledTZNames</u>(string <i>subName</i> = "", string <i>tzDatabaseDir</i> = defaultTZDatabaseDir);
</div></dt>
<dd>Returns a list of the names of the time zones installed on the system.
<p></p>
You can provide a sub-name to narrow down the list of time zones (which
        will likely be in the thousands if you get them all). For example,
        if you pass in "America" as the sub-name, then only the time zones which
        begin with "America" will be returned.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>string <i>subName</i></td>
<td valign=top>The first part of the time zones that you want.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">FileException</span> if it fails to read from disk.<p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">string <a name="tzDatabaseNameToWindowsTZName"></a><u>tzDatabaseNameToWindowsTZName</u>(string <i>tzName</i>);
</div></dt>
<dd>Converts the given TZ Database name to the corresponding Windows time zone
    name.
<p></p>
Note that in a few cases, a TZ Dabatase name corresponds to two different
    Windows time zone names. So, while in most cases converting from one to the
    other and back again will result in the same time zone name that you started
    with, in a few cases, you will get a different name.
<p></p>


    Also, there are far more TZ Database names than Windows time zones, so some
    of the more exotic TZ Database names don't have corresponding Windows time
    zone names.

<p></p>
<b>See Also:</b><br><a href="http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/zone_tzid.html">              Windows &lt;-&gt; TZ Database Name Conversion Table</a>

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>string <i>tzName</i></td>
<td valign=top>The TZ Database name to convert.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given <span class="d_param"><i>tzName</i></span> cannot be
        converted.<p></p>

</dd>
<dt><div class="d_decl">string <a name="windowsTZNameToTZDatabaseName"></a><u>windowsTZNameToTZDatabaseName</u>(string <i>tzName</i>);
</div></dt>
<dd>Converts the given Windows time zone name to a corresponding TZ Database
    name.
<p></p>
<b>See Also:</b><br><a href="http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/zone_tzid.html">              Windows &lt;-&gt; TZ Database Name Conversion Table</a>

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>string <i>tzName</i></td>
<td valign=top>The TZ Database name to convert.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given <span class="d_param"><i>tzName</i></span> cannot be
        converted.<p></p>

</dd>
<dt><div class="d_decl">struct <a name="StopWatch"></a><u>StopWatch</u>;
</div></dt>
<dd><span class="d_inlinecode"><a name="StopWatch"></a><u>StopWatch</u></span> measures time as precisely as possible.
<p></p>
This class uses a high-performance counter. On Windows systems, it uses
   <span class="d_inlinecode">QueryPerformanceCounter</span>, and on Posix systems, it uses
   <span class="d_inlinecode">clock_gettime</span> if available, and <span class="d_inlinecode">gettimeofday</span> otherwise.
<p></p>


   But the precision of <span class="d_inlinecode"><a name="StopWatch"></a><u>StopWatch</u></span> differs from system to system. It is
   impossible to for it to be the same from system to system since the precision
   of the system clock varies from system to system, and other system-dependent
   and situation-dependent stuff (such as the overhead of a context switch
   between threads) can also affect <span class="d_inlinecode"><a name="StopWatch"></a><u>StopWatch</u></span>'s accuracy.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">void</span> foo()
{
    <span class="d_psymbol">StopWatch</span> sw;
    <span class="d_keyword">enum</span> n = 100;
    TickDuration[n] times;
    TickDuration last = TickDuration.from!<span class="d_string">"seconds"</span>(0);
    <span class="d_keyword">foreach</span>(i; 0..n)
    {
       sw.start(); <span class="d_comment">//start/resume mesuring.
</span>       <span class="d_keyword">foreach</span>(unused; 0..1_000_000)
           bar();
       sw.stop();  <span class="d_comment">//stop/pause measuring.
</span>       <span class="d_comment">//Return value of peek() after having stopped are the always same.
</span>       writeln((i + 1) * 1_000_000, <span class="d_string">" times done, lap time: "</span>,
               sw.peek().msecs, <span class="d_string">"[ms]"</span>);
       times[i] = sw.peek() - last;
       last = sw.peek();
    }
    <span class="d_keyword">real</span> sum = 0;
    <span class="d_comment">// When you want to know the number of seconds,
</span>    <span class="d_comment">// you can use properties of TickDuration.
</span>    <span class="d_comment">// (seconds, mseconds, useconds, hnsecs)
</span>    <span class="d_keyword">foreach</span>(t; times)
       sum += t.hnsecs;
    writeln(<span class="d_string">"Average time: "</span>, sum/n, <span class="d_string">" hnsecs"</span>);
}
</pre>
<p></p>

<dl><dt><div class="d_decl">@safe  this(AutoStart <i>autostart</i>);
</div></dt>
<dd>Auto start with constructor.<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @safe bool <a name="opEquals"></a><u>opEquals</u>(ref const StopWatch <i>rhs</i>);
</div></dt>
<dd><p></p>

</dd>
<dt><div class="d_decl">@safe void <a name="reset"></a><u>reset</u>();
</div></dt>
<dd>Resets the stop watch.<p></p>

</dd>
<dt><div class="d_decl">@safe void <a name="start"></a><u>start</u>();
</div></dt>
<dd>Starts the stop watch.<p></p>

</dd>
<dt><div class="d_decl">@safe void <a name="stop"></a><u>stop</u>();
</div></dt>
<dd>Stops the <a name="stop"></a><u>stop</u> watch.<p></p>

</dd>
<dt><div class="d_decl">const @safe TickDuration <a name="peek"></a><u>peek</u>();
</div></dt>
<dd>Peek at the amount of time which has passed since the stop watch was
       started.<p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">TickDuration[lengthof!(fun)()] <a name="benchmark"></a><u>benchmark</u>(fun...)(uint <i>n</i>);
<br>TickDuration[lengthof!(fun)()] <a name="benchmark"></a><u>benchmark</u>(fun...)(uint <i>times</i>);
</div></dt>
<dd>Benchmarks code for speed assessment and comparison.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>fun</td>
<td valign=top>aliases of callable objects (e.g. function names). Each should
              take no arguments.</td></tr>
<tr><td valign=top>n</td>
<td valign=top>The number of times each function is to be executed.</td></tr>
</table><p></p>
<b>Returns:</b><br>The amount of time (as a ) that it took to
        call each function <span class="d_inlinecode">n</span> times. The first value is the length of time
        that it took to call <span class="d_inlinecode">fun[0]</span> <span class="d_inlinecode">n</span> times. The second value is the
        length of time it took to call <span class="d_inlinecode">fun[1]</span> <span class="d_inlinecode">n</span> times. Etc.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">int</span> a;
<span class="d_keyword">void</span> f0() {}
<span class="d_keyword">void</span> f1() {<span class="d_keyword">auto</span> b = a;}
<span class="d_keyword">void</span> f2() {<span class="d_keyword">auto</span> b = to!(string)(a);}
<span class="d_keyword">auto</span> r = <span class="d_psymbol">benchmark</span>!(f0, f1, f2)(10_000_000);
writefln(<span class="d_string">"Milliseconds to call fun[0] n times: %s"</span>, r[0].to!(<span class="d_string">"msecs"</span>, <span class="d_keyword">int</span>));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">struct <a name="ComparingBenchmarkResult"></a><u>ComparingBenchmarkResult</u>;
</div></dt>
<dd>Return value of benchmark with two functions comparing.<p></p>

<dl><dt><div class="d_decl">const pure nothrow @property @safe real <a name="point"></a><u>point</u>();
</div></dt>
<dd>Evaluation value
<p></p>
This returns the evaluation value of performance as the ratio of
       baseFunc's time over targetFunc's time. If performance is high, this
       returns a high value.<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property @safe TickDuration <a name="baseTime"></a><u>baseTime</u>();
</div></dt>
<dd>The time required of the base function<p></p>

</dd>
<dt><div class="d_decl">const pure nothrow @property @safe TickDuration <a name="targetTime"></a><u>targetTime</u>();
</div></dt>
<dd>The time required of the target function<p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">ComparingBenchmarkResult <a name="comparingBenchmark"></a><u>comparingBenchmark</u>(alias baseFunc, alias targetFunc, int times = 4095)();
<br>ComparingBenchmarkResult <a name="comparingBenchmark"></a><u>comparingBenchmark</u>(alias baseFunc, alias targetFunc, int times = 4095)();
</div></dt>
<dd>Benchmark with two functions comparing.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>baseFunc</td>
<td valign=top>The function to become the base of the speed.</td></tr>
<tr><td valign=top>targetFunc</td>
<td valign=top>The function that wants to measure speed.</td></tr>
<tr><td valign=top>times</td>
<td valign=top>The number of times each function is to be executed.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">void</span> f1() {
   <span class="d_comment">// ...
</span>}
<span class="d_keyword">void</span> f2() {
   <span class="d_comment">// ...
</span>}

<span class="d_keyword">void</span> main() {
   <span class="d_keyword">auto</span> b = <span class="d_psymbol">comparingBenchmark</span>!(f1, f2, 0x80);
   writeln(b.point);
}
</pre>
<p></p>

</dd>
<dt><div class="d_decl">long <a name="sysTimeToDTime"></a><u>sysTimeToDTime</u>(in SysTime <i>sysTime</i>);
</div></dt>
<dd><span style="color:red">Scheduled for deprecation in August 2011. This is only here to help
          transition code which uses std.date to using std.datetime.</span>
<p></p>
Returns a <span class="d_inlinecode">d_time</span> for the given <span class="d_inlinecode">SysTime</span>.<p></p>

</dd>
<dt><div class="d_decl">SysTime <a name="dTimeToSysTime"></a><u>dTimeToSysTime</u>(long <i>dTime</i>, immutable TimeZone <i>tz</i> = null);
</div></dt>
<dd><span style="color:red">Scheduled for deprecation in August 2011. This is only here to help
          transition code which uses std.date to using std.datetime.</span>
<p></p>
Returns a <span class="d_inlinecode">SysTime</span> for the given <span class="d_inlinecode">d_time</span>.<p></p>

</dd>
<dt><div class="d_decl">D <a name="abs"></a><u>abs</u>(D)(D <i>duration</i>);
</div></dt>
<dd>Returns the absolute value of a duration.<p></p>

</dd>
<dt><div class="d_decl">template <a name="isTimePoint"></a><u>isTimePoint</u>(T)</div></dt>
<dd>Whether the given type defines all of the necessary functions for it to
    function as a time point.<p></p>

</dd>
<dt><div class="d_decl">static pure nothrow bool <a name="yearIsLeapYear"></a><u>yearIsLeapYear</u>(int <i>year</i>);
</div></dt>
<dd>Whether the given Gregorian Year is a leap <i>year</i>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>int <i>year</i></td>
<td valign=top>The <i>year</i> to to be tested.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">pure nothrow long <a name="unixTimeToStdTime"></a><u>unixTimeToStdTime</u>(time_t <i>unixTime</i>);
</div></dt>
<dd>Converts a <span class="d_inlinecode">time_t</span> (which uses midnight, January 1st, 1970 UTC as its
    epoch and seconds as its units) to std time (which uses midnight,
    January 1st, 1 A.D. UTC and hnsecs as its units).
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>time_t <i>unixTime</i></td>
<td valign=top>The <span class="d_inlinecode">time_t</span> to convert.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">pure nothrow time_t <a name="stdTimeToUnixTime"></a><u>stdTimeToUnixTime</u>(long <i>stdTime</i>);
</div></dt>
<dd>Converts std time (which uses midnight, January 1st, 1 A.D. UTC as its epoch
    and hnsecs as its units) to <span class="d_inlinecode">time_t</span> (which uses midnight, January 1st,
    1970 UTC as its epoch and seconds as its units). If <span class="d_inlinecode">time_t</span> is 32 bits,
    rather than 64, and the result can't fit in a 32-bit value, then the closest
    value that can be held in 32 bits will be used (so <span class="d_inlinecode">time_t.max</span> if it
    goes over and <span class="d_inlinecode">time_t.min</span> if it goes under).
<p></p>
<b>Note:</b><br>
While Windows systems require that <span class="d_inlinecode">time_t</span> be non-negative (in spite
        of <span class="d_inlinecode">time_t</span> being signed), this function still returns negative
        numbers on Windows, since it's more flexible to allow negative time_t
        for those who need it. So, if you're on Windows and are using the
        standard C functions or Win32 API functions which take a <span class="d_inlinecode">time_t</span>,
        you may want to check whether the return value of
        <span class="d_inlinecode"><a name="stdTimeToUnixTime"></a><u>stdTimeToUnixTime</u></span> is non-negative.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>long <i>stdTime</i></td>
<td valign=top>The std time to convert.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">typedef <a name="DosFileTime"></a><u>DosFileTime</u>;
</div></dt>
<dd>Type representing the DOS file date/time format.<p></p>

</dd>
<dt><div class="d_decl">SysTime <a name="DosFileTimeToSysTime"></a><u>DosFileTimeToSysTime</u>(DosFileTime <i>dft</i>, immutable TimeZone <i>tz</i> = LocalTime());
</div></dt>
<dd>Converts from DOS file date/time to <span class="d_inlinecode">SysTime</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>DosFileTime <i>dft</i></td>
<td valign=top>The DOS file time to convert.</td></tr>
<tr><td valign=top>TimeZone <i>tz</i></td>
<td valign=top>The time zone which the DOS file time is assumed to be in.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the <span class="d_inlinecode">DosFileTime</span> is invalid.<p></p>

</dd>
<dt><div class="d_decl">DosFileTime <a name="SysTimeToDosFileTime"></a><u>SysTimeToDosFileTime</u>(SysTime <i>sysTime</i>);
</div></dt>
<dd>Converts from <span class="d_inlinecode">SysTime</span> to DOS file date/time.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>SysTime <i>sysTime</i></td>
<td valign=top>The <span class="d_inlinecode">SysTime</span> to convert.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if the given <span class="d_inlinecode">SysTime</span> cannot be converted to
        a <span class="d_inlinecode">DosFileTime</span>.<p></p>

</dd>
<dt><div class="d_decl">bool <a name="validTimeUnits"></a><u>validTimeUnits</u>(string[] <i>units</i>...);
</div></dt>
<dd>Whether all of the given strings are valid <i>units</i> of time.
<p></p>
<span class="d_inlinecode">"nsecs"</span> is not considered a valid unit of time. Nothing in std.datetime
    can handle precision greater than hnsecs, and the few functions in core.time
    which deal with "nsecs" deal with it explicitly.<p></p>

</dd>
<dt><div class="d_decl">int <a name="cmpTimeUnits"></a><u>cmpTimeUnits</u>(string <i>lhs</i>, string <i>rhs</i>);
</div></dt>
<dd>Compares two time unit strings. <span class="d_inlinecode">"years"</span> are the largest units and
    <span class="d_inlinecode">"hnsecs"</span> are the smallest.
<p></p>
<b>Returns:</b><br><table cellspacing=0 cellpadding=5><caption>       <tr><td valign=top>this &lt; <i>rhs</i></td> <td valign=top>&lt; 0</td></tr>
        <tr><td valign=top>this == <i>rhs</i></td> <td valign=top>0</td></tr>
        <tr><td valign=top>this &gt; <i>rhs</i></td> <td valign=top>&gt; 0</td></tr>
        </caption>       <tr><td valign=top>this &lt; <i>rhs</i></td> <td valign=top>&lt; 0</td></tr>
        <tr><td valign=top>this == <i>rhs</i></td> <td valign=top>0</td></tr>
        <tr><td valign=top>this &gt; <i>rhs</i></td> <td valign=top>&gt; 0</td></tr>
        </table>

<p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if either of the given strings is not a valid
        time unit string.<p></p>

</dd>
<dt><div class="d_decl">template <a name="CmpTimeUnits"></a><u>CmpTimeUnits</u>(string lhs,string rhs) if (validTimeUnits(lhs,rhs))</div></dt>
<dd>Compares two time unit strings at compile time. <span class="d_inlinecode">"years"</span> are the largest
    units and <span class="d_inlinecode">"hnsecs"</span> are the smallest.
<p></p>
This template is used instead of <span class="d_inlinecode">cmpTimeUnits</span> because exceptions
    can't be thrown at compile time and <span class="d_inlinecode">cmpTimeUnits</span> must enforce that
    the strings it's given are valid time unit strings. This template uses a
    template constraint instead.

<p></p>
<b>Returns:</b><br><table cellspacing=0 cellpadding=5><caption>       <tr><td valign=top>this &lt; rhs</td> <td valign=top>&lt; 0</td></tr>
        <tr><td valign=top>this == rhs</td> <td valign=top>0</td></tr>
        <tr><td valign=top>this &gt; rhs</td> <td valign=top>&gt; 0</td></tr>
        </caption>       <tr><td valign=top>this &lt; rhs</td> <td valign=top>&lt; 0</td></tr>
        <tr><td valign=top>this == rhs</td> <td valign=top>0</td></tr>
        <tr><td valign=top>this &gt; rhs</td> <td valign=top>&gt; 0</td></tr>
        </table><p></p>

</dd>
<dt><div class="d_decl">pure nothrow bool <a name="valid"></a><u>valid</u>(string units)(int <i>value</i>);
</div></dt>
<dd>Returns whether the given value is <a name="valid"></a><u>valid</u> for the given unit type when in a
    time point. Naturally, a duration is not held to a particular range, but
    the values in a time point are (e.g. a month must be in the range of
    1 - 12 inclusive).
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>units</td>
<td valign=top>The units of time to validate.</td></tr>
<tr><td valign=top>value</td>
<td valign=top>The number to validate.</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(<span class="d_psymbol">valid</span>!<span class="d_string">"hours"</span>(12));
<span class="d_keyword">assert</span>(!<span class="d_psymbol">valid</span>!<span class="d_string">"hours"</span>(32));
<span class="d_keyword">assert</span>(<span class="d_psymbol">valid</span>!<span class="d_string">"months"</span>(12));
<span class="d_keyword">assert</span>(!<span class="d_psymbol">valid</span>!<span class="d_string">"months"</span>(13));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">pure nothrow bool <a name="valid"></a><u>valid</u>(string units)(int <i>year</i>, int <i>month</i>, int <i>day</i>);
</div></dt>
<dd>Returns whether the given day is <a name="valid"></a><u>valid</u> for the given year and month.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>units</td>
<td valign=top>The units of time to validate.</td></tr>
<tr><td valign=top>year</td>
<td valign=top>The year of the day to validate.</td></tr>
<tr><td valign=top>month</td>
<td valign=top>The month of the day to validate.</td></tr>
<tr><td valign=top>day</td>
<td valign=top>The day to validate.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">pure void <a name="enforceValid"></a><u>enforceValid</u>(string units)(int <i>value</i>, string <i>file</i> = __FILE__, size_t <i>line</i> = __LINE__);
</div></dt>
<dd><b>Parameters:</b><table class=parms><tr><td valign=top>units</td>
<td valign=top>The units of time to validate.</td></tr>
<tr><td valign=top>value</td>
<td valign=top>The number to validate.</td></tr>
<tr><td valign=top>file</td>
<td valign=top>The file that the <span class="d_inlinecode">DateTimeException</span> will list if thrown.</td></tr>
<tr><td valign=top>line</td>
<td valign=top>The line number that the <span class="d_inlinecode">DateTimeException</span> will list if
                thrown.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if <span class="d_inlinecode">valid!units(value)</span> is <b>false</b>.<p></p>

</dd>
<dt><div class="d_decl">pure void <a name="enforceValid"></a><u>enforceValid</u>(string units)(int <i>year</i>, Month <i>month</i>, int <i>day</i>, string <i>file</i> = __FILE__, size_t <i>line</i> = __LINE__);
</div></dt>
<dd><b>Parameters:</b><table class=parms><tr><td valign=top>units</td>
<td valign=top>The units of time to validate.</td></tr>
<tr><td valign=top>year</td>
<td valign=top>The year of the day to validate.</td></tr>
<tr><td valign=top>month</td>
<td valign=top>The month of the day to validate.</td></tr>
<tr><td valign=top>day</td>
<td valign=top>The day to validate.</td></tr>
<tr><td valign=top>file</td>
<td valign=top>The file that the <span class="d_inlinecode">DateTimeException</span> will list if thrown.</td></tr>
<tr><td valign=top>line</td>
<td valign=top>The line number that the <span class="d_inlinecode">DateTimeException</span> will list if
                thrown.</td></tr>
</table><p></p>
<b>Throws:</b><br><span class="d_inlinecode">DateTimeException</span> if <span class="d_inlinecode">valid!"days"(year, month, day)</span> is <b>false</b>.<p></p>

</dd>
<dt><div class="d_decl">static pure int <a name="monthsToMonth"></a><u>monthsToMonth</u>(int <i>currMonth</i>, int <i>month</i>);
</div></dt>
<dd>Returns the number of months from the current months of the year to the
    given <i>month</i> of the year. If they are the same, then the result is 0.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>int <i>currMonth</i></td>
<td valign=top>The current <i>month</i> of the year.</td></tr>
<tr><td valign=top>int <i>month</i></td>
<td valign=top>The <i>month</i> of the year to get the number of months to.</td></tr>
</table><p></p>

</dd>
<dt><div class="d_decl">static pure nothrow int <a name="daysToDayOfWeek"></a><u>daysToDayOfWeek</u>(DayOfWeek <i>currDoW</i>, DayOfWeek <i>dow</i>);
</div></dt>
<dd>Returns the number of days from the current day of the week to the given
    day of the week. If they are the same, then the result is 0.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>DayOfWeek <i>currDoW</i></td>
<td valign=top>The current day of the week.</td></tr>
<tr><td valign=top>DayOfWeek <i>dow</i></td>
<td valign=top>The day of the week to get the number of days to.</td></tr>
</table><p></p>

</dd>
</dl>

    
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="6203743411";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
 
</div>


<div id="copyright">
Copyright 2010 - 2011
 |
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

