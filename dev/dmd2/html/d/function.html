
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en-US">

<!--
	Copyright (c) 1999-2011 by Digital Mars
	All Rights Reserved Written by Walter Bright
	http://www.digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="keywords" content="D programming language" />
<meta name="description" content="D Programming Language" />
<title>Functions - D Programming Language 2.0 - Digital Mars</title>
<link rel="stylesheet" type="text/css" href="style.css" />
<link rel="stylesheet" type="text/css" href="print.css" media="print" />
<link rel="shortcut icon" href="favicon.ico" />

<!-- enable this for automated hyphenation, see http://code.google.com/p/hyphenator/ -->
<!--
<script src="http://erdani.com/js/Hyphenator.js" type="text/javascript"></script>
<script type="text/javascript">Hyphenator.run();</script>
-->

</head>

<body class="hyphenate">
<div id="heading">
	<a href="http://www.digitalmars.com/"><img src="dmlogo.gif" width="270" height="53" style="border-style:none" alt="www.digitalmars.com" align="left"></a>
	<p align="right">D Programming Language 2.0</p>
	<br>

	<div id="headingNav">
	<ul>	<li><a href="http://www.digitalmars.com/NewsGroup.html" title="User Forums"><img src="http://www.digitalmars.com/news.png" border=0 alt="User Forums"> Forum</a></li>
	<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/Function" title="Read/write comments and feedback"><img src="wiki.png" border=0 alt="D Wiki"> Wiki</a></li>
	<li><a href="index.html" title="D Programming Language" class="dlink">&nbsp;<img src="d.png" border=0 alt="D Programming Language">&nbsp;</a></li>
	<li><a href="http://www.digitalmars.com/advancedsearch.html" title="Search Digital Mars web site"><img src="search.png" border=0 alt="Search">Search</a></li>
	<li><a href="http://www.digitalmars.com/d/download.html" title="download D"><img src="download.png" border=0 alt="Download">Downloads</a></li>
	<li><a href="http://www.digitalmars.com/" title="www.digitalmars.com"><img src="home.png" border=0 alt="digitalmars.com">Home</a></li>
	</ul>
	</div>

	<div id="lastupdate">Last update Fri Jul  8 22:24:13 2011
</div>
</div>
<!-- Generated by Ddoc from function.dd -->



<div id="navigation">
  
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input id="q" name="q" size="10" value="Search" onFocus='if(this.value == "Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/d/2.0">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="index.html" title="D Programming Language">D 2.0 Home</a></li>
	<li><a href="spec.html" title="D Language Specification">Language Reference</a></li>
	<li><a href="phobos/phobos.html" title="D Runtime Library">Library Reference</a></li>
	<li><a href="comparison.html" title="Language Comparisons">Comparisons</a></li>
	<li><a href="http://www.digitalmars.com/d/1.0/index.html" title="D Programming Language 1.0">D 1.0 Home</a></li>
    </ul>
</div>
</div>

  
    <div class="navblock">
    <ul>	<li><a href="spec.html">Specification</a></li>
	<li><a href="intro.html">Introduction</a></li>
	<li><a href="lex.html">Lexical</a></li>
	<li><a href="module.html">Modules</a></li>
	<li><a href="declaration.html">Declarations</a></li>
	<li><a href="type.html">Types</a></li>
	<li><a href="property.html">Properties</a></li>
	<li><a href="attribute.html">Attributes</a></li>
	<li><a href="pragma.html">Pragmas</a></li>
	<li><a href="expression.html">Expressions</a></li>
	<li><a href="statement.html">Statements</a></li>
	<li><a href="arrays.html">Arrays</a></li>
	<li><a href="hash-map.html">Associative Arrays</a></li>
	<li><a href="struct.html">Structs &amp; Unions</a></li>
	<li><a href="class.html">Classes</a></li>
	<li><a href="interface.html">Interfaces</a></li>
	<li><a href="enum.html">Enums</a></li>
	<li><a href="const3.html">Const and Immutable</a></li>
	<li><a href="function.html">Functions</a></li>
	<li><a href="operatoroverloading.html">Operator Overloading</a></li>
	<li><a href="template.html">Templates</a></li>
	<li><a href="template-mixin.html">Template Mixins</a></li>
	<li><a href="dbc.html">Contracts</a></li>
	<li><a href="version.html">Conditional Compilation</a></li>
	<li><a href="traits.html">Traits</a></li>
	<li><a href="errors.html">Handling errors</a></li>
	<li><a href="unittest.html">Unit Tests</a></li>
	<li><a href="garbage.html">Garbage Collection</a></li>
	<li><a href="float.html">Floating Point</a></li>
	<li><a href="iasm.html">Inline Assembler</a></li>
	<li><a href="ddoc.html">Documentation Comments</a></li>
	<li><a href="interfaceToC.html">Interfacing To C</a></li>
	<li><a href="cpp_interface.html">Interfacing To C++</a></li>
	<li><a href="portability.html">Portability Guide</a></li>
	<li><a href="html.html">Embedding D in HTML</a></li>
	<li><a href="entity.html">Named Character Entities</a></li>
	<li><a href="memory-safe-d.html">Memory Safe D Spec</a></li>
	<li><a href="abi.html">Application Binary Interface</a></li>
    </ul>
    </div>
    
    <div class="navblock">
	<h2>Books</h2>
	<ul>		<li><a href="http://www.amazon.com/exec/obidos/ASIN/0321635361/classicempire">D Programming Language</a>
</li>
		<li><a href="http://www.amazon.com/exec/obidos/ASIN/1590599608/classicempire">Learn to Tango with D</a>
</li>
		<li><a href="http://www.amazon.com/exec/obidos/ASIN/0596520123/classicempire">Version Control with Git</a>
</li>
	</ul>
    </div>


    
<script src="http://www.gmodules.com/ig/ifr?url=http://www.google.com/ig/modules/translatemypage.xml&up_source_language=en&w=160&h=60&title=&border=&output=js"></script>
    



</div>
<div id="content">
  <h1>Functions</h1>
  <pre class="bnf"><span class="notranslate"><a name="FunctionBody"><i>FunctionBody</i></a>:
    <a href="statement.html#BlockStatement"><i>BlockStatement</i></a>
    <a href="#BodyStatement"><i>BodyStatement</i></a>
    <a href="#InStatement"><i>InStatement</i></a> <a href="#BodyStatement"><i>BodyStatement</i></a>
    <a href="#OutStatement"><i>OutStatement</i></a> <a href="#BodyStatement"><i>BodyStatement</i></a>
    <a href="#InStatement"><i>InStatement</i></a> <a href="#OutStatement"><i>OutStatement</i></a> <a href="#BodyStatement"><i>BodyStatement</i></a>
    <a href="#OutStatement"><i>OutStatement</i></a> <a href="#InStatement"><i>InStatement</i></a> <a href="#BodyStatement"><i>BodyStatement</i></a>

<a name="InStatement"><i>InStatement</i></a>:
    <b>in</b> <a href="statement.html#BlockStatement"><i>BlockStatement</i></a>

<a name="OutStatement"><i>OutStatement</i></a>:
    <b>out</b> <a href="statement.html#BlockStatement"><i>BlockStatement</i></a>
    <b>out</b> <b>(</b> <i>Identifier</i> <b>)</b> <a href="statement.html#BlockStatement"><i>BlockStatement</i></a>

<a name="BodyStatement"><i>BodyStatement</i></a>:
    <b>body</b> <a href="statement.html#BlockStatement"><i>BlockStatement</i></a>
</span></pre>


<h3>Function Return Values</h3>

        <p>Function return values are considered to be rvalues.
        This means they cannot be passed by reference to other functions.
        </p>

<h3><a name="pure-functions">Pure Functions</a></h3>

        <p>Pure functions are functions that produce the same
        result for the same arguments.
        To that end, a pure function:
        </p>

        <ul>       <li>does not read or write any global mutable state</li>
        <li>cannot call functions that are not pure</li>
        <li>can override an impure function, but an impure function
        cannot override a pure one</li>
        <li>is covariant with an impure function</li>
        <li>cannot perform I/O</li>
        </ul>

        <p>As a concession to practicality, a pure function can:</p>

        <ul>       <li>allocate memory via a <a href="expression.html#NewExpression"><i>NewExpression</i></a></li>
        <li>terminate the program</li>
        <li>read and write the floating point exception flags</li>
        <li>read and write the floating point mode flags, as long as those flags
        are restored to their initial state upon function entry</li>
        <li>perform impure operations in statements that are in a
        <a href="version.html#ConditionalStatement"><i>ConditionalStatement</i></a>
        controlled by a <a href="version.html#debug"><i>DebugCondition</i></a>.</li>
        </ul>

        <p>A pure function can throw exceptions.</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">int</span> x;
<span class="d_keyword">immutable</span> <span class="d_keyword">int</span> y;
<span class="d_keyword">const</span> <span class="d_keyword">int</span>* pz;

<span class="d_keyword">pure</span> <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> i,
             <span class="d_keyword">char</span>* p,
             <span class="d_keyword">const</span> <span class="d_keyword">char</span>* q,
             <span class="d_keyword">immutable</span> <span class="d_keyword">int</span>* s)
{
  <span class="d_keyword">debug</span> writeln(<span class="d_string">"in foo()"</span>); <span class="d_comment">// ok, impure code allowed in debug statement
</span>  x = i;   <span class="d_comment">// error, modifying global state
</span>  i = x;   <span class="d_comment">// error, reading mutable global state
</span>  i = y;   <span class="d_comment">// ok, reading immutable global state
</span>  i = *pz; <span class="d_comment">// error, reading const global state
</span>  <span class="d_keyword">return</span> i;
}
</span></pre>


<h3><a name="nothrow-functions">Nothrow Functions</a></h3>

        <p>Nothrow functions do not throw any exceptions derived
        from class <i>Exception</i>.
        </p>

        <p>Nothrow functions are covariant with throwing ones.</p>

<h3><a name="ref-functions">Ref Functions</a></h3>

        <p>Ref functions allow functions to return by reference.
        This is analogous to ref function parameters.
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">ref</span> <span class="d_keyword">int</span> foo() {
  <span class="d_keyword">auto</span> p = <span class="d_keyword">new</span> <span class="d_keyword">int</span>;
  <span class="d_keyword">return</span> *p;
}
...
foo() = 3;  <span class="d_comment">// reference returns can be lvalues
</span></span></pre>

<h3><a name="auto-functions">Auto Functions</a></h3>

        <p>Auto functions have their return type inferred from any
        <a href="statement.html#ReturnStatement"><i>ReturnStatement</i></a>s
        in the function body.
        </p>

        <p>An auto function is declared without a return type.
        If it does not already have a storage class, use the
        <span class="d_keyword">auto</span> storage class.
        </p>

        <p>If there are multiple <i>ReturnStatement</i>s, the types
        of them must match exactly. If there are no <i>ReturnStatement</i>s,
        the return type is inferred to be <span class="d_keyword">void</span>.
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">auto</span> foo(<span class="d_keyword">int</span> i) {
  <span class="d_keyword">return</span> i + 3;  <span class="d_comment">// return type is inferred to be int
</span>}
</span></pre>

<h3><a name="auto-ref-functions">Auto Ref Functions</a></h3>

        <p>Auto ref functions infer their return type just as
        <a href="#auto-functions">auto functions</a> do.
        In addition, they become <a href="#ref-functions">ref functions</a>
        if the return expression is an lvalue,
        and it would not be a reference to a local or a parameter.
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">auto</span> <span class="d_keyword">ref</span> foo(<span class="d_keyword">int</span> x)     { <span class="d_keyword">return</span> x; }  <span class="d_comment">// value return
</span><span class="d_keyword">auto</span> <span class="d_keyword">ref</span> foo()          { <span class="d_keyword">return</span> 3; }  <span class="d_comment">// value return
</span><span class="d_keyword">auto</span> <span class="d_keyword">ref</span> foo(<span class="d_keyword">ref</span> <span class="d_keyword">int</span> x) { <span class="d_keyword">return</span> x; }  <span class="d_comment">// ref return
</span><span class="d_keyword">auto</span> <span class="d_keyword">ref</span> foo(<span class="d_keyword">out</span> <span class="d_keyword">int</span> x) { <span class="d_keyword">return</span> x; }  <span class="d_comment">// ref return
</span><span class="d_keyword">auto</span> <span class="d_keyword">ref</span> foo() { <span class="d_keyword">static</span> <span class="d_keyword">int</span> x; <span class="d_keyword">return</span> x; }  <span class="d_comment">// ref return
</span></span></pre>

        <p>The lexically first <a href="statement.html#ReturnStatement"><i>ReturnStatement</i></a>
        determines the ref-ness of a function:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">auto</span> <span class="d_keyword">ref</span> foo(<span class="d_keyword">ref</span> <span class="d_keyword">int</span> x) { <span class="d_keyword">return</span> 3; <span class="d_keyword">return</span> x; }  <span class="d_comment">// ok, value return
</span><span class="d_keyword">auto</span> <span class="d_keyword">ref</span> foo(<span class="d_keyword">ref</span> <span class="d_keyword">int</span> x) { <span class="d_keyword">return</span> x; <span class="d_keyword">return</span> 3; }  <span class="d_comment">// error, ref return, 3 is not an lvalue
</span></span></pre>


<h3><a name="inout-functions">Inout Functions</a></h3>

        <p>Functions that deal with mutable, const, or immutable types with
        equanimity often need to transmit their type to the return value:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span>[] foo(<span class="d_keyword">int</span>[] a, <span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y) { <span class="d_keyword">return</span> a[x .. y]; }

<span class="d_keyword">const</span>(<span class="d_keyword">int</span>)[] foo(<span class="d_keyword">const</span>(<span class="d_keyword">int</span>)[] a, <span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y) { <span class="d_keyword">return</span> a[x .. y]; }

<span class="d_keyword">immutable</span>(<span class="d_keyword">int</span>)[] foo(<span class="d_keyword">immutable</span>(<span class="d_keyword">int</span>)[] a, <span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y) { <span class="d_keyword">return</span> a[x .. y]; }
</span></pre>

        <p>The code generated by these three functions is identical.
        To indicate that these can be one function, the <span class="d_keyword">inout</span>
        type constructor is employed:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">inout</span>(<span class="d_keyword">int</span>)[] foo(<span class="d_keyword">inout</span>(<span class="d_keyword">int</span>)[] a, <span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y) { <span class="d_keyword">return</span> a[x .. y]; }
</span></pre>

        <p>The <span class="d_keyword">inout</span> forms a wildcard that stands in for
        any of mutable, const or immutable. When the function is called,
        the inout of the return type is changed to whatever the mutable,
        const, or immutable status of the argument type to the parameter
        inout was.
        </p>

        <p>Inout types can be implicitly converted to const, but to nothing
        else. Other types cannot be implicitly converted to inout.
        Casting to or from inout is not allowed in @safe functions.
        </p>

        <p>If an inout appears in a function parameter list, it must also appear
        in the return type.
        </p>

        <p>A set of arguments to a function with inout parameters is considered
        a match if any inout argument types match exactly, or:</p>

<ol>       <li>No argument types are composed of inout types.</li>
        <li>A mutable, const or immutable argument type can be matched against each
        corresponding parameter inout type.</li>
</ol>

        <p>If such a match occurs, if every match is mutable, then the inout is
        considered matched with mutable. If every match is immutable, then the
        inout is considered matched with immutable. Otherwise, the inout is
        considered matched with const. The inout in the return type is then rewritten
        to be the inout matched attribute.
        </p>

        <p>Global and static variable types cannot have any inout components.
        </p>

        <p><b>Note:</b> Shared types are not overlooked. Shared types cannot
        be matched with inout.
        </p>


<h3><a name="property-functions">Property Functions</a></h3>

        <p>Property functions are tagged with the <tt><span class="notranslate">@property</span></tt>
        attribute. They can be called without parentheses (hence
        acting like properties).
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">struct</span> S {
  <span class="d_keyword">int</span> m_x;
  @property {
    <span class="d_keyword">int</span> x() { <span class="d_keyword">return</span> m_x; }
    <span class="d_keyword">int</span> x(<span class="d_keyword">int</span> newx) { <span class="d_keyword">return</span> m_x = newx; }
  }
}

<span class="d_keyword">void</span> foo() {
  S s;
  s.x = 3;   <span class="d_comment">// calls s.x(int)
</span>  bar(s.x);  <span class="d_comment">// calls bar(s.x())
</span>}
</span></pre>


<h3><a name="virtual-functions">Virtual Functions</a></h3>

        <p>Virtual functions are functions that are called indirectly
        through a function
        pointer table, called a vtbl[], rather than directly.
        All non-static non-private non-template member functions are virtual.
        This may sound
        inefficient, but since the D compiler knows all of the class
        hierarchy when generating code, all
        functions that are not overridden can be optimized to be non-virtual.
        In fact, since
        C++ programmers tend to "when in doubt, make it virtual", the D way of
        "make it
        virtual unless we can prove it can be made non-virtual" results, on
        average, in many
        more direct function calls. It also results in fewer bugs caused by
        not declaring
        a function virtual that gets overridden.
        </p>

        <p>Functions with non-D linkage cannot be virtual, and hence cannot be
        overridden.
        </p>

        <p>Member template functions cannot be virtual, and hence cannot be
        overridden.
        </p>

        <p>Functions marked as <tt>final</tt> may not be overridden in a
        derived class, unless they are also <tt>private</tt>.
        For example:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> A {
  <span class="d_keyword">int</span> def() { ... }
  <span class="d_keyword">final</span> <span class="d_keyword">int</span> foo() { ... }
  <span class="d_keyword">final</span> <span class="d_keyword">private</span> <span class="d_keyword">int</span> bar() { ... }
  <span class="d_keyword">private</span> <span class="d_keyword">int</span> abc() { ... }
}

<span class="d_keyword">class</span> B : A {
  <span class="d_keyword">int</span> def() { ... }  <span class="d_comment">// ok, overrides A.def
</span>  <span class="d_keyword">int</span> foo() { ... }  <span class="d_comment">// error, A.foo is final
</span>  <span class="d_keyword">int</span> bar() { ... }  <span class="d_comment">// ok, A.bar is final private, but not virtual
</span>  <span class="d_keyword">int</span> abc() { ... }  <span class="d_comment">// ok, A.abc is not virtual, B.abc is virtual
</span>}

<span class="d_keyword">void</span> test(A a) {
  a.def();    <span class="d_comment">// calls B.def
</span>  a.foo();    <span class="d_comment">// calls A.foo
</span>  a.bar();    <span class="d_comment">// calls A.bar
</span>  a.abc();    <span class="d_comment">// calls A.abc
</span>}

<span class="d_keyword">void</span> func() {
  B b = <span class="d_keyword">new</span> B();
  test(b);
}
</span></pre>

        <p>Covariant return types
        are supported, which means that the
        overriding function in a derived class can return a type
        that is derived from the type returned by the overridden function:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> A { }
<span class="d_keyword">class</span> B : A { }

<span class="d_keyword">class</span> Foo {
  A test() { <span class="d_keyword">return</span> <span class="d_keyword">null</span>; }
}

<span class="d_keyword">class</span> Bar : Foo {
  B test() { <span class="d_keyword">return</span> <span class="d_keyword">null</span>; } <span class="d_comment">// overrides and is covariant with Foo.test()
</span>}
</span></pre>

        <p>Virtual functions all have a hidden parameter called the
        <i>this</i> reference, which refers to the class object for which
        the function is called.
        </p>

<h3><a name="function-inheritance">Function Inheritance and Overriding</a></h3>

        A functions in a derived class with the same name and parameter
        types as a function in a base class overrides that function:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> A {
  <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> x) { ... }
}

<span class="d_keyword">class</span> B : A {
  <span class="d_keyword">override</span> <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> x) { ... }
}

<span class="d_keyword">void</span> test() {
  B b = <span class="d_keyword">new</span> B();
  bar(b);
}

<span class="d_keyword">void</span> bar(A a) {
  a.foo(1);   <span class="d_comment">// calls B.foo(int)
</span>}
</span></pre>

        <p>However, when doing overload resolution, the functions in the base
        class are not considered:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> A {
  <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> x) { ... }
  <span class="d_keyword">int</span> foo(<span class="d_keyword">long</span> y) { ... }
}

<span class="d_keyword">class</span> B : A {
  <span class="d_keyword">override</span> <span class="d_keyword">int</span> foo(<span class="d_keyword">long</span> x) { ... }
}

<span class="d_keyword">void</span> test() {
  B b = <span class="d_keyword">new</span> B();
  b.foo(1);  <span class="d_comment">// calls B.foo(long), since A.foo(int) not considered
</span>  A a = b;
  a.foo(1);    <span class="d_comment">// issues runtime error (instead of calling A.foo(int))</span>
}
</span></pre>

        <p>To consider the base class's functions in the overload resolution
        process, use an <i>AliasDeclaration</i>:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> A {
  <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> x) { ... }
  <span class="d_keyword">int</span> foo(<span class="d_keyword">long</span> y) { ... }
}

<span class="d_keyword">class</span> B : A {
  <b><span class="d_keyword">alias</span> A.foo foo;</b>
  <span class="d_keyword">override</span> <span class="d_keyword">int</span> foo(<span class="d_keyword">long</span> x) { ... }
}

<span class="d_keyword">void</span> test() {
  B b = <span class="d_keyword">new</span> B();
  bar(b);
}

<span class="d_keyword">void</span> bar(A a) {
  a.foo(1);      <span class="d_comment">// calls A.foo(int)
</span>  B b = <span class="d_keyword">new</span> B();
  b.foo(1);      <span class="d_comment">// calls A.foo(int)
</span>}
</span></pre>

       <p>If such an <i>AliasDeclaration</i> is not used, the derived
        class's functions completely override all the functions of the
        same name in the base class, even if the types of the parameters
        in the base class functions are different. If, through
        implicit conversions to the base class, those other functions do
        get called, a <tt><span class="notranslate">core.exception.HiddenFuncError</span></tt> exception is raised:
        </p>
<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> core.exception;

<span class="d_keyword">class</span> A {
   <span class="d_keyword">void</span> set(<span class="d_keyword">long</span> i) { }
   <span class="d_keyword">void</span> <b>set</b>(<span class="d_keyword">int</span> i)  { }
}
<span class="d_keyword">class</span> B : A {
   <span class="d_keyword">void</span> set(<span class="d_keyword">long</span> i) { }
}

<span class="d_keyword">void</span> foo(A a) {
  <span class="d_keyword">int</span> i;
  <span class="d_keyword">try</span> {
    a.<b>set</b>(3);   <span class="d_comment">// error, throws runtime exception since
</span>                <span class="d_comment">// A.set(int) should not be available from B
</span>  }
  <span class="d_keyword">catch</span> (<b>HiddenFuncError</b> o) {
     i = 1;
  }
  <span class="d_keyword">assert</span>(i == 1);
}

<span class="d_keyword">void</span> main() {
  foo(<span class="d_keyword">new</span> B);
}
</span></pre>
        <p>If an <tt><span class="notranslate">HiddenFuncError</span></tt> exception is thrown in your program,
        the use of overloads and overrides needs to be reexamined in the
        relevant classes.</p>

        <p>The <tt><span class="notranslate">HiddenFuncError</span></tt> exception is not thrown if the
        hidden function is disjoint, as far as overloading is concerned,
        from all the other virtual functions is the inheritance hierarchy.</p>


        <p>A function parameter's default value is not inherited:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> A {
  <span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> <b>x = 5</b>) { ... }
}

<span class="d_keyword">class</span> B : A {
  <span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> <b>x = 7</b>) { ... }
}

<span class="d_keyword">class</span> C : B {
  <span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> <b>x</b>) { ... }
}


<span class="d_keyword">void</span> test() {
  A a = <span class="d_keyword">new</span> A();
  a.foo();       <span class="d_comment">// calls A.foo(5)
</span>
  B b = <span class="d_keyword">new</span> B();
  b.foo();       <span class="d_comment">// calls B.foo(7)
</span>
  C c = <span class="d_keyword">new</span> C();
  c.foo();       <span class="d_comment">// error, need an argument for C.foo
</span>}
</span></pre>


<h3>Inline Functions</h3>

        There is no inline keyword. The compiler makes the decision whether to
        inline a function or not, analogously to the register keyword no
        longer being relevant to a
        compiler's decisions on enregistering variables.
        (There is no register keyword either.)


<h2><a name="function-overloading">Function Overloading</a></h2>

        <p>Functions are overloaded based on how well the arguments
        to a function can match up with the parameters.
        The function with the <i>best</i> match is selected.
        The levels of matching are:
        </p>

        <ol>       <li>no match</li>
        <li>match with implicit conversions</li>
        <li>match with conversion to const</li>
        <li>exact match</li>
        </ol>

        <p>Each argument (including any <tt><span class="notranslate">this</span></tt> pointer) is
        compared against the function's corresponding parameter, to
        determine the match level for that argument. The match level
        for a function is the <i>worst</i> match level of each of its
        arguments.</p>

       <p>Literals do not match <tt><span class="notranslate">ref</span></tt> or <tt><span class="notranslate">out</span></tt> parameters.</p>


       <p>If two or more functions have the same match level,
        then <a name="partial-ordering"><i>partial ordering</i></a>
        is used to try to find the best match.
        Partial ordering finds the most specialized function.
        If neither function is more specialized than the other,
        then it is an ambiguity error.
        Partial ordering is determined for functions <tt><span class="notranslate">f()</span></tt>
        and <tt><span class="notranslate">g()</span></tt> by taking the parameter types of <tt><span class="notranslate">f()</span></tt>,
        constructing a list of arguments by taking the default values
        of those types, and attempting to match them against <tt><span class="notranslate">g()</span></tt>.
        If it succeeds, then <tt><span class="notranslate">g()</span></tt> is at least as specialized
        as <tt><span class="notranslate">f()</span></tt>.
        For example:
        </p>
<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> A { }
<span class="d_keyword">class</span> B : A { }
<span class="d_keyword">class</span> C : B { }
<span class="d_keyword">void</span> foo(A);
<span class="d_keyword">void</span> foo(B);

<span class="d_keyword">void</span> test() {
  C c;
  <span class="d_comment">/* Both foo(A) and foo(B) match with implicit conversion rules.
   * Applying partial ordering rules,
   * foo(B) cannot be called with an A, and foo(A) can be called
   * with a B. Therefore, foo(B) is more specialized, and is selected.
   */</span>
  foo(c); <span class="d_comment">// calls foo(B)
</span>}
</span></pre>
        <p>A function with a variadic argument is considered less
        specialized than a function without.
        </p>


        <p>Functions defined with non-D linkage cannot be overloaded.
        because the name mangling does not take the parameter types
        into account.
        </p>

<h2><a name="overload-sets">Overload Sets</a></h2>

        <p>Functions declared at the same scope overload against each
        other, and are called an <i>Overload Set</i>.
        A typical example of an overload set are functions defined
        at module level:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">module</span> A;
<span class="d_keyword">void</span> foo() { }
<span class="d_keyword">void</span> foo(<span class="d_keyword">long</span> i) { }
</span></pre>

        <p><tt><span class="notranslate">A.foo()</span></tt> and <tt><span class="notranslate">A.foo(long)</span></tt> form an overload set.
        A different module can also define functions with the same name:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">module</span> B;
<span class="d_keyword">class</span> C { }
<span class="d_keyword">void</span> foo(C) { }
<span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> i) { }
</span></pre>

        <p>and A and B can be imported by a third module, C.
        Both overload sets, the <tt><span class="notranslate">A.foo</span></tt> overload set and the <tt><span class="notranslate">B.foo</span></tt>
        overload set, are found. An instance of <tt><span class="notranslate">foo</span></tt> is selected
        based on it matching in exactly one overload set:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> A;
<span class="d_keyword">import</span> B;

<span class="d_keyword">void</span> bar(C c) {
  foo();    <span class="d_comment">// calls A.foo()
</span>  foo(1L);  <span class="d_comment">// calls A.foo(long)
</span>  foo(c);   <span class="d_comment">// calls B.foo(C)
</span>  foo(1,2); <span class="d_comment">// error, does not match any foo
</span>  foo(1);   <span class="d_comment">// error, matches A.foo(long) and B.foo(int)
</span>  A.foo(1); <span class="d_comment">// calls A.foo(long)
</span>}
</span></pre>

        <p>Even though <tt><span class="notranslate">B.foo(int)</span></tt> is a better match than <tt><span class="notranslate">       A.foo(long)</span></tt> for <tt><span class="notranslate">foo(1)</span></tt>,
        it is an error because the two matches are in
        different overload sets.
        </p>

        <p>Overload sets can be merged with an alias declaration:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> A;
<span class="d_keyword">import</span> B;

<span class="d_keyword">alias</span> A.foo foo;
<span class="d_keyword">alias</span> B.foo foo;

<span class="d_keyword">void</span> bar(C c) {
  foo();    <span class="d_comment">// calls A.foo()
</span>  foo(1L);  <span class="d_comment">// calls A.foo(long)
</span>  foo(c);   <span class="d_comment">// calls B.foo(C)
</span>  foo(1,2); <span class="d_comment">// error, does not match any foo
</span>  foo(1);   <span class="d_comment">// calls B.foo(int)
</span>  A.foo(1); <span class="d_comment">// calls A.foo(long)
</span>}
</span></pre>




<h3><a name="parameters">Function Parameters</a></h3>


       Parameter storage classes are <b>in</b>, <b>out</b>,
        <b>ref</b>, <b>lazy</b>, <b>final</b>, <b>const</b>, <b>immutable</b>, or
        <b>scope</b>.
         For example:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> foo(<span class="d_keyword">in</span> <span class="d_keyword">int</span> x, <span class="d_keyword">out</span> <span class="d_keyword">int</span> y, <span class="d_keyword">ref</span> <span class="d_keyword">int</span> z, <span class="d_keyword">int</span> q);
</span></pre>

        <p>       x is <b>in</b>, y is <b>out</b>, z is <b>ref</b>, and q is none.
        </p>

        <p>       The <b>in</b> storage class is equivalent to <b>const scope</b>.
        </p>

    <p>   The <b>scope</b> storage class means that references in the parameter
    cannot be escaped (e.g. assigned to a global variable).
    </p>

        <p>       If no storage class is specified, the parameter becomes a mutable
        copy of its argument.
        </p>


        <ul>       <li>The function declaration makes it clear what the inputs and
        outputs to the function are.</li>
        <li>It eliminates the need for IDL as a separate language.</li>
        <li>It provides more information to the compiler, enabling more
        error checking and
        possibly better code generation.</li>
        </ul>

        <p>       <b>out</b> parameters are set to the default initializer for the
        type of it. For example:
        </p>
<pre class="d_code"><span class="notranslate"><span class="d_keyword">void</span> foo(<span class="d_keyword">out</span> <span class="d_keyword">int</span> x) {
  <span class="d_comment">// x is set to 0 at start of foo()
</span>}

<span class="d_keyword">int</span> a = 3;
foo(a);
<span class="d_comment">// a is now 0
</span>

<span class="d_keyword">void</span> abc(<span class="d_keyword">out</span> <span class="d_keyword">int</span> x) {
  x = 2;
}

<span class="d_keyword">int</span> y = 3;
abc(y);
<span class="d_comment">// y is now 2
</span>

<span class="d_keyword">void</span> def(<span class="d_keyword">ref</span> <span class="d_keyword">int</span> x) {
  x += 1;
}

<span class="d_keyword">int</span> z = 3;
def(z);
<span class="d_comment">// z is now 4
</span></span></pre>

        <p>For dynamic array and object parameters, which are passed
        by reference, in/out/ref
        apply only to the reference and not the contents.
        </p>

        <p>Lazy arguments are evaluated not when the function is called,
        but when the parameter is evaluated within the function. Hence,
        a lazy argument can be executed 0 or more times. A lazy parameter
        cannot be an lvalue.</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">void</span> dotimes(<span class="d_keyword">int</span> n, <span class="d_keyword">lazy</span> <span class="d_keyword">void</span> exp) {
  <span class="d_keyword">while</span> (n--)
    exp();
}

<span class="d_keyword">void</span> test() {
  <span class="d_keyword">int</span> x;
  dotimes(3, writefln(x++));
}
</span></pre>

        <p>prints to the console:</p>

<pre class="console"><span class="notranslate">0
1
2
</span></pre>

        <p>A lazy parameter of type <tt>void</tt> can accept an argument
        of any type.</p>

<h3>Function Default Arguments</h3>

        <p>Function parameter declarations can have default values:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y = 3) {
  ...
}
...
foo(4);   <span class="d_comment">// same as foo(4, 3);
</span></span></pre>

        <p>Default parameters are evaluated in the context of the
        function declaration.
        If the default value for a parameter is given, all following
        parameters must also have default values.
        </p>

<a name="variadic"><h2>Variadic Functions</h2></a>

        Functions taking a variable number of arguments are called
        variadic functions. A variadic function can take one of
        three forms:

        <ol>       <li>C-style variadic functions</li>
        <li>Variadic functions with type info</li>
        <li>Typesafe variadic functions</li>
        </ol>


<h3>C-style Variadic Functions</h3>

        A C-style variadic function is declared as taking
        a parameter of ... after the required function parameters.
        It has non-D linkage, such as <tt>extern (C)</tt>:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">extern</span> (C) <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y, ...);

foo(3, 4);      <span class="d_comment">// ok
</span>foo(3, 4, 6.8); <span class="d_comment">// ok, one variadic argument
</span>foo(2);         <span class="d_comment">// error, y is a required argument
</span></span></pre>

        There must be at least one non-variadic parameter declared.

<pre class="d_code"><span class="notranslate"><span class="d_keyword">extern</span> (C) <span class="d_keyword">int</span> def(...); <span class="d_comment">// error, must have at least one parameter
</span></span></pre>

        C-style variadic functions match the C calling convention for
        variadic functions, and is most useful for calling C library
        functions like <tt>printf</tt>.
        The implementiations of these variadic functions have a special
        local variable declared for them,
        <b>_argptr</b>, which is a <tt>void*</tt> pointer to the first of the
        variadic
        arguments. To access the arguments, <b>_argptr</b> must be cast
        to a pointer to the expected argument type:

<pre class="d_code"><span class="notranslate">foo(3, 4, 5);   <span class="d_comment">// first variadic argument is 5
</span>
<span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y, ...) {
  <span class="d_keyword">int</span> z;

  z = *<span class="d_keyword">cast</span>(<span class="d_keyword">int</span>*)<b>_argptr</b>; <span class="d_comment">// z is set to 5
</span>}
</span></pre>

        To protect against the vagaries of stack layouts on different
        CPU architectures, use <b>std.c.stdarg</b> to access the variadic
        arguments:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> <b>std.c.stdarg</b>;
</span></pre>

<h3>D-style Variadic Functions</h3>

        Variadic functions with argument and type info are declared as taking
        a parameter of ... after the required function parameters.
        It has D linkage, and need not have any non-variadic parameters
        declared:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> abc(<span class="d_keyword">char</span> c, ...);   <span class="d_comment">// one required parameter: c
</span><span class="d_keyword">int</span> def(...);           <span class="d_comment">// ok
</span></span></pre>

        These variadic functions have a special local variable declared for
        them,
        <b>_argptr</b>, which is a <tt>void*</tt> pointer to the first of the
        variadic
        arguments. To access the arguments, <b>_argptr</b> must be cast
        to a pointer to the expected argument type:

<pre class="d_code"><span class="notranslate">foo(3, 4, 5);   <span class="d_comment">// first variadic argument is 5
</span>
<span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y, ...) {
  <span class="d_keyword">int</span> z;

  z = *<span class="d_keyword">cast</span>(<span class="d_keyword">int</span>*)<b>_argptr</b>; <span class="d_comment">// z is set to 5
</span>}
</span></pre>

        An additional hidden argument
        with the name <b>_arguments</b> and type <tt>TypeInfo[]</tt>
        is passed to the function.
        <b>_arguments</b> gives the number of arguments and the type
        of each, enabling the creation of typesafe variadic functions.

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">class</span> Foo { <span class="d_keyword">int</span> x = 3; }
<span class="d_keyword">class</span> Bar { <span class="d_keyword">long</span> y = 4; }

<span class="d_keyword">void</span> printargs(<span class="d_keyword">int</span> x, ...) {
  writefln(<span class="d_string">"%d arguments"</span>, <b>_arguments</b>.length);
  <span class="d_keyword">for</span> (<span class="d_keyword">int</span> i = 0; i &lt; <b>_arguments</b>.length; i++)
  {
    <b>_arguments</b>[i].print();

    <span class="d_keyword">if</span> (<b>_arguments</b>[i] == <span class="d_keyword">typeid</span>(<span class="d_keyword">int</span>))
    {
      <span class="d_keyword">int</span> j = *<span class="d_keyword">cast</span>(<span class="d_keyword">int</span> *)_argptr;
      _argptr += <span class="d_keyword">int</span>.sizeof;
      writefln(<span class="d_string">"\t%d"</span>, j);
    }
    <span class="d_keyword">else</span> <span class="d_keyword">if</span> (<b>_arguments</b>[i] == <span class="d_keyword">typeid</span>(<span class="d_keyword">long</span>))
    {
      <span class="d_keyword">long</span> j = *<span class="d_keyword">cast</span>(<span class="d_keyword">long</span> *)_argptr;
      _argptr += <span class="d_keyword">long</span>.sizeof;
      writefln(<span class="d_string">"\t%d"</span>, j);
    }
    <span class="d_keyword">else</span> <span class="d_keyword">if</span> (<b>_arguments</b>[i] == <span class="d_keyword">typeid</span>(<span class="d_keyword">double</span>))
    {
      <span class="d_keyword">double</span> d = *<span class="d_keyword">cast</span>(<span class="d_keyword">double</span> *)_argptr;
      _argptr += <span class="d_keyword">double</span>.sizeof;
      writefln(<span class="d_string">"\t%g"</span>, d);
    }
    <span class="d_keyword">else</span> <span class="d_keyword">if</span> (<b>_arguments</b>[i] == <span class="d_keyword">typeid</span>(Foo))
    {
      Foo f = *<span class="d_keyword">cast</span>(Foo*)_argptr;
      _argptr += Foo.sizeof;
      writefln(<span class="d_string">"\t%X"</span>, f);
    }
    <span class="d_keyword">else</span> <span class="d_keyword">if</span> (<b>_arguments</b>[i] == <span class="d_keyword">typeid</span>(Bar))
    {
      Bar b = *<span class="d_keyword">cast</span>(Bar*)_argptr;
      _argptr += Bar.sizeof;
      writefln(<span class="d_string">"\t%X"</span>, b);
    }
    <span class="d_keyword">else</span>
      <span class="d_keyword">assert</span>(0);
  }
}

<span class="d_keyword">void</span> main() {
  Foo f = <span class="d_keyword">new</span> Foo();
  Bar b = <span class="d_keyword">new</span> Bar();

  writefln(<span class="d_string">"%X"</span>, f);
  printargs(1, 2, 3L, 4.5, f, b);
}
</span></pre>

        which prints:

<pre class="d_code"><span class="notranslate">00870FE0
5 arguments
<span class="d_keyword">int</span>
        2
<span class="d_keyword">long</span>
        3
<span class="d_keyword">double</span>
        4.5
Foo
        00870FE0
Bar
        00870FD0
</span></pre>

        To protect against the vagaries of stack layouts on different
        CPU architectures, use <b>std.stdarg</b> to access the variadic
        arguments:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">import</span> <b>std.stdarg</b>;

<span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> x, ...) {
  writefln(<span class="d_string">"%d arguments"</span>, _arguments.length);
  <span class="d_keyword">for</span> (<span class="d_keyword">int</span> i = 0; i &lt; _arguments.length; i++)
  {
    _arguments[i].print();

    <span class="d_keyword">if</span> (_arguments[i] == <span class="d_keyword">typeid</span>(<span class="d_keyword">int</span>))
    {
      <span class="d_keyword">int</span> j = <b>va_arg</b>!(<span class="d_keyword">int</span>)(_argptr);
      writefln(<span class="d_string">"\t%d"</span>, j);
    }
    <span class="d_keyword">else</span> <span class="d_keyword">if</span> (_arguments[i] == <span class="d_keyword">typeid</span>(<span class="d_keyword">long</span>))
    {
      <span class="d_keyword">long</span> j = <b>va_arg</b>!(<span class="d_keyword">long</span>)(_argptr);
      writefln(<span class="d_string">"\t%d"</span>, j);
    }
    <span class="d_keyword">else</span> <span class="d_keyword">if</span> (_arguments[i] == <span class="d_keyword">typeid</span>(<span class="d_keyword">double</span>))
    {
      <span class="d_keyword">double</span> d = <b>va_arg</b>!(<span class="d_keyword">double</span>)(_argptr);
      writefln(<span class="d_string">"\t%g"</span>, d);
    }
    <span class="d_keyword">else</span> <span class="d_keyword">if</span> (_arguments[i] == <span class="d_keyword">typeid</span>(FOO))
    {
      FOO f = <b>va_arg</b>!(FOO)(_argptr);
      writefln(<span class="d_string">"\t%X"</span>, f);
    }
    <span class="d_keyword">else</span>
      <span class="d_keyword">assert</span>(0);
  }
}
</span></pre>

<h3>Typesafe Variadic Functions</h3>

        Typesafe variadic functions are used when the variable argument
        portion of the arguments are used to construct an array or
        class object.
        <p>

        For arrays:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> test() {
  <span class="d_keyword">return</span> sum(1, 2, 3) + sum(); <span class="d_comment">// returns 6+0
</span>}

<span class="d_keyword">int</span> func() {
  <span class="d_keyword">int</span>[3] ii = [4, 5, 6];
  <span class="d_keyword">return</span> sum(ii);             <span class="d_comment">// returns 15
</span>}

<span class="d_keyword">int</span> sum(<span class="d_keyword">int</span>[] ar ...) {
  <span class="d_keyword">int</span> s;
  <span class="d_keyword">foreach</span> (<span class="d_keyword">int</span> x; ar)
    s += x;
  <span class="d_keyword">return</span> s;
}
</span></pre>

        For static arrays:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> test() {
  <span class="d_keyword">return</span> sum(2, 3);   <span class="d_comment">// error, need 3 values for array
</span>  <span class="d_keyword">return</span> sum(1, 2, 3); <span class="d_comment">// returns 6
</span>}

<span class="d_keyword">int</span> func() {
  <span class="d_keyword">int</span>[3] ii = [4, 5, 6];
  <span class="d_keyword">int</span>[] jj = ii;
  <span class="d_keyword">return</span> sum(ii); <span class="d_comment">// returns 15
</span>  <span class="d_keyword">return</span> sum(jj); <span class="d_comment">// error, type mismatch
</span>}

<span class="d_keyword">int</span> sum(<span class="d_keyword">int</span>[3] ar ...) {
  <span class="d_keyword">int</span> s;
  <span class="d_keyword">foreach</span> (<span class="d_keyword">int</span> x; ar)
    s += x;
  <span class="d_keyword">return</span> s;
}
</span></pre>

        For class objects:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> Foo {
  <span class="d_keyword">int</span> x;
  string s;

  <span class="d_keyword">this</span>(<span class="d_keyword">int</span> x, string s) {
    <span class="d_keyword">this</span>.x = x;
    <span class="d_keyword">this</span>.s = s;
  }
}

<span class="d_keyword">void</span> test(<span class="d_keyword">int</span> x, Foo f ...);

...

Foo g = <span class="d_keyword">new</span> Foo(3, <span class="d_string">"abc"</span>);
test(1, g);         <span class="d_comment">// ok, since g is an instance of Foo
</span>test(1, 4, <span class="d_string">"def"</span>);  <span class="d_comment">// ok
</span>test(1, 5);         <span class="d_comment">// error, no matching constructor for Foo
</span></span></pre>

        An implementation may construct the object or array instance
        on the stack. Therefore, it is an error to refer to that
        instance after the variadic function has returned:

<pre class="d_code"><span class="notranslate">Foo test(Foo f ...) {
  <span class="d_keyword">return</span> f;   <span class="d_comment">// error, f instance contents invalid after return
</span>}

<span class="d_keyword">int</span>[] test(<span class="d_keyword">int</span>[] a ...) {
  <span class="d_keyword">return</span> a;       <span class="d_comment">// error, array contents invalid after return
</span>  <span class="d_keyword">return</span> a[0..1]; <span class="d_comment">// error, array contents invalid after return
</span>  <span class="d_keyword">return</span> a.dup;   <span class="d_comment">// ok, since copy is made
</span>}
</span></pre>

        For other types, the argument is built with itself, as in:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> test(<span class="d_keyword">int</span> i ...) {
  <span class="d_keyword">return</span> i;
}

...
test(3);    <span class="d_comment">// returns 3
</span>test(3, 4); <span class="d_comment">// error, too many arguments
</span><span class="d_keyword">int</span>[] x;
test(x);    <span class="d_comment">// error, type mismatch
</span></span></pre>

<h3>Lazy Variadic Functions</h3>

        <p>If the variadic parameter is an array of delegates
        with no parameters:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>()[] dgs ...);
</span></pre>

        <p>Then each of the arguments whose type does not match that
        of the delegate is converted to a delegate.
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> <span class="d_keyword">delegate</span>() dg;
foo(1, 3+x, dg, <span class="d_keyword">cast</span>(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>())<span class="d_keyword">null</span>);
</span></pre>

        <p>is the same as:</p>

<pre class="d_code"><span class="notranslate">foo( { <span class="d_keyword">return</span> 1; }, { <span class="d_keyword">return</span> 3+x; }, dg, <span class="d_keyword">null</span> );
</span></pre>

<h2>Local Variables</h2>

        <p>It is an error to use a local variable without first assigning it a
        value. The implementation may not always be able to detect these
        cases. Other language compilers sometimes issue a warning for this,
        but since it is always a bug, it should be an error.
        </p>

        <p>It is an error to declare a local variable that is never referred to.
        Dead variables, like anachronistic dead code, are just a source of
        confusion for maintenance programmers.
        </p>

        <p>It is an error to declare a local variable that hides another local
        variable in the same function:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">void</span> func(<span class="d_keyword">int</span> x) {
   <span class="d_keyword">int</span> x;     <span class="d_comment">// error, hides previous definition of x
</span>   <span class="d_keyword">double</span> y;
   ...
   { <span class="d_keyword">char</span> y;  <span class="d_comment">// error, hides previous definition of y
</span>     <span class="d_keyword">int</span> z;
   }
   { <span class="d_keyword">wchar</span> z; <span class="d_comment">// legal, previous z is out of scope
</span>   }
}
</span></pre>

        <p>While this might look unreasonable, in practice whenever
        this is done it either is a
        bug or at least looks like a bug.
        </p>

        <p>It is an error to return the address of or a reference to a
        local variable.
        </p>

        <p>It is an error to have a local variable and a label with the same
        name.
        </p>

<h2><a name="nested">Nested Functions</a></h2>

        <p>Functions may be nested within other functions:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> bar(<span class="d_keyword">int</span> a) {
  <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> b) {
    <span class="d_keyword">int</span> abc() { <span class="d_keyword">return</span> 1; }

    <span class="d_keyword">return</span> b + abc();
  }
  <span class="d_keyword">return</span> foo(a);
}

<span class="d_keyword">void</span> test() {
  <span class="d_keyword">int</span> i = bar(3); <span class="d_comment">// i is assigned 4
</span>}
</span></pre>

        <p>Nested functions can be accessed only if the name is in scope.</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">void</span> foo()
{
  <span class="d_keyword">void</span> A()
  {
    B(); <span class="d_comment">// error, B() is forward referenced
</span>    C(); <span class="d_comment">// error, C undefined
</span>  }
  <span class="d_keyword">void</span> B()
  {
    A(); <span class="d_comment">// ok, in scope
</span>    <span class="d_keyword">void</span> C()
    {
      <span class="d_keyword">void</span> D()
      {
        A();      <span class="d_comment">// ok
</span>        B();      <span class="d_comment">// ok
</span>        C();      <span class="d_comment">// ok
</span>        D();      <span class="d_comment">// ok
</span>      }
    }
  }
  A(); <span class="d_comment">// ok
</span>  B(); <span class="d_comment">// ok
</span>  C(); <span class="d_comment">// error, C undefined
</span>}
</span></pre>

        <p>and:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> bar(<span class="d_keyword">int</span> a) {
  <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> b) { <span class="d_keyword">return</span> b + 1; }
  <span class="d_keyword">int</span> abc(<span class="d_keyword">int</span> b) { <span class="d_keyword">return</span> foo(b); }   <span class="d_comment">// ok
</span>  <span class="d_keyword">return</span> foo(a);
}

<span class="d_keyword">void</span> test() {
  <span class="d_keyword">int</span> i = bar(3);     <span class="d_comment">// ok
</span>  <span class="d_keyword">int</span> j = bar.foo(3); <span class="d_comment">// error, bar.foo not visible
</span>}
</span></pre>

        <p>Nested functions have access to the variables and other symbols
        defined by the lexically enclosing function.
        This access includes both the ability to read and write them.
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> bar(<span class="d_keyword">int</span> a) {
  <span class="d_keyword">int</span> c = 3;

  <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> b) {
    b += c;       <span class="d_comment">// 4 is added to b
</span>    c++;          <span class="d_comment">// bar.c is now 5
</span>    <span class="d_keyword">return</span> b + c; <span class="d_comment">// 12 is returned
</span>  }
  c = 4;
  <span class="d_keyword">int</span> i = foo(a); <span class="d_comment">// i is set to 12
</span>  <span class="d_keyword">return</span> i + c;   <span class="d_comment">// returns 17
</span>}

<span class="d_keyword">void</span> test() {
  <span class="d_keyword">int</span> i = bar(3); <span class="d_comment">// i is assigned 17
</span>}
</span></pre>

        <p>This access can span multiple nesting levels:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> bar(<span class="d_keyword">int</span> a) {
  <span class="d_keyword">int</span> c = 3;

  <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> b) {
      <span class="d_keyword">int</span> abc() {
          <span class="d_keyword">return</span> c;   <span class="d_comment">// access bar.c
</span>      }
      <span class="d_keyword">return</span> b + c + abc();
  }
  <span class="d_keyword">return</span> foo(3);
}
</span></pre>

        <p>Static nested functions cannot access any stack variables of
        any lexically enclosing function, but can access static variables.
        This is analogous to how static member functions behave.
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> bar(<span class="d_keyword">int</span> a) {
  <span class="d_keyword">int</span> c;
  <span class="d_keyword">static</span> <span class="d_keyword">int</span> d;

  <span class="d_keyword">static</span> <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> b) {
    b = d;          <span class="d_comment">// ok
</span>    b = c;          <span class="d_comment">// error, foo() cannot access frame of bar()
</span>    <span class="d_keyword">return</span> b + 1;
  }
  <span class="d_keyword">return</span> foo(a);
}
</span></pre>

        <p>Functions can be nested within member functions:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">struct</span> Foo {
  <span class="d_keyword">int</span> a;

  <span class="d_keyword">int</span> bar() {
    <span class="d_keyword">int</span> c;

    <span class="d_keyword">int</span> foo() {
      <span class="d_keyword">return</span> c + a;
    }
    <span class="d_keyword">return</span> 0;
  }
}
</span></pre>

        <p>Member functions of nested classes and structs do not have
        access to the stack variables of the enclosing function, but
        do have access to the other symbols:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">void</span> test() {
  <span class="d_keyword">int</span> j;
  <span class="d_keyword">static</span> <span class="d_keyword">int</span> s;

  <span class="d_keyword">struct</span> Foo {
    <span class="d_keyword">int</span> a;

    <span class="d_keyword">int</span> bar() {
      <span class="d_keyword">int</span> c = s;  <span class="d_comment">// ok, s is static
</span>      <span class="d_keyword">int</span> d = j;  <span class="d_comment">// error, no access to frame of test()
</span>
      <span class="d_keyword">int</span> foo() {
        <span class="d_keyword">int</span> e = s;    <span class="d_comment">// ok, s is static
</span>        <span class="d_keyword">int</span> f = j;    <span class="d_comment">// error, no access to frame of test()
</span>        <span class="d_keyword">return</span> c + a; <span class="d_comment">// ok, frame of bar() is accessible,
</span>                      <span class="d_comment">// so are members of Foo accessible via
</span>                      <span class="d_comment">// the 'this' pointer to Foo.bar()
</span>      }

      <span class="d_keyword">return</span> 0;
    }
  }
}
</span></pre>

        <p>Nested functions always have the D function linkage type.
        </p>

        <p>Unlike module level declarations, declarations within function
        scope are processed in order. This means that two nested functions
        cannot mutually call each other:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">void</span> test() {
  <span class="d_keyword">void</span> foo() { bar(); } <span class="d_comment">// error, bar not defined
</span>  <span class="d_keyword">void</span> bar() { foo(); } <span class="d_comment">// ok
</span>}
</span></pre>

        <p>The solution is to use a delegate:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">void</span> test() {
  <span class="d_keyword">void</span> <span class="d_keyword">delegate</span>() fp;
  <span class="d_keyword">void</span> foo() { fp(); }
  <span class="d_keyword">void</span> bar() { foo(); }
  fp = &amp;bar;
}
</span></pre>

        <p><b>Future directions:</b> This restriction may be removed.</p>


<h3><a name="closures">Delegates, Function Pointers, and  Closures</a></h3>

        <p>A function pointer can point to a static nested function:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> <span class="d_keyword">function</span>() fp;

<span class="d_keyword">void</span> test() {
  <span class="d_keyword">static</span> <span class="d_keyword">int</span> a = 7;
  <span class="d_keyword">static</span> <span class="d_keyword">int</span> foo() { <span class="d_keyword">return</span> a + 3; }

  fp = &amp;foo;
}

<span class="d_keyword">void</span> bar() {
  test();
  <span class="d_keyword">int</span> i = fp();       <span class="d_comment">// i is set to 10
</span>}
</span></pre>

        <p>A delegate can be set to a non-static nested function:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> <span class="d_keyword">delegate</span>() dg;

<span class="d_keyword">void</span> test() {
  <span class="d_keyword">int</span> a = 7;
  <span class="d_keyword">int</span> foo() { <span class="d_keyword">return</span> a + 3; }

  dg = &amp;foo;
  <span class="d_keyword">int</span> i = dg(); <span class="d_comment">// i is set to 10
</span>}
</span></pre>


       <p>The stack variables referenced by a nested function are
        still valid even after the function exits (this is different
        from D 1.0). This is called a <i>closure</i>.
        Returning addresses of stack variables, however, is not
        a closure and is an error.
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span>* bar() {
  <span class="d_keyword">int</span> b;
  test();
  <span class="d_keyword">int</span> i = dg(); <span class="d_comment">// ok, test.a is in a closure and still exists
</span>  <span class="d_keyword">return</span> &amp;b;    <span class="d_comment">// error, bar.b not valid after bar() exits
</span>}
</span></pre>


        <p>Delegates to non-static nested functions contain two pieces of
        data: the pointer to the stack frame of the lexically enclosing
        function (called the <i>frame pointer</i>) and the address of the
        function. This is analogous to struct/class non-static member
        function delegates consisting of a <i>this</i> pointer and
        the address of the member function.
        Both forms of delegates are interchangeable, and are actually
        the same type:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">struct</span> Foo {
  <span class="d_keyword">int</span> a = 7;
  <span class="d_keyword">int</span> bar() { <span class="d_keyword">return</span> a; }
}

<span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>() dg) {
  <span class="d_keyword">return</span> dg() + 1;
}

<span class="d_keyword">void</span> test() {
  <span class="d_keyword">int</span> x = 27;
  <span class="d_keyword">int</span> abc() { <span class="d_keyword">return</span> x; }
  Foo f;
  <span class="d_keyword">int</span> i;

  i = foo(&amp;abc);   <span class="d_comment">// i is set to 28
</span>  i = foo(&amp;f.bar); <span class="d_comment">// i is set to 8
</span>}
</span></pre>

        <p>This combining of the environment and the function is called
        a <i>dynamic closure</i>.
        </p>

        <p>The <b>.ptr</b> property of a delegate will return the
        <i>frame pointer</i> value as a <tt>void*</tt>.
        </p>

        <p>The <b>.funcptr</b> property of a delegate will return the
        <i>function pointer</i> value as a function type.
        </p>

        <p><b>Future directions:</b> Function pointers and delegates may merge
        into a common syntax and be interchangeable with each other.
        </p>

<h3>Anonymous Functions and Anonymous Delegates</h3>

        <p>See <a href="expression.html#FunctionLiteral">Function Literals</a>.
        </p>

<h2>main() Function</h2>

        <p>For console programs, <tt>main()</tt> serves as the entry point.
        It gets called after all the module initializers are run, and
        after any unittests are run.
        After it returns, all the module destructors are run.
        <tt>main()</tt> must be declared using one of the following forms:
        </p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">void</span> main() { ... }
<span class="d_keyword">void</span> main(<span class="d_keyword">char</span>[][] args) { ... }
<span class="d_keyword">int</span> main() { ... }
<span class="d_keyword">int</span> main(<span class="d_keyword">char</span>[][] args) { ... }
</span></pre>

<h2><a name="interpretation">Compile Time Function Execution (CTFE)</a></h2>

        <p>A subset of functions can be executed at compile time.
        This is useful when constant folding algorithms need to
        include recursion and looping.
        In order to be executed at compile time, a function must
        meet the following criteria:
        </p>

        <ol>        <li>function arguments must all be:
            <ul>               <li>integer literals</li>
                <li>floating point literals</li>
                <li>character literals</li>
                <li>string literals</li>
                <li>array literals where the members are all items
                in this list</li>
                <li>associative array literals where the members are all items
                in this list</li>
                <li>struct literals where the members are all items
                in this list</li>
                <li>const variables initialized with a member of
                this list</li>
                <li>delegates</li>
                <li>pointers to functions</li>
                <li>delegate literals</li>
                <li>function literals</li>
            </ul>
        </li>

        <li>function parameters may not be C-style variadic</li>

        <li>the function may not be synchronized</li>

        <li>expressions in the function may not:
            <ul>               <li>throw exceptions</li>
                <li>use pointers or classes</li>
                <li>reference any global state or variables</li>
                <li>reference any local static variables</li>
                <li>delete</li>
                <li>call any function that is not
                executable at compile time</li>
            </ul>
        </li>

        <li>the following statement types are not allowed:
            <ul>               <li>synchronized statements</li>
                <li>throw statements</li>
                <li>with statements</li>
                <li>scope statements</li>
                <li>try-catch-finally statements</li>
                <li>labeled break and continue statements</li>
             </ul>
        </li>

        <li>as a special case, the following properties
        can be executed at compile time:
                <table border=1 cellpadding=4 cellspacing=0>               <tr><td><tt><span class="notranslate">.dup</span></tt></td></tr>
                <tr><td><tt><span class="notranslate">.length</span></tt></td></tr>
                <tr><td><tt><span class="notranslate">.keys</span></tt></td></tr>
                <tr><td><tt><span class="notranslate">.values</span></tt></td></tr>
                </table>
        </li>

        </ol>

        <p>In order to be executed at compile time, the function
        must appear in a context where it must be so executed, for
        example:</p>

        <ul>       <li>initialization of a static variable</li>
        <li>dimension of a static array</li>
        <li>argument for a template value parameter</li>
        </ul>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">template</span> eval( A... ) {
  <span class="d_keyword">const</span> <span class="d_keyword">typeof</span>(A[0]) eval = A[0];
}

<span class="d_keyword">int</span> square(<span class="d_keyword">int</span> i) {
   <span class="d_keyword">return</span> i * i;
}

<span class="d_keyword">void</span> foo() {
  <span class="d_keyword">static</span> j = square(3);     <span class="d_comment">// compile time
</span>  writefln(j);
  writefln(square(4));      <span class="d_comment">// run time
</span>  writefln(eval!(square(5))); <span class="d_comment">// compile time
</span>}
</span></pre>

        <p>Executing functions at compile time can take considerably
        longer than executing it at run time.
        If the function goes into an infinite loop, it will hang at
        compile time (rather than hanging at run time).
        </p>

        <p>Functions executed at compile time can give different results
        from run time in the following scenarios:
        </p>

        <ul>        <li>floating point computations may be done at a higher
        precision than run time</li>
        <li>dependency on implementation defined order of evaluation</li>
        <li>use of uninitialized variables</li>

        </ul>

        <p>These are the same kinds of scenarios where different
        optimization settings affect the results.</p>

<h3>String Mixins and Compile Time Function Execution</h3>

        <p>Any functions that execute at compile time must also
        be executable at run time. The compile time evaluation of
        a function does the equivalent of running the function at
        run time. This means that the semantics of a function cannot
        depend on compile time values of the function. For example:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">int</span> foo(<span class="d_keyword">char</span>[] s) {
  <span class="d_keyword">return</span> <span class="d_keyword">mixin</span>(s);
}

<span class="d_keyword">const</span> <span class="d_keyword">int</span> x = foo(<span class="d_string">"1"</span>);
</span></pre>

        <p>is illegal, because the runtime code for foo() cannot be
        generated. A function template would be the appropriate
        method to implement this sort of thing.</p>

<h2><a name="function-safety">Function Safety</a></h2>

        <p><i>Safe functions</i> are functions that are statically checked
        to exhibit no possibility of
        <a href="glossary.html#undefined_behavior"><i>undefined behavior</i></a>.
        Undefined behavior is often used as a vector for malicious
        attacks.
        </p>

<h3><a name="safe-functions">Safe Functions</a></h3>

        <p>Safe functions are marked with the <tt><span class="notranslate">@safe</span></tt> attribute.</p>

        <p>The following operations are not allowed in safe
        functions:</p>

        <ul>       <li>No casting from a pointer type to any type other than <tt><span class="notranslate">void*</span></tt>.</li>
        <li>No casting from any non-pointer type to a pointer type.</li>
        <li>No modification of pointer values.</li>
        <li>Cannot access unions that have pointers or references overlapping
        with other types.</li>
        <li>Calling any system functions.</li>
        <li>No catching of exceptions that are not derived from <tt><span class="notranslate">class Exception</span></tt>.</li>
        <li>No inline assembler.</li>
        <li>No explicit casting of mutable objects to immutable.</li>
        <li>No explicit casting of immutable objects to mutable.</li>
        <li>No explicit casting of thread local objects to shared.</li>
        <li>No explicit casting of shared objects to thread local.</li>
        <li>No taking the address of a local variable or function parameter.</li>
        <li>Cannot access <span class="d_keyword">__gshared</span> variables.</li>
        </ul>

        <p>Functions nested inside safe functions default to being
        safe functions.
        </p>

        <p>Safe functions are covariant with trusted or system functions.</p>

        <p><b>Note:</b> The verifiable safety of functions may be compromised by
        bugs in the compiler and specification. Please report all such errors
        so they can be corrected.
        </p>

<h3><a name="trusted-functions">Trusted Functions</a></h3>

        <p>Trusted functions are marked with the <tt><span class="notranslate">@trusted</span></tt> attribute.</p>

        <p>Trusted functions are guaranteed by the programmer to not exhibit
        any undefined behavior if called by a safe function.
        Generally, trusted functions should be kept small so that they are
        easier to manually verify.
        </p>

        <p>Trusted functions may call safe, trusted, or system functions.
        </p>

        <p>Trusted functions are covariant with safe or system functions.</p>

<h3><a name="system-functions">System Functions</a></h3>

        <p>System functions are functions not marked with <tt><span class="notranslate">@safe</span></tt> or
        <tt><span class="notranslate">@trusted</span></tt>
        and are not nested inside <tt><span class="notranslate">@safe</span></tt> functions.
        System functions may be marked with the <tt><span class="notranslate">@system</span></tt> attribute.
        A function being system does not mean it actually is unsafe, it just
        means that the compiler is unable to verify that it cannot exhibit
        undefined behavior.
        </p>

        <p>System functions are <b>not</b> covariant with trusted or safe functions.
        </p>


<h2><a name="function-attribute-inference">Function Attribute Inference</a></h2>

        <p><a href="expression.html#FunctionLiteral"><i>FunctionLiteral</i></a>s and
        <a href="template.html#function-templates">function template</a>s, since their function bodies
        are always present, infer the
        <a href="#pure-functions"><b>pure</b></a>,
        <a href="#nothrow-functions"><b>nothrow</b></a>, and
        <a href="#safe-functions"><b>@safe</b></a> attributes unless
        specifically overridden.
        </p>

        <p>Attribute inference is not done for other functions, even if the function
        body is present.
        </p>

        <p>The inference is done by determining if the function body follows the
        rules of the particular attribute.
        </p>

        <p>Cyclic functions (i.e. functions that wind up directly or indirectly
        calling themselves) are inferred as being impure, throwing, and @system.
        </p>

        <p>If a function attempts to test itself for those attributes, then
        the function is inferred as not having those attributes.
        </p>



  
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="3651639259";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

</div>




<div id="footernav">
<a href="http://www.digitalmars.com/NewsGroup.html" title="User Forums">Forums</a> |
<a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/Function" title="Read/write comments and feedback">Comments</a> |
<a href="index.html" title="D Programming Language" class="dlink">&nbsp;D&nbsp;</a> |
<a href="http://www.digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a> |
<a href="http://www.digitalmars.com/d/download.html" title="download D">Downloads</a> |
<a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a>
</div>
<div id="copyright">

Copyright &copy; 1999-2011 by Digital Mars &reg;, All Rights Reserved
 |
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>


<script src="http://completelyexpendable.info/editable_code.js"></script>
</body>
</html>

